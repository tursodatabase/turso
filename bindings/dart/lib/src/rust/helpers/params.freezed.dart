// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'params.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$Params {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(List<Value> field0) positional,
    required TResult Function(List<(String, Value)> field0) named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(List<Value> field0)? positional,
    TResult? Function(List<(String, Value)> field0)? named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(List<Value> field0)? positional,
    TResult Function(List<(String, Value)> field0)? named,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Params_None value) none,
    required TResult Function(Params_Positional value) positional,
    required TResult Function(Params_Named value) named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Params_None value)? none,
    TResult? Function(Params_Positional value)? positional,
    TResult? Function(Params_Named value)? named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Params_None value)? none,
    TResult Function(Params_Positional value)? positional,
    TResult Function(Params_Named value)? named,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParamsCopyWith<$Res> {
  factory $ParamsCopyWith(Params value, $Res Function(Params) then) =
      _$ParamsCopyWithImpl<$Res, Params>;
}

/// @nodoc
class _$ParamsCopyWithImpl<$Res, $Val extends Params>
    implements $ParamsCopyWith<$Res> {
  _$ParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Params
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$Params_NoneImplCopyWith<$Res> {
  factory _$$Params_NoneImplCopyWith(
    _$Params_NoneImpl value,
    $Res Function(_$Params_NoneImpl) then,
  ) = __$$Params_NoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Params_NoneImplCopyWithImpl<$Res>
    extends _$ParamsCopyWithImpl<$Res, _$Params_NoneImpl>
    implements _$$Params_NoneImplCopyWith<$Res> {
  __$$Params_NoneImplCopyWithImpl(
    _$Params_NoneImpl _value,
    $Res Function(_$Params_NoneImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Params
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$Params_NoneImpl extends Params_None {
  const _$Params_NoneImpl() : super._();

  @override
  String toString() {
    return 'Params.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Params_NoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(List<Value> field0) positional,
    required TResult Function(List<(String, Value)> field0) named,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(List<Value> field0)? positional,
    TResult? Function(List<(String, Value)> field0)? named,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(List<Value> field0)? positional,
    TResult Function(List<(String, Value)> field0)? named,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Params_None value) none,
    required TResult Function(Params_Positional value) positional,
    required TResult Function(Params_Named value) named,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Params_None value)? none,
    TResult? Function(Params_Positional value)? positional,
    TResult? Function(Params_Named value)? named,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Params_None value)? none,
    TResult Function(Params_Positional value)? positional,
    TResult Function(Params_Named value)? named,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class Params_None extends Params {
  const factory Params_None() = _$Params_NoneImpl;
  const Params_None._() : super._();
}

/// @nodoc
abstract class _$$Params_PositionalImplCopyWith<$Res> {
  factory _$$Params_PositionalImplCopyWith(
    _$Params_PositionalImpl value,
    $Res Function(_$Params_PositionalImpl) then,
  ) = __$$Params_PositionalImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Value> field0});
}

/// @nodoc
class __$$Params_PositionalImplCopyWithImpl<$Res>
    extends _$ParamsCopyWithImpl<$Res, _$Params_PositionalImpl>
    implements _$$Params_PositionalImplCopyWith<$Res> {
  __$$Params_PositionalImplCopyWithImpl(
    _$Params_PositionalImpl _value,
    $Res Function(_$Params_PositionalImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Params
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? field0 = null}) {
    return _then(
      _$Params_PositionalImpl(
        null == field0
            ? _value._field0
            : field0 // ignore: cast_nullable_to_non_nullable
                as List<Value>,
      ),
    );
  }
}

/// @nodoc

class _$Params_PositionalImpl extends Params_Positional {
  const _$Params_PositionalImpl(final List<Value> field0)
      : _field0 = field0,
        super._();

  final List<Value> _field0;
  @override
  List<Value> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Params.positional(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Params_PositionalImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  /// Create a copy of Params
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Params_PositionalImplCopyWith<_$Params_PositionalImpl> get copyWith =>
      __$$Params_PositionalImplCopyWithImpl<_$Params_PositionalImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(List<Value> field0) positional,
    required TResult Function(List<(String, Value)> field0) named,
  }) {
    return positional(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(List<Value> field0)? positional,
    TResult? Function(List<(String, Value)> field0)? named,
  }) {
    return positional?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(List<Value> field0)? positional,
    TResult Function(List<(String, Value)> field0)? named,
    required TResult orElse(),
  }) {
    if (positional != null) {
      return positional(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Params_None value) none,
    required TResult Function(Params_Positional value) positional,
    required TResult Function(Params_Named value) named,
  }) {
    return positional(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Params_None value)? none,
    TResult? Function(Params_Positional value)? positional,
    TResult? Function(Params_Named value)? named,
  }) {
    return positional?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Params_None value)? none,
    TResult Function(Params_Positional value)? positional,
    TResult Function(Params_Named value)? named,
    required TResult orElse(),
  }) {
    if (positional != null) {
      return positional(this);
    }
    return orElse();
  }
}

abstract class Params_Positional extends Params {
  const factory Params_Positional(final List<Value> field0) =
      _$Params_PositionalImpl;
  const Params_Positional._() : super._();

  List<Value> get field0;

  /// Create a copy of Params
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Params_PositionalImplCopyWith<_$Params_PositionalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Params_NamedImplCopyWith<$Res> {
  factory _$$Params_NamedImplCopyWith(
    _$Params_NamedImpl value,
    $Res Function(_$Params_NamedImpl) then,
  ) = __$$Params_NamedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<(String, Value)> field0});
}

/// @nodoc
class __$$Params_NamedImplCopyWithImpl<$Res>
    extends _$ParamsCopyWithImpl<$Res, _$Params_NamedImpl>
    implements _$$Params_NamedImplCopyWith<$Res> {
  __$$Params_NamedImplCopyWithImpl(
    _$Params_NamedImpl _value,
    $Res Function(_$Params_NamedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Params
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? field0 = null}) {
    return _then(
      _$Params_NamedImpl(
        null == field0
            ? _value._field0
            : field0 // ignore: cast_nullable_to_non_nullable
                as List<(String, Value)>,
      ),
    );
  }
}

/// @nodoc

class _$Params_NamedImpl extends Params_Named {
  const _$Params_NamedImpl(final List<(String, Value)> field0)
      : _field0 = field0,
        super._();

  final List<(String, Value)> _field0;
  @override
  List<(String, Value)> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Params.named(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Params_NamedImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  /// Create a copy of Params
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Params_NamedImplCopyWith<_$Params_NamedImpl> get copyWith =>
      __$$Params_NamedImplCopyWithImpl<_$Params_NamedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(List<Value> field0) positional,
    required TResult Function(List<(String, Value)> field0) named,
  }) {
    return named(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function(List<Value> field0)? positional,
    TResult? Function(List<(String, Value)> field0)? named,
  }) {
    return named?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(List<Value> field0)? positional,
    TResult Function(List<(String, Value)> field0)? named,
    required TResult orElse(),
  }) {
    if (named != null) {
      return named(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Params_None value) none,
    required TResult Function(Params_Positional value) positional,
    required TResult Function(Params_Named value) named,
  }) {
    return named(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Params_None value)? none,
    TResult? Function(Params_Positional value)? positional,
    TResult? Function(Params_Named value)? named,
  }) {
    return named?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Params_None value)? none,
    TResult Function(Params_Positional value)? positional,
    TResult Function(Params_Named value)? named,
    required TResult orElse(),
  }) {
    if (named != null) {
      return named(this);
    }
    return orElse();
  }
}

abstract class Params_Named extends Params {
  const factory Params_Named(final List<(String, Value)> field0) =
      _$Params_NamedImpl;
  const Params_Named._() : super._();

  List<(String, Value)> get field0;

  /// Create a copy of Params
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Params_NamedImplCopyWith<_$Params_NamedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
