---
name: 2025-11-26-py-bindings
---

<Output path="./turso/lib.py">

<Code model="anthropic/claude-sonnet-4-5" language="python">

Turso - is the SQLite compatible database written in Rust.
One of the important features of the Turso - is async IO execution which can be used with modern storage backend like IO uring.

Generate Python driver using methods exported to the Python with pyo3 from Rust:
<File path="./src/lib.rs" />
<File path="./turso/__init__.py" />

# bindings

Bindings in the lib.rs written with `pyo3` library which has certain conventions.

Remember, that it can accept `py: Python` argument which will be passed implicitly and exported bindings will not have this extra arg

Checkout guide for class definitions from pyo3 official docs:
<Link url="https://raw.githubusercontent.com/PyO3/PyO3/refs/heads/main/guide/src/class.md" />

# SQLITE-LIKE DB API

Make driver API similar to the SQLite DB-API2 for the python.

Use following outline generated by the official DB-API 2.0 docs:
<Outline model="openai/gpt-4.1">

Generate outline of the sqlite3 python docs for the purpose of later reuse during implementation of sqlite-like bindings for another database.

Focus your attention on following things:
1. Transaction behaviour - commit/rollback/automatic behaviour
2. Parameters binding - how to bind positional/named parameters
3. API structure - what classes are used and what methods to they have
4. Error handling - what are the common errors which can be useful to back-port in the sqlite-bindings we will write later
5. Result structure - what are the fields which sqlite3 driver set and what is their purpose

Try to extract only essential parts. Ignore:
1. Backward compatibility nuances - we will write fresh driver
2. Niche features which very rarely used (including some weird error codes)

<Shell cmd="curl https://docs.python.org/3/library/sqlite3.html | pandoc --from html --to markdown" />

</Outline>

Pay additional attention to the following aspects:
1. SQLite DB-API2 implementation implicitly opens transaction for DML queries in the execute(...) method:
> If autocommit is LEGACY_TRANSACTION_CONTROL, isolation_level is not None, sql is an INSERT, UPDATE, DELETE, or REPLACE statement, and there is no open transaction, a transaction is implicitly opened before executing sql.

</Code>

</Output>