#!/usr/bin/env tclsh

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Basic CTE tests
do_execsql_test_on_specific_db {:memory:} cte-basic {
    WITH t AS (SELECT 1 as x) SELECT * FROM t;
} {1}

do_execsql_test_on_specific_db {:memory:} cte-multiple {
    WITH t1 AS (SELECT 1 as x), t2 AS (SELECT 2 as y) SELECT * FROM t1, t2;
} {1|2}

do_execsql_test_on_specific_db {:memory:} cte-chain {
    WITH a AS (SELECT 1 as x), b AS (SELECT x FROM a), c AS (SELECT x FROM b), d AS (SELECT x FROM c) SELECT * FROM d;
} {1}

# CTE with UNION (previously failed)
do_execsql_test_on_specific_db {:memory:} cte-union {
    WITH t AS (SELECT 1 as x UNION SELECT 2) SELECT * FROM t ORDER BY 1;
} {1
2}

# CTE with UNION ALL (previously failed)
do_execsql_test_on_specific_db {:memory:} cte-union-all {
    WITH t AS (SELECT 1 as x UNION ALL SELECT 2) SELECT * FROM t ORDER BY 1;
} {1
2}

# CTE with INTERSECT (previously failed)
do_execsql_test_on_specific_db {:memory:} cte-intersect {
    WITH t AS (SELECT 1 as x INTERSECT SELECT 1) SELECT * FROM t;
} {1}

# CTE with EXCEPT (previously failed)
do_execsql_test_on_specific_db {:memory:} cte-except {
    WITH t AS (SELECT 1 as x EXCEPT SELECT 2) SELECT * FROM t;
} {1}

# CTE with multiple UNIONs
do_execsql_test_on_specific_db {:memory:} cte-multiple-unions {
    WITH t AS (SELECT 1 as x UNION SELECT 2 UNION SELECT 3) SELECT * FROM t ORDER BY 1;
} {1
2
3}

# CTE with UNION referenced by another CTE
do_execsql_test_on_specific_db {:memory:} cte-union-ref {
    WITH t AS (SELECT 1 as x UNION SELECT 2), u AS (SELECT * FROM t) SELECT * FROM u ORDER BY 1;
} {1
2}

# CTE with UNION used multiple times
do_execsql_test_on_specific_db {:memory:} cte-union-multi-ref {
    WITH t AS (SELECT 1 as x UNION SELECT 2) SELECT * FROM t as a, t as b ORDER BY 1, 2;
} {1|1
1|2
2|1
2|2}

# CTE with UNION and aggregate
# Note: Column naming in compound select CTEs has a known limitation
# where aliases from the first SELECT are not propagated - this is a
# separate issue from compound query support in CTEs
do_execsql_test_on_specific_db {:memory:} cte-union-aggregate {
    WITH t AS (SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) SELECT COUNT(*) FROM t;
} {3}

# CTE with compound query and LIMIT
do_execsql_test_on_specific_db {:memory:} cte-union-limit {
    WITH t AS (SELECT 1 UNION SELECT 2 UNION SELECT 3 LIMIT 2) SELECT * FROM t ORDER BY 1;
} {1
2}

# CTE with compound query and LIMIT 1
do_execsql_test_on_specific_db {:memory:} cte-union-limit-one {
    WITH t AS (SELECT 1 UNION SELECT 2 LIMIT 1) SELECT * FROM t;
} {1}

# CTE with compound query and LIMIT + OFFSET
do_execsql_test_on_specific_db {:memory:} cte-union-limit-offset {
    WITH t AS (SELECT 1 UNION SELECT 2 UNION SELECT 3 LIMIT 2 OFFSET 1) SELECT * FROM t ORDER BY 1;
} {2
3}

# CTE with INTERSECT and LIMIT
do_execsql_test_on_specific_db {:memory:} cte-intersect-limit {
    WITH t AS (SELECT 1 INTERSECT SELECT 1 LIMIT 1) SELECT * FROM t;
} {1}

# CTE with EXCEPT and LIMIT
do_execsql_test_on_specific_db {:memory:} cte-except-limit {
    WITH t AS (SELECT 1 UNION SELECT 2 EXCEPT SELECT 2 LIMIT 2) SELECT * FROM t;
} {1}

# =============================================================================
# CTE with DML statements (INSERT, UPDATE, DELETE)
# =============================================================================

# CTE with INSERT - basic case
do_execsql_test_on_specific_db {:memory:} cte-insert-basic {
    CREATE TABLE t(x);
    WITH c AS (SELECT 1 as x) INSERT INTO t SELECT * FROM c;
    SELECT * FROM t;
} {1}

# CTE with INSERT - multiple rows via UNION
do_execsql_test_on_specific_db {:memory:} cte-insert-union {
    CREATE TABLE t(x);
    WITH c AS (SELECT 1 UNION SELECT 2 UNION SELECT 3) INSERT INTO t SELECT * FROM c;
    SELECT * FROM t ORDER BY 1;
} {1
2
3}

# CTE with INSERT - CTE chain
do_execsql_test_on_specific_db {:memory:} cte-insert-chain {
    CREATE TABLE t(x);
    WITH a AS (SELECT 1 as x), b AS (SELECT x + 10 FROM a) INSERT INTO t SELECT * FROM b;
    SELECT * FROM t;
} {11}

# CTE with DELETE - basic case
do_execsql_test_on_specific_db {:memory:} cte-delete-basic {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH vals AS (SELECT 1 as x) DELETE FROM t WHERE x IN (SELECT x FROM vals);
    SELECT * FROM t ORDER BY 1;
} {2
3}

# CTE with DELETE - multiple values via UNION (using SELECT *)
do_execsql_test_on_specific_db {:memory:} cte-delete-union {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3),(4);
    WITH odd AS (SELECT 1 UNION SELECT 3) DELETE FROM t WHERE x IN (SELECT * FROM odd);
    SELECT * FROM t ORDER BY 1;
} {2
4}

# CTE with DELETE - CTE chain
do_execsql_test_on_specific_db {:memory:} cte-delete-chain {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH a AS (SELECT 1 as x), b AS (SELECT x FROM a) DELETE FROM t WHERE x IN (SELECT x FROM b);
    SELECT * FROM t ORDER BY 1;
} {2
3}

# CTE with UPDATE - basic case in WHERE
do_execsql_test_on_specific_db {:memory:} cte-update-where {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH vals AS (SELECT 1 as x) UPDATE t SET x = x + 10 WHERE x IN (SELECT x FROM vals);
    SELECT * FROM t ORDER BY 1;
} {2
3
11}

# CTE with UPDATE - CTE chain in WHERE
do_execsql_test_on_specific_db {:memory:} cte-update-chain {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH a AS (SELECT 2 as x), b AS (SELECT x FROM a) UPDATE t SET x = x * 100 WHERE x IN (SELECT x FROM b);
    SELECT * FROM t ORDER BY 1;
} {1
3
200}

# CTE with multiple CTEs referenced in DML
# Note: Using SELECT * for compound CTEs due to known column naming limitation
do_execsql_test_on_specific_db {:memory:} cte-delete-multiple-ctes {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3),(4),(5);
    WITH low AS (SELECT 1 UNION SELECT 2), high AS (SELECT 4 UNION SELECT 5)
    DELETE FROM t WHERE x IN (SELECT * FROM low) OR x IN (SELECT * FROM high);
    SELECT * FROM t;
} {3}

# Multiple references to same CTE in WHERE clause (simple CTE without UNION)
do_execsql_test_on_specific_db {:memory:} cte-multi-ref-where {
    CREATE TABLE t(x, y);
    INSERT INTO t VALUES (1, 10), (2, 20), (3, 30);
    WITH vals AS (SELECT 2 as v)
    DELETE FROM t WHERE x IN (SELECT v FROM vals) AND y IN (SELECT v * 10 FROM vals);
    SELECT * FROM t ORDER BY 1;
} {1|10
3|30}

# CTE with INSERT and RETURNING
do_execsql_test_on_specific_db {:memory:} cte-insert-returning {
    CREATE TABLE t(x);
    WITH c AS (SELECT 42 as x) INSERT INTO t SELECT * FROM c RETURNING x;
} {42}

# CTE with DELETE and RETURNING
do_execsql_test_on_specific_db {:memory:} cte-delete-returning {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH vals AS (SELECT 2 as x) DELETE FROM t WHERE x IN (SELECT x FROM vals) RETURNING x;
} {2}

# CTE with UPDATE and RETURNING
do_execsql_test_on_specific_db {:memory:} cte-update-returning {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH vals AS (SELECT 1 as x) UPDATE t SET x = x + 100 WHERE x IN (SELECT x FROM vals) RETURNING x;
} {101}
