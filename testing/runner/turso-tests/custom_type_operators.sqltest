@database :memory:



@requires strict "uses STRICT tables"
test op-setup-same-type-both-columns {
    -- Both columns are the same custom type → operator fires.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, a test_uint, b test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 10, 5);
    INSERT INTO t1 VALUES (2, 3, 7);
    SELECT id, a + b FROM t1 ORDER BY id;
}
expect {
    1|15
    2|10
}

@requires strict "uses STRICT tables"
test op-same-type-where-eq {
    -- WHERE with = between two custom type columns.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, a test_uint, b test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 10, 10);
    INSERT INTO t1 VALUES (2, 3, 7);
    INSERT INTO t1 VALUES (3, 5, 5);
    SELECT id FROM t1 WHERE a = b ORDER BY id;
}
expect {
    1
    3
}

@requires strict "uses STRICT tables"
test op-same-type-where-lt {
    -- WHERE with < between two custom type columns.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, a test_uint, b test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 3, 10);
    INSERT INTO t1 VALUES (2, 20, 5);
    INSERT INTO t1 VALUES (3, 1, 1);
    SELECT id FROM t1 WHERE a < b ORDER BY id;
}
expect {
    1
}


@requires strict "uses STRICT tables"
test op-literal-add-integer {
    -- Integer literal + custom type column (value any).
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 20);
    INSERT INTO t1 VALUES (3, 30);
    SELECT id, val + 5 FROM t1 ORDER BY id;
}
expect {
    1|15
    2|25
    3|35
}

@requires strict "uses STRICT tables"
test op-literal-eq-multi-rows {
    -- Literal comparison with = across multiple rows.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 42);
    INSERT INTO t1 VALUES (3, 42);
    INSERT INTO t1 VALUES (4, 99);
    SELECT id FROM t1 WHERE val = 42 ORDER BY id;
}
expect {
    2
    3
}

@requires strict "uses STRICT tables"
test op-literal-lt-multi-rows {
    -- Literal comparison with < across multiple rows (no clobbering).
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 3);
    INSERT INTO t1 VALUES (2, 10);
    INSERT INTO t1 VALUES (3, 7);
    INSERT INTO t1 VALUES (4, 1);
    SELECT id, val FROM t1 WHERE val < 5 ORDER BY id;
}
expect {
    1|3
    4|1
}

@requires strict "uses STRICT tables"
test op-reversed-literal-plus-column {
    -- Reversed: literal + custom_type_column → operator fires with swapped args.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 20);
    INSERT INTO t1 VALUES (3, 30);
    SELECT id, 5 + val FROM t1 ORDER BY id;
}
expect {
    1|15
    2|25
    3|35
}


@requires strict "uses STRICT tables"
test op-derived-gt-literal {
    -- > derived from swap_args(<)
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, 3);
    SELECT id FROM t1 WHERE val > 9 ORDER BY id;
}
expect {
    1
    3
}

@requires strict "uses STRICT tables"
test op-derived-gte-literal {
    -- >= derived from NOT(<)
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, 3);
    SELECT id FROM t1 WHERE val >= 9 ORDER BY id;
}
expect {
    1
    2
    3
}

@requires strict "uses STRICT tables"
test op-derived-lte-literal {
    -- <= derived from NOT(swap_args(<))
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, 3);
    SELECT id FROM t1 WHERE val <= 50 ORDER BY id;
}
expect {
    2
    3
    4
}

@requires strict "uses STRICT tables"
test op-derived-neq-literal {
    -- != derived from NOT(=)
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    SELECT id FROM t1 WHERE val != 9 ORDER BY id;
}
expect {
    1
    3
}

@requires strict "uses STRICT tables"
test op-derived-gt-between-columns {
    -- > between two custom type columns.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, a test_uint, b test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 20, 5);
    INSERT INTO t1 VALUES (2, 3, 10);
    INSERT INTO t1 VALUES (3, 7, 7);
    SELECT id FROM t1 WHERE a > b ORDER BY id;
}
expect {
    1
}


@requires strict "uses STRICT tables"
test op-numeric-add-literal-multi-row {
    -- numeric(10,2) + integer literal across multiple rows.
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    INSERT INTO t1 VALUES (2, 100);
    INSERT INTO t1 VALUES (3, 7);
    SELECT id, val + 5 FROM t1 ORDER BY id;
}
expect {
    1|47.00
    2|105.00
    3|12.00
}

@requires strict "uses STRICT tables"
test op-numeric-sub-literal-multi-row {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    INSERT INTO t1 VALUES (2, 100);
    INSERT INTO t1 VALUES (3, 7);
    SELECT id, val - 2 FROM t1 ORDER BY id;
}
expect {
    1|40.00
    2|98.00
    3|5.00
}

@requires strict "uses STRICT tables"
test op-numeric-mul-literal-multi-row {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 3);
    INSERT INTO t1 VALUES (3, -5);
    SELECT id, val * 3 FROM t1 ORDER BY id;
}
expect {
    1|30.0000
    2|9.0000
    3|-15.0000
}

@requires strict "uses STRICT tables"
test op-numeric-div-literal-multi-row {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 30);
    SELECT id, val / 10 FROM t1 ORDER BY id;
}
expect {
    1|10
    2|3
}

@requires strict "uses STRICT tables"
test op-numeric-lt-literal-multi-row {
    -- numeric < literal across 4 rows (tests no register clobbering).
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, -5);
    SELECT id, val FROM t1 WHERE val < 50 ORDER BY id;
}
expect {
    2|9.00
    4|-5.00
}

@requires strict "uses STRICT tables"
test op-numeric-eq-literal-multi-row {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    INSERT INTO t1 VALUES (2, 99);
    INSERT INTO t1 VALUES (3, 42);
    SELECT id FROM t1 WHERE val = 42 ORDER BY id;
}
expect {
    1
    3
}

@requires strict "uses STRICT tables"
test op-numeric-gt-literal-multi-row {
    -- > (derived) with numeric across 4 rows.
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, -5);
    SELECT id, val FROM t1 WHERE val > 9 ORDER BY id;
}
expect {
    1|100.00
    3|50.00
}

@requires strict "uses STRICT tables"
test op-numeric-gte-literal-multi-row {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, -5);
    SELECT id, val FROM t1 WHERE val >= 9 ORDER BY id;
}
expect {
    1|100.00
    2|9.00
    3|50.00
}

@requires strict "uses STRICT tables"
test op-numeric-lte-literal-multi-row {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, -5);
    SELECT id, val FROM t1 WHERE val <= 50 ORDER BY id;
}
expect {
    2|9.00
    3|50.00
    4|-5.00
}

@requires strict "uses STRICT tables"
test op-numeric-neq-literal-multi-row {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    SELECT id, val FROM t1 WHERE val != 9 ORDER BY id;
}
expect {
    1|100.00
    3|50.00
}

@requires strict "uses STRICT tables"
test op-numeric-between-literal-multi-row {
    -- BETWEEN rewrites to >= AND <=, both derived operators.
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, -5);
    SELECT id, val FROM t1 WHERE val BETWEEN 9 AND 50 ORDER BY id;
}
expect {
    2|9.00
    3|50.00
}

@requires strict "uses STRICT tables"
test op-numeric-add-both-columns {
    -- Both columns are numeric → operator fires, no encoding needed.
    CREATE TABLE t1(id INTEGER PRIMARY KEY, a numeric(10,2), b numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 10, 5);
    INSERT INTO t1 VALUES (2, 100, 200);
    SELECT id, a + b FROM t1 ORDER BY id;
}
expect {
    1|15.00
    2|300.00
}

@requires strict "uses STRICT tables"
test op-numeric-lt-both-columns {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, a numeric(10,2), b numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 10, 20);
    INSERT INTO t1 VALUES (2, 30, 5);
    INSERT INTO t1 VALUES (3, 7, 7);
    SELECT id FROM t1 WHERE a < b ORDER BY id;
}
expect {
    1
}


@requires strict "uses STRICT tables"
test op-different-types-no-override {
    -- Different custom types: standard operator, not overridden.
    CREATE TYPE type_a(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add;
    CREATE TYPE type_b(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, a type_a, b type_b) STRICT;
    INSERT INTO t1 VALUES (1, 10, 5);
    -- Standard + on integers: 10 + 5 = 15 (but decoded first)
    SELECT a + b FROM t1;
}
expect {
    15
}


@requires strict "uses STRICT tables"
test op-standard-plus-custom-no-override {
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, int_col INTEGER, custom_col test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 10, 5);
    -- int_col is standard INTEGER, custom_col is test_uint → standard +.
    SELECT int_col + custom_col FROM t1;
}
expect {
    15
}


@requires strict "uses STRICT tables"
test op-order-by-custom-lt {
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 3);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, 10);
    SELECT id, val FROM t1 ORDER BY val;
}
expect {
    2|3
    4|10
    3|50
    1|100
}

@requires strict "uses STRICT tables"
test op-order-by-custom-lt-desc {
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 3);
    INSERT INTO t1 VALUES (3, 50);
    SELECT id, val FROM t1 ORDER BY val DESC;
}
expect {
    1|100
    3|50
    2|3
}


@requires strict "uses STRICT tables"
test op-null-literal-no-override {
    -- NULL literal: operator should not fire (NULL has no type).
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    SELECT val + NULL FROM t1;
}
expect {

}

@requires strict "uses STRICT tables"
test op-null-column-value {
    -- Column value is NULL: operator should handle gracefully.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, NULL);
    INSERT INTO t1 VALUES (2, 42);
    SELECT id, val + 5 FROM t1 ORDER BY id;
}
expect {
    1|
    2|47
}


@requires strict "uses STRICT tables"
test op-nested-expression {
    -- (a + b) + c: inner fires (both custom type columns), outer may or may not.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, a test_uint, b test_uint, c test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 10, 20, 30);
    -- test_uint_add returns an integer, so (a + b) is not a custom type column.
    -- The inner (a + b) fires the operator. The outer falls back to standard +.
    SELECT (a + b) + c FROM t1;
}
expect {
    60
}


@requires strict "uses STRICT tables"
test op-backward-compat-old-syntax {
    -- Old syntax: OPERATOR 'op' (type) -> func_name
    CREATE TYPE test_uint_old(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' (test_uint_old) -> test_uint_add
        OPERATOR '<' (test_uint_old) -> test_uint_lt
        OPERATOR '=' (test_uint_old) -> test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint_old) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 20);
    SELECT val + 5 FROM t1 ORDER BY id;
}
expect {
    15
    25
}


@requires strict "uses STRICT tables"
test op-value-integer-with-integer-literal {
    -- value type is "integer", integer literal → compatible → operator fires.
    CREATE TYPE my_int(value integer) BASE integer
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val my_int) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 20);
    SELECT id FROM t1 WHERE val = 10;
}
expect {
    1
}

@requires strict "uses STRICT tables"
test op-value-integer-with-text-literal-fallback {
    -- value type is "integer", text literal → NOT compatible → standard operator.
    CREATE TYPE my_int(value integer) BASE integer
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val my_int) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    -- Standard = compares integer 10 with text '10' → SQLite rules apply.
    SELECT id FROM t1 WHERE val = '10';
}
expect {
    1
}


@requires strict "uses STRICT tables"
test op-many-rows-lt {
    -- 8 rows to stress-test register handling across iterations.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 1);
    INSERT INTO t1 VALUES (2, 2);
    INSERT INTO t1 VALUES (3, 3);
    INSERT INTO t1 VALUES (4, 4);
    INSERT INTO t1 VALUES (5, 5);
    INSERT INTO t1 VALUES (6, 6);
    INSERT INTO t1 VALUES (7, 7);
    INSERT INTO t1 VALUES (8, 8);
    SELECT id FROM t1 WHERE val < 5 ORDER BY id;
}
expect {
    1
    2
    3
    4
}

@requires strict "uses STRICT tables"
test op-many-rows-add {
    -- 8 rows: addition across many iterations.
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 20);
    INSERT INTO t1 VALUES (3, 30);
    INSERT INTO t1 VALUES (4, 40);
    INSERT INTO t1 VALUES (5, 50);
    INSERT INTO t1 VALUES (6, 60);
    INSERT INTO t1 VALUES (7, 70);
    INSERT INTO t1 VALUES (8, 80);
    SELECT id, val + 100 FROM t1 ORDER BY id;
}
expect {
    1|110
    2|120
    3|130
    4|140
    5|150
    6|160
    7|170
    8|180
}

@requires strict "uses STRICT tables"
test op-many-rows-numeric-gt {
    -- 8 rows with numeric type: derived > across many iterations.
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 20);
    INSERT INTO t1 VALUES (3, 30);
    INSERT INTO t1 VALUES (4, 40);
    INSERT INTO t1 VALUES (5, 50);
    INSERT INTO t1 VALUES (6, 60);
    INSERT INTO t1 VALUES (7, 70);
    INSERT INTO t1 VALUES (8, 80);
    SELECT id FROM t1 WHERE val > 50 ORDER BY id;
}
expect {
    6
    7
    8
}


@requires strict "uses STRICT tables"
test op-where-and-order-by-combined {
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 3);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, 10);
    INSERT INTO t1 VALUES (5, 7);
    SELECT id, val FROM t1 WHERE val > 5 ORDER BY val;
}
expect {
    5|7
    4|10
    3|50
    1|100
}

@requires strict "uses STRICT tables"
test op-numeric-where-and-order-by {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 3);
    INSERT INTO t1 VALUES (3, 50);
    INSERT INTO t1 VALUES (4, 10);
    INSERT INTO t1 VALUES (5, 7);
    SELECT id, val FROM t1 WHERE val > 5 ORDER BY val;
}
expect {
    5|7.00
    4|10.00
    3|50.00
    1|100.00
}


@requires strict "uses STRICT tables"
test op-reversed-literal-lt {
    -- 5 < val → should use custom operator (literal on LHS).
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 3);
    INSERT INTO t1 VALUES (2, 10);
    INSERT INTO t1 VALUES (3, 5);
    INSERT INTO t1 VALUES (4, 100);
    SELECT id FROM t1 WHERE 5 < val ORDER BY id;
}
expect {
    2
    4
}

@requires strict "uses STRICT tables"
test op-reversed-literal-eq {
    -- 42 = val → should use custom operator (literal on LHS).
    CREATE TYPE test_uint(value any) BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' test_uint_add
        OPERATOR '<' test_uint_lt
        OPERATOR '=' test_uint_eq;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    INSERT INTO t1 VALUES (2, 99);
    INSERT INTO t1 VALUES (3, 42);
    SELECT id FROM t1 WHERE 42 = val ORDER BY id;
}
expect {
    1
    3
}
