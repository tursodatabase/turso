@database :memory:

@requires strict "uses STRICT tables"
test create-type-basic {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' (test_uint) -> test_uint_add
        OPERATOR '<' (test_uint) -> test_uint_lt
        OPERATOR '=' (test_uint) -> test_uint_eq;
    SELECT name FROM sqlite_turso_types WHERE name = 'test_uint';
}
expect {
    test_uint
}

@requires strict "uses STRICT tables"
test create-type-if-not-exists {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TYPE IF NOT EXISTS test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    SELECT count(*) FROM sqlite_turso_types WHERE name = 'test_uint';
}
expect {
    1
}

@requires strict "uses STRICT tables"
test drop-type-basic {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    DROP TYPE test_uint;
    SELECT count(*) FROM sqlite_turso_types WHERE name = 'test_uint';
}
expect {
    0
}

@requires strict "uses STRICT tables"
test drop-type-if-exists {
    DROP TYPE IF EXISTS nonexistent;
    SELECT 'ok';
}
expect {
    ok
}

@requires strict "uses STRICT tables"
test strict-table-with-custom-type {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    INSERT INTO t1 VALUES (2, 100);
    SELECT id, val FROM t1;
}
expect {
    1|42
    2|100
}

@requires strict "uses STRICT tables"
test encode-decode-round-trip {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(val test_reverse) STRICT;
    INSERT INTO t1 VALUES ('hello');
    INSERT INTO t1 VALUES ('world');
    SELECT val FROM t1;
}
expect {
    hello
    world
}

@requires strict "uses STRICT tables"
test uint-addition {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value) DECODE test_uint_decode(value)
        OPERATOR '+' (test_uint) -> test_uint_add;
    CREATE TABLE t1(val test_uint) STRICT;
    INSERT INTO t1 VALUES (20);
    INSERT INTO t1 VALUES (30);
    SELECT val + val FROM t1;
}
expect {
    40
    60
}

@requires strict "uses STRICT tables"
test uint-comparison-less-than {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value) DECODE test_uint_decode(value)
        OPERATOR '<' (test_uint) -> test_uint_lt;
    CREATE TABLE t1(val test_uint) STRICT;
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (10);
    INSERT INTO t1 VALUES (100);
    SELECT val FROM t1 WHERE val < 10;
}
expect {
    9
}

@requires strict "uses STRICT tables"
test uint-comparison-equals {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value) DECODE test_uint_decode(value)
        OPERATOR '=' (test_uint) -> test_uint_eq;
    CREATE TABLE t1(val test_uint) STRICT;
    INSERT INTO t1 VALUES (42);
    INSERT INTO t1 VALUES (99);
    SELECT val FROM t1 WHERE val = 42;
}
expect {
    42
}

@requires strict "uses STRICT tables"
test cast-to-custom-type {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    SELECT CAST('hello' AS test_reverse);
}
expect {
    olleh
}

@requires strict "uses STRICT tables"
test null-handling {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(val test_uint) STRICT;
    INSERT INTO t1 VALUES (NULL);
    SELECT COALESCE(val, 'IS_NULL') FROM t1;
}
expect {
    IS_NULL
}

@requires strict "uses STRICT tables"
test multiple-custom-types {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(a test_uint, b test_reverse) STRICT;
    INSERT INTO t1 VALUES (42, 'hello');
    SELECT a, b FROM t1;
}
expect {
    42|hello
}

@requires strict "uses STRICT tables"
test type-default-literal {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value) DEFAULT 0;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1(id) VALUES (1);
    INSERT INTO t1(id) VALUES (2);
    INSERT INTO t1 VALUES (3, 99);
    SELECT id, val FROM t1;
}
expect {
    1|0
    2|0
    3|99
}

@requires strict "uses STRICT tables"
test type-default-function {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value) DEFAULT test_reverse_encode('auto');
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_reverse) STRICT;
    INSERT INTO t1(id) VALUES (1);
    INSERT INTO t1 VALUES (2, 'hello');
    SELECT id, val FROM t1;
}
expect {
    1|otua
    2|hello
}

@requires strict "uses STRICT tables"
test type-default-column-override {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value) DEFAULT 0;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint DEFAULT 42) STRICT;
    INSERT INTO t1(id) VALUES (1);
    SELECT id, val FROM t1;
}
expect {
    1|42
}

@requires strict "uses STRICT tables"
test encode-expression-multiply {
    CREATE TYPE cents BASE integer ENCODE value * 100 DECODE value / 100;
    CREATE TABLE t1(price cents) STRICT;
    INSERT INTO t1 VALUES (42);
    INSERT INTO t1 VALUES (1);
    SELECT price FROM t1;
}
expect {
    42
    1
}

@requires strict "uses STRICT tables"
test encode-expression-identity {
    CREATE TYPE passthrough BASE text ENCODE value DECODE value;
    CREATE TABLE t1(val passthrough) STRICT;
    INSERT INTO t1 VALUES ('hello');
    SELECT val FROM t1;
}
expect {
    hello
}

@requires strict "uses STRICT tables"
test encode-error-propagation {
    CREATE TYPE jsontype BASE text ENCODE json(value) DECODE value;
    CREATE TABLE t1(val jsontype) STRICT;
    INSERT INTO t1 VALUES ('not valid json');
}
expect error {
    malformed JSON
}

@requires strict "uses STRICT tables"
test decode-error-propagation {
    CREATE TYPE jsontype BASE text ENCODE value DECODE json(value);
    CREATE TABLE t1(val jsontype) STRICT;
    INSERT INTO t1 VALUES ('not valid json');
    SELECT val FROM t1;
}
expect error {
    malformed JSON
}

@requires strict "uses STRICT tables"
test pragma-list-types-builtins {
    PRAGMA list_types;
}
expect {
    INTEGER|||||
    REAL|||||
    TEXT|||||
    BLOB|||||
    ANY|||||
    bigint|integer||||
    boolean|integer|boolean_to_int (value)|int_to_boolean (value)||
    bytea|blob||||
    date|text|date (value)|value||
    inet|text|validate_ipaddr (value)|value||
    json|text|json (value)|value||
    jsonb|blob|jsonb (value)|json (value)||
    numeric(precision, scale)|blob|numeric_encode (value, precision, scale)|numeric_decode (value)||+(numeric) -> numeric_add, -(numeric) -> numeric_sub, *(numeric) -> numeric_mul, /(numeric) -> numeric_div, <(numeric) -> numeric_lt, =(numeric) -> numeric_eq
    smallint|integer|CASE WHEN value BETWEEN - 32768 AND 32767 THEN value ELSE RAISE (ABORT, 'integer out of range for smallint') END|value||
    time|text|time (value)|value||
    timestamp|text|datetime (value)|value||
    uuid|blob|uuid_blob (value)|uuid_str (value)|uuid4_str ()|
    varchar(maxlen)|text|CASE WHEN length (value) <= maxlen THEN value ELSE RAISE (ABORT, 'value too long for varchar') END|value||
}

@requires strict "uses STRICT tables"
test pragma-list-types-with-custom {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' (test_uint) -> test_uint_add
        DEFAULT 0;
    PRAGMA list_types;
}
expect {
    INTEGER|||||
    REAL|||||
    TEXT|||||
    BLOB|||||
    ANY|||||
    bigint|integer||||
    boolean|integer|boolean_to_int (value)|int_to_boolean (value)||
    bytea|blob||||
    date|text|date (value)|value||
    inet|text|validate_ipaddr (value)|value||
    json|text|json (value)|value||
    jsonb|blob|jsonb (value)|json (value)||
    numeric(precision, scale)|blob|numeric_encode (value, precision, scale)|numeric_decode (value)||+(numeric) -> numeric_add, -(numeric) -> numeric_sub, *(numeric) -> numeric_mul, /(numeric) -> numeric_div, <(numeric) -> numeric_lt, =(numeric) -> numeric_eq
    smallint|integer|CASE WHEN value BETWEEN - 32768 AND 32767 THEN value ELSE RAISE (ABORT, 'integer out of range for smallint') END|value||
    test_uint|text|test_uint_encode (value)|test_uint_decode (value)|0|+(test_uint) -> test_uint_add
    time|text|time (value)|value||
    timestamp|text|datetime (value)|value||
    uuid|blob|uuid_blob (value)|uuid_str (value)|uuid4_str ()|
    varchar(maxlen)|text|CASE WHEN length (value) <= maxlen THEN value ELSE RAISE (ABORT, 'value too long for varchar') END|value||
}

@requires strict "uses STRICT tables"
test encode-null-rejects-primary-key {
    CREATE TYPE my_uuid BASE text ENCODE uuid_blob(value) DECODE uuid_str(value);
    CREATE TABLE t1(id my_uuid PRIMARY KEY, name TEXT) STRICT;
    INSERT INTO t1 VALUES ('019509a2', 'bad');
}
expect error {
    NOT NULL constraint failed
}

@requires strict "uses STRICT tables"
test drop-type-in-use {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    DROP TYPE test_uint;
}
expect error {
}

@requires strict "uses STRICT tables"
test add-column-custom-type {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY) STRICT;
    ALTER TABLE t1 ADD COLUMN val test_uint;
    INSERT INTO t1 VALUES (1, 42);
    INSERT INTO t1 VALUES (2, 100);
    SELECT id, val FROM t1;
}
expect {
    1|42
    2|100
}

@requires strict "uses STRICT tables"
test custom-type-requires-strict {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint);
}
expect error {
}

@requires strict "uses STRICT tables"
test update-with-custom-type {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_reverse) STRICT;
    INSERT INTO t1 VALUES (1, 'hello');
    INSERT INTO t1 VALUES (2, 'world');
    UPDATE t1 SET val = 'updated' WHERE id = 1;
    SELECT id, val FROM t1 ORDER BY id;
}
expect {
    1|updated
    2|world
}

@requires strict "uses STRICT tables"
test update-uint-encode {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    UPDATE t1 SET val = 99 WHERE id = 1;
    SELECT id, val FROM t1;
}
expect {
    1|99
}

@requires strict "uses STRICT tables"
test update-custom-type-null {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    UPDATE t1 SET val = NULL WHERE id = 1;
    SELECT id, COALESCE(val, 'IS_NULL') FROM t1;
}
expect {
    1|IS_NULL
}

@requires strict "uses STRICT tables"
test replace-with-custom-type {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    REPLACE INTO t1 VALUES (1, 99);
    SELECT id, val FROM t1;
}
expect {
    1|99
}

@requires strict "uses STRICT tables"
test custom-type-not-null-constraint {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint NOT NULL) STRICT;
    INSERT INTO t1 VALUES (1, NULL);
}
expect error {
    NOT NULL constraint failed
}

@requires strict "uses STRICT tables"
test update-non-set-column-not-re-encoded {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, name TEXT, val test_reverse) STRICT;
    INSERT INTO t1 VALUES (1, 'hello', 'world');
    UPDATE t1 SET name = 'goodbye' WHERE id = 1;
    SELECT id, name, val FROM t1;
}
expect {
    1|goodbye|world
}

@requires strict "uses STRICT tables"
test upsert-do-update-encodes {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_reverse) STRICT;
    INSERT INTO t1 VALUES (1, 'hello');
    INSERT INTO t1 VALUES (1, 'ignored') ON CONFLICT(id) DO UPDATE SET val = 'updated';
    SELECT id, val FROM t1;
}
expect {
    1|updated
}

@requires strict "uses STRICT tables"
test upsert-non-set-column-not-re-encoded {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, name TEXT, val test_reverse) STRICT;
    INSERT INTO t1 VALUES (1, 'hello', 'world');
    INSERT INTO t1 VALUES (1, 'x', 'y') ON CONFLICT(id) DO UPDATE SET name = 'changed';
    SELECT id, name, val FROM t1;
}
expect {
    1|changed|world
}

@requires strict "uses STRICT tables"
test order-by-custom-type-without-lt {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(val test_reverse) STRICT;
    INSERT INTO t1 VALUES ('apple');
    INSERT INTO t1 VALUES ('banana');
    INSERT INTO t1 VALUES ('cherry');
    SELECT val FROM t1 ORDER BY val;
}
expect {
    banana
    apple
    cherry
}

@requires strict "uses STRICT tables"
test order-by-numeric-type-with-lt {
    CREATE TABLE t1(val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (20);
    INSERT INTO t1 VALUES (-5);
    SELECT val FROM t1 ORDER BY val;
}
expect {
    -5.00
    9.00
    20.00
    100.00
}

@requires strict "uses STRICT tables"
test order-by-numeric-desc {
    CREATE TABLE t1(val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (20);
    SELECT val FROM t1 ORDER BY val DESC;
}
expect {
    100.00
    20.00
    9.00
}

@requires strict "uses STRICT tables"
test order-by-custom-type-desc {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(val test_reverse) STRICT;
    INSERT INTO t1 VALUES ('apple');
    INSERT INTO t1 VALUES ('banana');
    INSERT INTO t1 VALUES ('cherry');
    SELECT val FROM t1 ORDER BY val DESC;
}
expect {
    cherry
    apple
    banana
}

@requires strict "uses STRICT tables"
test order-by-numeric-with-nulls {
    CREATE TABLE t1(val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (NULL);
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (NULL);
    INSERT INTO t1 VALUES (-5);
    SELECT COALESCE(CAST(val AS TEXT), 'NULL') FROM t1 ORDER BY val;
}
expect {
    NULL
    NULL
    -5.00
    9.00
    100.00
}

@requires strict "uses STRICT tables"
test order-by-numeric-nulls-desc {
    CREATE TABLE t1(val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (NULL);
    INSERT INTO t1 VALUES (9);
    SELECT COALESCE(CAST(val AS TEXT), 'NULL') FROM t1 ORDER BY val DESC;
}
expect {
    100.00
    9.00
    NULL
}

@requires strict "uses STRICT tables"
test order-by-custom-type-not-in-select {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_reverse) STRICT;
    INSERT INTO t1 VALUES (1, 'apple');
    INSERT INTO t1 VALUES (2, 'banana');
    INSERT INTO t1 VALUES (3, 'cherry');
    SELECT id FROM t1 ORDER BY val;
}
expect {
    2
    1
    3
}

@requires strict "uses STRICT tables"
test order-by-numeric-not-in-select {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, -5);
    SELECT id FROM t1 ORDER BY val;
}
expect {
    3
    2
    1
}

@requires strict "uses STRICT tables"
test order-by-mixed-columns {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, name TEXT, val test_reverse) STRICT;
    INSERT INTO t1 VALUES (1, 'b', 'apple');
    INSERT INTO t1 VALUES (2, 'a', 'banana');
    INSERT INTO t1 VALUES (3, 'a', 'cherry');
    SELECT id, name, val FROM t1 ORDER BY name, val;
}
expect {
    2|a|banana
    3|a|cherry
    1|b|apple
}

@requires strict "uses STRICT tables"
test order-by-numeric-with-limit {
    CREATE TABLE t1(val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (20);
    INSERT INTO t1 VALUES (-5);
    INSERT INTO t1 VALUES (50);
    SELECT val FROM t1 ORDER BY val LIMIT 3;
}
expect {
    -5.00
    9.00
    20.00
}

@requires strict "uses STRICT tables"
test order-by-numeric-with-limit-offset {
    CREATE TABLE t1(val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (20);
    INSERT INTO t1 VALUES (-5);
    INSERT INTO t1 VALUES (50);
    SELECT val FROM t1 ORDER BY val LIMIT 2 OFFSET 1;
}
expect {
    9.00
    20.00
}

@requires strict "uses STRICT tables"
test order-by-custom-type-with-nulls {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(val test_reverse) STRICT;
    INSERT INTO t1 VALUES ('apple');
    INSERT INTO t1 VALUES (NULL);
    INSERT INTO t1 VALUES ('cherry');
    SELECT COALESCE(val, 'NULL') FROM t1 ORDER BY val;
}
expect {
    NULL
    apple
    cherry
}

@requires strict "uses STRICT tables"
test order-by-numeric-multiple-columns {
    CREATE TABLE t1(a numeric(10,2), b numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 30);
    INSERT INTO t1 VALUES (1, 10);
    INSERT INTO t1 VALUES (2, 20);
    INSERT INTO t1 VALUES (1, 20);
    SELECT a, b FROM t1 ORDER BY a, b;
}
expect {
    1.00|10.00
    1.00|20.00
    1.00|30.00
    2.00|20.00
}

@requires strict "uses STRICT tables"
test order-by-group-by-numeric {
    CREATE TABLE t1(category TEXT, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES ('a', 100);
    INSERT INTO t1 VALUES ('a', 9);
    INSERT INTO t1 VALUES ('b', 20);
    INSERT INTO t1 VALUES ('b', 50);
    INSERT INTO t1 VALUES ('c', -5);
    SELECT category, SUM(val) as total FROM t1 GROUP BY category ORDER BY total;
}
expect {
    c|-5.0
    b|70.0
    a|109.0
}

@requires strict "uses STRICT tables"
test order-by-group-by-custom-type {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(val test_reverse, n INTEGER) STRICT;
    INSERT INTO t1 VALUES ('apple', 1);
    INSERT INTO t1 VALUES ('apple', 2);
    INSERT INTO t1 VALUES ('banana', 3);
    INSERT INTO t1 VALUES ('cherry', 4);
    SELECT val, SUM(n) FROM t1 GROUP BY val ORDER BY val;
}
expect {
    apple|3
    banana|3
    cherry|4
}

@requires strict "uses STRICT tables"
test order-by-numeric-expression {
    CREATE TABLE t1(val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (20);
    SELECT val + val as doubled FROM t1 ORDER BY val;
}
expect {
    18.00
    40.00
    200.00
}

@requires strict "uses STRICT tables"
test order-by-custom-type-where-clause {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_reverse) STRICT;
    INSERT INTO t1 VALUES (1, 'apple');
    INSERT INTO t1 VALUES (2, 'banana');
    INSERT INTO t1 VALUES (3, 'cherry');
    INSERT INTO t1 VALUES (4, 'date');
    SELECT val FROM t1 WHERE id > 1 ORDER BY val;
}
expect {
    banana
    date
    cherry
}

@requires strict "uses STRICT tables"
test order-by-numeric-where-clause {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, -5);
    INSERT INTO t1 VALUES (4, 50);
    SELECT val FROM t1 WHERE val > 0 ORDER BY val;
}
expect {
    9.00
    50.00
    100.00
}

@requires strict "uses STRICT tables"
test order-by-numeric-distinct {
    CREATE TABLE t1(val numeric(10,2)) STRICT;
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (100);
    INSERT INTO t1 VALUES (20);
    INSERT INTO t1 VALUES (9);
    SELECT DISTINCT val FROM t1 ORDER BY val;
}
expect {
    9.00
    20.00
    100.00
}

@requires strict "uses STRICT tables"
test order-by-custom-type-join {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_reverse) STRICT;
    CREATE TABLE t2(id INTEGER PRIMARY KEY, t1_id INTEGER, label TEXT) STRICT;
    INSERT INTO t1 VALUES (1, 'apple');
    INSERT INTO t1 VALUES (2, 'banana');
    INSERT INTO t1 VALUES (3, 'cherry');
    INSERT INTO t2 VALUES (1, 1, 'x');
    INSERT INTO t2 VALUES (2, 2, 'y');
    INSERT INTO t2 VALUES (3, 3, 'z');
    SELECT t2.label, t1.val FROM t1 JOIN t2 ON t1.id = t2.t1_id ORDER BY t1.val;
}
expect {
    y|banana
    x|apple
    z|cherry
}

@requires strict "uses STRICT tables"
test order-by-numeric-join {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val numeric(10,2)) STRICT;
    CREATE TABLE t2(id INTEGER PRIMARY KEY, t1_id INTEGER, label TEXT) STRICT;
    INSERT INTO t1 VALUES (1, 100);
    INSERT INTO t1 VALUES (2, 9);
    INSERT INTO t1 VALUES (3, -5);
    INSERT INTO t2 VALUES (1, 1, 'x');
    INSERT INTO t2 VALUES (2, 2, 'y');
    INSERT INTO t2 VALUES (3, 3, 'z');
    SELECT t2.label, t1.val FROM t1 JOIN t2 ON t1.id = t2.t1_id ORDER BY t1.val;
}
expect {
    z|-5.00
    y|9.00
    x|100.00
}
