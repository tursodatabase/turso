@database :memory:

@requires strict "uses STRICT tables"
test create-type-basic {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' (test_uint) -> test_uint_add
        OPERATOR '<' (test_uint) -> test_uint_lt
        OPERATOR '=' (test_uint) -> test_uint_eq;
    SELECT type, name FROM sqlite_schema WHERE type = 'type';
}
expect {
    type|test_uint
}

@requires strict "uses STRICT tables"
test create-type-if-not-exists {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TYPE IF NOT EXISTS test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    SELECT count(*) FROM sqlite_schema WHERE type = 'type' AND name = 'test_uint';
}
expect {
    1
}

@requires strict "uses STRICT tables"
test drop-type-basic {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    DROP TYPE test_uint;
    SELECT count(*) FROM sqlite_schema WHERE type = 'type';
}
expect {
    0
}

@requires strict "uses STRICT tables"
test drop-type-if-exists {
    DROP TYPE IF EXISTS nonexistent;
    SELECT 'ok';
}
expect {
    ok
}

@requires strict "uses STRICT tables"
test strict-table-with-custom-type {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1 VALUES (1, 42);
    INSERT INTO t1 VALUES (2, 100);
    SELECT id, val FROM t1;
}
expect {
    1|42
    2|100
}

@requires strict "uses STRICT tables"
test encode-decode-round-trip {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(val test_reverse) STRICT;
    INSERT INTO t1 VALUES ('hello');
    INSERT INTO t1 VALUES ('world');
    SELECT val FROM t1;
}
expect {
    hello
    world
}

@requires strict "uses STRICT tables"
test uint-addition {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value) DECODE test_uint_decode(value)
        OPERATOR '+' (test_uint) -> test_uint_add;
    CREATE TABLE t1(val test_uint) STRICT;
    INSERT INTO t1 VALUES (20);
    INSERT INTO t1 VALUES (30);
    SELECT val + val FROM t1;
}
expect {
    40
    60
}

@requires strict "uses STRICT tables"
test uint-comparison-less-than {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value) DECODE test_uint_decode(value)
        OPERATOR '<' (test_uint) -> test_uint_lt;
    CREATE TABLE t1(val test_uint) STRICT;
    INSERT INTO t1 VALUES (9);
    INSERT INTO t1 VALUES (10);
    INSERT INTO t1 VALUES (100);
    SELECT val FROM t1 WHERE val < 10;
}
expect {
    9
}

@requires strict "uses STRICT tables"
test uint-comparison-equals {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value) DECODE test_uint_decode(value)
        OPERATOR '=' (test_uint) -> test_uint_eq;
    CREATE TABLE t1(val test_uint) STRICT;
    INSERT INTO t1 VALUES (42);
    INSERT INTO t1 VALUES (99);
    SELECT val FROM t1 WHERE val = 42;
}
expect {
    42
}

@requires strict "uses STRICT tables"
test cast-to-custom-type {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    SELECT CAST('hello' AS test_reverse);
}
expect {
    olleh
}

@requires strict "uses STRICT tables"
test null-handling {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(val test_uint) STRICT;
    INSERT INTO t1 VALUES (NULL);
    SELECT COALESCE(val, 'IS_NULL') FROM t1;
}
expect {
    IS_NULL
}

@requires strict "uses STRICT tables"
test multiple-custom-types {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value);
    CREATE TABLE t1(a test_uint, b test_reverse) STRICT;
    INSERT INTO t1 VALUES (42, 'hello');
    SELECT a, b FROM t1;
}
expect {
    42|hello
}

@requires strict "uses STRICT tables"
test type-default-literal {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value) DEFAULT 0;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    INSERT INTO t1(id) VALUES (1);
    INSERT INTO t1(id) VALUES (2);
    INSERT INTO t1 VALUES (3, 99);
    SELECT id, val FROM t1;
}
expect {
    1|0
    2|0
    3|99
}

@requires strict "uses STRICT tables"
test type-default-function {
    CREATE TYPE test_reverse BASE text ENCODE test_reverse_encode(value) DECODE test_reverse_decode(value) DEFAULT test_reverse_encode('auto');
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_reverse) STRICT;
    INSERT INTO t1(id) VALUES (1);
    INSERT INTO t1 VALUES (2, 'hello');
    SELECT id, val FROM t1;
}
expect {
    1|otua
    2|hello
}

@requires strict "uses STRICT tables"
test type-default-column-override {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value) DEFAULT 0;
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint DEFAULT 42) STRICT;
    INSERT INTO t1(id) VALUES (1);
    SELECT id, val FROM t1;
}
expect {
    1|42
}

@requires strict "uses STRICT tables"
test encode-expression-multiply {
    CREATE TYPE cents BASE integer ENCODE value * 100 DECODE value / 100;
    CREATE TABLE t1(price cents) STRICT;
    INSERT INTO t1 VALUES (42);
    INSERT INTO t1 VALUES (1);
    SELECT price FROM t1;
}
expect {
    42
    1
}

@requires strict "uses STRICT tables"
test encode-expression-identity {
    CREATE TYPE passthrough BASE text ENCODE value DECODE value;
    CREATE TABLE t1(val passthrough) STRICT;
    INSERT INTO t1 VALUES ('hello');
    SELECT val FROM t1;
}
expect {
    hello
}

@requires strict "uses STRICT tables"
test encode-error-propagation {
    CREATE TYPE jsontype BASE text ENCODE json(value) DECODE value;
    CREATE TABLE t1(val jsontype) STRICT;
    INSERT INTO t1 VALUES ('not valid json');
}
expect error {
    malformed JSON
}

@requires strict "uses STRICT tables"
test decode-error-propagation {
    CREATE TYPE jsontype BASE text ENCODE value DECODE json(value);
    CREATE TABLE t1(val jsontype) STRICT;
    INSERT INTO t1 VALUES ('not valid json');
    SELECT val FROM t1;
}
expect error {
    malformed JSON
}

@requires strict "uses STRICT tables"
test pragma-list-types-builtins {
    PRAGMA list_types;
}
expect {
    INTEGER|||||
    REAL|||||
    TEXT|||||
    BLOB|||||
    ANY|||||
    bigint|integer||||
    boolean|integer|boolean_to_int (value)|int_to_boolean (value)||
    bytea|blob||||
    date|text|date (value)|value||
    inet|text|validate_ipaddr (value)|value||
    json|text|json (value)|value||
    jsonb|blob|jsonb (value)|json (value)||
    smallint|integer|check_int_range (value, - 32768, 32767)|value||
    time|text|time (value)|value||
    timestamp|text|datetime (value)|value||
    uuid|blob|uuid_blob (value)|uuid_str (value)|uuid4_str ()|
    varchar|text|check_text_maxlen (value, maxlen)|value||
}

@requires strict "uses STRICT tables"
test pragma-list-types-with-custom {
    CREATE TYPE test_uint BASE text
        ENCODE test_uint_encode(value)
        DECODE test_uint_decode(value)
        OPERATOR '+' (test_uint) -> test_uint_add
        DEFAULT 0;
    PRAGMA list_types;
}
expect {
    INTEGER|||||
    REAL|||||
    TEXT|||||
    BLOB|||||
    ANY|||||
    bigint|integer||||
    boolean|integer|boolean_to_int (value)|int_to_boolean (value)||
    bytea|blob||||
    date|text|date (value)|value||
    inet|text|validate_ipaddr (value)|value||
    json|text|json (value)|value||
    jsonb|blob|jsonb (value)|json (value)||
    smallint|integer|check_int_range (value, - 32768, 32767)|value||
    test_uint|text|test_uint_encode (value)|test_uint_decode (value)|0|+(test_uint) -> test_uint_add
    time|text|time (value)|value||
    timestamp|text|datetime (value)|value||
    uuid|blob|uuid_blob (value)|uuid_str (value)|uuid4_str ()|
    varchar|text|check_text_maxlen (value, maxlen)|value||
}

@requires strict "uses STRICT tables"
test encode-null-rejects-primary-key {
    CREATE TYPE my_uuid BASE text ENCODE uuid_blob(value) DECODE uuid_str(value);
    CREATE TABLE t1(id my_uuid PRIMARY KEY, name TEXT) STRICT;
    INSERT INTO t1 VALUES ('019509a2', 'bad');
}
expect error {
    NOT NULL constraint failed
}

@requires strict "uses STRICT tables"
test drop-type-in-use {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint) STRICT;
    DROP TYPE test_uint;
}
expect error {
}

@requires strict "uses STRICT tables"
test add-column-custom-type {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY) STRICT;
    ALTER TABLE t1 ADD COLUMN val test_uint;
    INSERT INTO t1 VALUES (1, 42);
    INSERT INTO t1 VALUES (2, 100);
    SELECT id, val FROM t1;
}
expect {
    1|42
    2|100
}

@requires strict "uses STRICT tables"
test custom-type-requires-strict {
    CREATE TYPE test_uint BASE text ENCODE test_uint_encode(value) DECODE test_uint_decode(value);
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val test_uint);
}
expect error {
}
