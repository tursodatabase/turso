@database :memory:

@cross-check-integrity
test distinct_orderby_regression {
    CREATE TABLE t (a,b,c,d);
    INSERT INTO t VALUES (1,2,3,4),(2,3,4,5);
    SELECT DISTINCT c,b FROM t ORDER BY d,b;
}
expect {
    3|2
    4|3
}

# In ORDER BY clauses, column aliases take precedence when resolving identifiers to columns.
@cross-check-integrity
test orderby_alias_precedence {
    CREATE TABLE t(x,y);
    INSERT INTO t VALUES (1,200),(2,100);
    SELECT x AS y, y AS x FROM t ORDER BY x;
}
expect {
    2|100
    1|200
}

# Check that ORDER BY with heap-sort properly handle multiple rows with same order key + result values
@cross-check-integrity
test orderby_same_rows {
    CREATE TABLE t(x,y,z);
    INSERT INTO t VALUES (1,2,3),(1,2,6),(1,2,9),(1,2,10),(1,3,-1),(1,3,-2);
    SELECT x, y FROM t ORDER BY x, y LIMIT 10;
}
expect {
    1|2
    1|2
    1|2
    1|2
    1|3
    1|3
}

# https://github.com/tursodatabase/turso/issues/3684
@cross-check-integrity
test orderby_alias_shadows_column {
    CREATE TABLE t(a, b);
    INSERT INTO t VALUES (1, 1), (2, 2), (3, 3);
    SELECT a, -b AS a FROM t ORDER BY a;
}
expect {
    3|-3
    2|-2
    1|-1
}

@cross-check-integrity
test order_by_ambiguous_column {
    CREATE TABLE a(id INT, value INT);
    INSERT INTO a VALUES (1, 10), (2, 20);
    CREATE TABLE b(id INT, value INT);
    INSERT INTO b VALUES (1, 100), (2, 200);
    SELECT
    a.id,
    b.value
    FROM
    a JOIN b ON a.id = b.id
    ORDER BY
    value;
}
expect error {
}

# https://github.com/tursodatabase/turso/issues/4608
# Float literals in ORDER BY should be treated as constant expressions, not column references.
# They should not cause parse errors.
test orderby_float_literal {
    SELECT 1 ORDER BY 0.5;
}
expect {
    1
}

@cross-check-integrity
test orderby_float_literal_with_table {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (3), (1), (2);
    SELECT x FROM t ORDER BY 0.5;
}
expect {
    3
    1
    2
}

# Single-row aggregate queries (aggregates without GROUP BY) produce exactly one row,
# so sqlite removes ORDER BY entirely because it's meaningless - this also means validation
# of the ORDER BY is skipped. In these examples, the ORDER BY contains an invalid subquery
# where the column counts don't match: a IN (SELECT a, b, c FROM t). This would normally fail
# validation but doesn't since the ORDER BY is removed.
@cross-check-integrity
test orderby_single_row_aggregate_optimization {
    CREATE TABLE t(a, b, c);
    SELECT COUNT(a) FROM t ORDER BY COALESCE(a IN (SELECT a, b, c FROM t), b);
}
expect {
    0
}

@cross-check-integrity
test orderby_single_row_aggregate_with_data {
    CREATE TABLE t(a, b, c);
    INSERT INTO t VALUES (1, 2, 3), (4, 5, 6);
    SELECT COUNT(a) FROM t ORDER BY COALESCE(a IN (SELECT a, b, c FROM t), b);
}
expect {
    2
}

# SQLite truncates ORDER BY after a rowid/INTEGER PRIMARY KEY column since the table is
# stored in rowid order and a unique column means no ties. This skips validation of
# subsequent clauses, so even invalid constructs like multi-column IN subqueries pass.
@cross-check-integrity
test orderby_rowid_truncation {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t VALUES (1, 'x'), (2, 'y');
    SELECT a FROM t ORDER BY a DESC, b NOT IN (SELECT a, b FROM t);
}
expect {
    2
    1
}

@cross-check-integrity
test orderby_rowid_truncation_explicit_rowid {
    CREATE TABLE t(a INTEGER, b TEXT);
    INSERT INTO t VALUES (1, 'x'), (2, 'y');
    SELECT a FROM t ORDER BY rowid DESC, b NOT IN (SELECT a, b FROM t);
}
expect {
    2
    1
}

