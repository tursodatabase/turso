@database :memory:

test fk-basic-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t (id INTEGER PRIMARY KEY, a TEXT);
    CREATE TABLE t2 (id INTEGER PRIMARY KEY, tid REFERENCES t(id));
    INSERT INTO t VALUES (1,'x'),(2,'y');
    INSERT INTO t2 VALUES (10,1),(11,NULL);    -- NULL child ok
    SELECT id,tid FROM t2 ORDER BY id;
}
expect {
    10|1
    11|
}

test fk-column-constraint-multi-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(a, c);
    CREATE TABLE s(a REFERENCES t(a, c));
}
expect error {
}

test fk-insert-child-missing-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t (id INTEGER PRIMARY KEY, a TEXT);
    CREATE TABLE t2 (id INTEGER PRIMARY KEY, tid REFERENCES t(id));
    INSERT INTO t2 VALUES (20,99);
}
expect error {
}

test fk-update-child-to-missing-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t (id INTEGER PRIMARY KEY, a TEXT);
    CREATE TABLE t2 (id INTEGER PRIMARY KEY, tid REFERENCES t(id));
    INSERT INTO t VALUES (1,'x');
    INSERT INTO t2 VALUES (10,1);
    UPDATE t2 SET tid = 42 WHERE id = 10;      -- now missing
}
expect error {
}

test fk-update-child-to-null-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t (id INTEGER PRIMARY KEY);
    CREATE TABLE t2 (id INTEGER PRIMARY KEY, tid REFERENCES t(id));
    INSERT INTO t VALUES (1);
    INSERT INTO t2 VALUES (7,1);
    UPDATE t2 SET tid = NULL WHERE id = 7;
    SELECT id, tid FROM t2;
}
expect {
    7|
}

test fk-delete-parent-blocked {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t (id INTEGER PRIMARY KEY, a TEXT);
    CREATE TABLE t2 (id INTEGER PRIMARY KEY, tid REFERENCES t(id));
    INSERT INTO t VALUES (1,'x'),(2,'y');
    INSERT INTO t2 VALUES (10,2);
    DELETE FROM t WHERE id=2;
}
expect error {
}

test fk-delete-parent-ok-when-no-child {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t (id INTEGER PRIMARY KEY, a TEXT);
    CREATE TABLE t2 (id INTEGER PRIMARY KEY, tid REFERENCES t(id));
    INSERT INTO t VALUES (1,'x'),(2,'y');
    INSERT INTO t2 VALUES (10,1);
    DELETE FROM t WHERE id=2;
    SELECT id FROM t ORDER BY id;
}
expect {
    1
}

test fk-composite-pk-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(
        a INT NOT NULL,
        b INT NOT NULL,
        PRIMARY KEY(a,b)
    );
    CREATE TABLE c(
        id INT PRIMARY KEY,
        x INT, y INT,
        FOREIGN KEY(x,y) REFERENCES p(a,b)
    );
    INSERT INTO p VALUES (1,1),(1,2);
    INSERT INTO c VALUES (10,1,1),(11,1,2),(12,NULL,2);  -- NULL in child allowed
    SELECT id,x,y FROM c ORDER BY id;
}
expect {
    10|1|1
    11|1|2
    12||2
}

test fk-composite-pk-missing {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(
        a INT NOT NULL,
        b INT NOT NULL,
        PRIMARY KEY(a,b)
    );
    CREATE TABLE c(
        id INT PRIMARY KEY,
        x INT, y INT,
        FOREIGN KEY(x,y) REFERENCES p(a,b)
    );
    INSERT INTO p VALUES (1,1);
    INSERT INTO c VALUES (20,1,2);             -- (1,2) missing
}
expect error {
}

test fk-composite-update-child-missing {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT NOT NULL, b INT NOT NULL, PRIMARY KEY(a,b));
    CREATE TABLE c(id INT PRIMARY KEY, x INT, y INT,
    FOREIGN KEY(x,y) REFERENCES p(a,b));
    INSERT INTO p VALUES (1,1),(2,2);
    INSERT INTO c VALUES (5,1,1);
    UPDATE c SET x=2,y=3 WHERE id=5;
}
expect error {
}

test fk-composite-unique-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(u TEXT, v TEXT, pad INT, UNIQUE(u,v));
    CREATE TABLE child(id INT PRIMARY KEY, cu TEXT, cv TEXT,
    FOREIGN KEY(cu,cv) REFERENCES parent(u,v));
    INSERT INTO parent VALUES ('A','B',0),('A','C',0);
    INSERT INTO child  VALUES (1,'A','B');
    SELECT id, cu, cv FROM child ORDER BY id;
}
expect {
    1|A|B
}

test fk-composite-unique-missing {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(u TEXT, v TEXT, pad INT, UNIQUE(u,v));
    CREATE TABLE child(id INT PRIMARY KEY, cu TEXT, cv TEXT,
    FOREIGN KEY(cu,cv) REFERENCES parent(u,v));
    INSERT INTO parent VALUES ('A','B',0);
    INSERT INTO child  VALUES (2,'A','X');     -- no ('A','X') in parent
}
expect error {
}

test fk-rowid-alias-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(id INTEGER PRIMARY KEY, a TEXT);
    CREATE TABLE c(cid INTEGER PRIMARY KEY, rid REFERENCES t(rowid));
    INSERT INTO t VALUES (100,'x');
    INSERT INTO c VALUES (1, 100);
}
expect error {
}

test fk-rowid-alias-parent-missing {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(id INTEGER PRIMARY KEY, a TEXT);
    CREATE TABLE c(cid INTEGER PRIMARY KEY, rid REFERENCES t(rowid));
    INSERT INTO c VALUES (1, 9999);
}
expect error {
}

test fk-update-child-noop-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid REFERENCES p(id));
    INSERT INTO p VALUES (1);
    INSERT INTO c VALUES (10,1);
    UPDATE c SET id = id WHERE id = 10;        -- no FK column touched
    SELECT id, pid FROM c;
}
expect {
    10|1
}

test fk-delete-parent-composite-scan {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT NOT NULL, b INT NOT NULL, PRIMARY KEY(a,b));
    CREATE TABLE c(id INT PRIMARY KEY, x INT, y INT,
    FOREIGN KEY(x,y) REFERENCES p(a,b));
    INSERT INTO p VALUES (1,2),(2,3);
    INSERT INTO c VALUES (7,2,3);
    DELETE FROM p WHERE a=2 AND b=3;
}
expect error {
}

test fk-update-child-to-existing-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(id INTEGER PRIMARY KEY);
    CREATE TABLE t2(id INTEGER PRIMARY KEY, tid REFERENCES t(id));
    INSERT INTO t VALUES (1),(2);
    INSERT INTO t2 VALUES (9,1);
    UPDATE t2 SET tid = 2 WHERE id = 9;
    SELECT id, tid FROM t2;
}
expect {
    9|2
}

test fk-composite-pk-delete-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT NOT NULL, b INT NOT NULL, PRIMARY KEY(a,b));
    CREATE TABLE c(id INT PRIMARY KEY, x INT, y INT,
    FOREIGN KEY(x,y) REFERENCES p(a,b));
    INSERT INTO p VALUES (1,2),(2,3);
    INSERT INTO c VALUES (7,2,3);
    -- Deleting a non-referenced parent tuple is OK
    DELETE FROM p WHERE a=1 AND b=2;
    SELECT a,b FROM p ORDER BY a,b;
}
expect {
    2|3
}

test fk-composite-pk-delete-violate {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT NOT NULL, b INT NOT NULL, PRIMARY KEY(a,b));
    CREATE TABLE c(id INT PRIMARY KEY, x INT, y INT,
    FOREIGN KEY(x,y) REFERENCES p(a,b));
    INSERT INTO p VALUES (2,3);
    INSERT INTO c VALUES (7,2,3);
    -- Deleting the referenced tuple should fail
    DELETE FROM p WHERE a=2 AND b=3;
}
expect error {
}

# Parent columns omitted: should default to parent's declared PRIMARY KEY (composite)
test fk-default-parent-pk-composite-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(
        a INT NOT NULL,
        b INT NOT NULL,
        PRIMARY KEY(a,b)
    );
    -- Parent columns omitted in REFERENCES p
    CREATE TABLE c(
        id INT PRIMARY KEY,
        x INT, y INT,
        FOREIGN KEY(x,y) REFERENCES p
    );
    INSERT INTO p VALUES (1,1), (1,2);
    INSERT INTO c VALUES (10,1,1), (11,1,2), (12,NULL,2);  -- NULL in child allowed
    SELECT id,x,y FROM c ORDER BY id;
}
expect {
    10|1|1
    11|1|2
    12||2
}

test fk-default-parent-pk-composite-missing {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT NOT NULL, b INT NOT NULL, PRIMARY KEY(a,b));
    CREATE TABLE c(id INT PRIMARY KEY, x INT, y INT,
    FOREIGN KEY(x,y) REFERENCES p);        -- omit parent cols
    INSERT INTO p VALUES (1,1);
    INSERT INTO c VALUES (20,1,2);                         -- (1,2) missing in parent
}
expect error {
}

# Parent has no explicitly declared PK, so we throw parse error when referencing bare table
test fk-default-parent-rowid-no-parent-pk {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p_no_pk(v TEXT);
    CREATE TABLE c_rowid(id INT PRIMARY KEY,
    r REFERENCES p_no_pk);
    INSERT INTO p_no_pk(v) VALUES ('a'), ('b');
    INSERT INTO c_rowid VALUES (1, 1);
}
expect error {
}

test fk-parent-omit-cols-parent-has-pk {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p_pk(id INTEGER PRIMARY KEY, v TEXT);
    CREATE TABLE c_ok(id INT PRIMARY KEY, r REFERENCES p_pk);  -- binds to p_pk(id)
    INSERT INTO p_pk VALUES (1,'a'),(2,'b');
    INSERT INTO c_ok VALUES (10,1);
    INSERT INTO c_ok VALUES (11,2);
    SELECT id, r FROM c_ok ORDER BY id;
}
expect {
    10|1
    11|2
}

# Self-reference (same table) with INTEGER PRIMARY KEY: single-row insert should pass
test fk-self-ipk-single-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        id  INTEGER PRIMARY KEY,
        rid REFERENCES t(id)          -- child->parent in same table
    );
    INSERT INTO t(id,rid) VALUES(5,5);       -- self-reference, single-row
    SELECT id, rid FROM t;
}
expect {
    5|5
}

# Self-reference with mismatched value: should fail immediately (no counter semantics used)
test fk-self-ipk-single-mismatch {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        id  INTEGER PRIMARY KEY,
        rid REFERENCES t(id)
    );
    INSERT INTO t(id,rid) VALUES(5,4);       -- rid!=id -> FK violation
}
expect error {
}

# Self-reference on composite PRIMARY KEY: single-row insert should pass
test fk-self-composite-single-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        a INT NOT NULL,
        b INT NOT NULL,
        x INT,
        y INT,
        PRIMARY KEY(a,b),
        FOREIGN KEY(x,y) REFERENCES t(a,b)
    );
    INSERT INTO t(a,b,x,y) VALUES(1,2,1,2);  -- self-reference matches PK
    SELECT a,b,x,y FROM t;
}
expect {
    1|2|1|2
}

# Rowid parent path: text '10' must be coerced to integer (MustBeInt) and succeed
test fk-rowid-mustbeint-coercion-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(cid INTEGER PRIMARY KEY, pid REFERENCES p(id));
    INSERT INTO p(id) VALUES(10);
    INSERT INTO c VALUES(1, '10');           -- text -> int via MustBeInt; should match
    SELECT pid FROM c;
}
expect {
    10
}

# Rowid parent path: non-numeric text cannot be coerced -> violation
test fk-rowid-mustbeint-coercion-fail {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(cid INTEGER PRIMARY KEY, pid REFERENCES p(id));
    INSERT INTO p(id) VALUES(10);
    INSERT INTO c VALUES(2, 'abc'); -- MustBeInt fails to match any parent row
}
expect error {
}

# Parent match via UNIQUE index (non-rowid), success path
test fk-parent-unique-index-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(u TEXT, v TEXT, pad INT, UNIQUE(u,v));
    CREATE TABLE child(id INT PRIMARY KEY, cu TEXT, cv TEXT,
    FOREIGN KEY(cu,cv) REFERENCES parent(u,v));
    INSERT INTO parent VALUES ('A','B',0),('A','C',0);
    INSERT INTO child  VALUES (1,'A','B');
    SELECT id, cu, cv FROM child ORDER BY id;
}
expect {
    1|A|B
}

# Parent UNIQUE index path: missing key -> immediate violation
test fk-parent-unique-index-missing {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(u TEXT, v TEXT, pad INT, UNIQUE(u,v));
    CREATE TABLE child(id INT PRIMARY KEY, cu TEXT, cv TEXT,
    FOREIGN KEY(cu,cv) REFERENCES parent(u,v));
    INSERT INTO parent VALUES ('A','B',0);
    INSERT INTO child  VALUES (2,'A','X');   -- no ('A','X') in parent
}
expect error {
}

# NULL in child short-circuits FK check
test fk-child-null-shortcircuit {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid REFERENCES p(id));
    INSERT INTO c VALUES (1, NULL);          -- NULL child is allowed
    SELECT id, pid FROM c;
}
expect {
    1|
}

test fk-self-unique-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        u TEXT,
        v TEXT,
        cu TEXT,
        cv TEXT,
        UNIQUE(u,v),
        FOREIGN KEY(cu,cv) REFERENCES t(u,v)
    );
    -- Single row insert where child points to its own (u,v): allowed
    INSERT INTO t(u,v,cu,cv) VALUES('A','B','A','B');
    SELECT u, v, cu, cv FROM t;
}
expect {
    A|B|A|B
}

test fk-self-unique-mismatch {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        u TEXT,
        v TEXT,
        cu TEXT,
        cv TEXT,
        UNIQUE(u,v),
        FOREIGN KEY(cu,cv) REFERENCES t(u,v)
    );
    -- Child points to a different (u,v) that doesn't exist: must fail
    INSERT INTO t(u,v,cu,cv) VALUES('A','B','A','X');
}
expect error {
}

test fk-self-unique-reference-existing-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        u TEXT,
        v TEXT,
        cu TEXT,
        cv TEXT,
        UNIQUE(u,v),
        FOREIGN KEY(cu,cv) REFERENCES t(u,v)
    );
    -- Insert a parent row first
    INSERT INTO t(u,v,cu,cv) VALUES('P','Q',NULL,NULL);
    -- Now insert a row whose FK references the existing ('P','Q'): OK
    INSERT INTO t(u,v,cu,cv) VALUES('X','Y','P','Q');
    SELECT u, v, cu, cv FROM t ORDER BY u, v, cu, cv;
}
expect {
    P|Q||
    X|Y|P|Q
}

test fk-self-unique-multirow-no-fastpath {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        u TEXT,
        v TEXT,
        cu TEXT,
        cv TEXT,
        UNIQUE(u,v),
        FOREIGN KEY(cu,cv) REFERENCES t(u,v)
    );
    INSERT INTO t(u,v,cu,cv) VALUES
    ('C','D','C','D'),
    ('E','F','E','F');
}
expect {
}

test fk-self-multirow-one-bad {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(id INTEGER PRIMARY KEY, rid INTEGER,
    FOREIGN KEY(rid) REFERENCES t(id));
    INSERT INTO t(id,rid) VALUES (1,1),(3,99); -- 99 has no parent -> error
}
expect error {
}

# doesnt fail because tx is un-committed
test fk-deferred-commit-doesnt-fail-early {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1, 99); -- shouldnt fail because we are mid-tx
}
expect {
}

# it should fail here because we actuall COMMIT
test fk-deferred-commit-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1, 99);
    COMMIT;
}
expect error {
}

# If we fix it before COMMIT, COMMIT succeeds
test fk-deferred-fix-before-commit-succeeds {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 99);   -- temporary violation
    INSERT INTO p VALUES(99);      -- fix parent
    COMMIT;
    SELECT * FROM p ORDER BY 1;
}
expect {
    99
}

#  ROLLBACK clears deferred state; a new tx can still fail if violation persists
test fk-deferred-rollback-clears {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 123);
    ROLLBACK;
    -- Now start over and *fix* it, COMMIT should pass.
    BEGIN;
    INSERT INTO p VALUES(123);
    INSERT INTO c VALUES(1, 123);
    COMMIT;
    SELECT * FROM c ORDER BY 1;
}
expect {
    1|123
}

test fk-deferred-insert-parent-fixes-before-commit {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 50); -- violation
    INSERT INTO p VALUES(50);    -- resolve
    COMMIT;
    SELECT * FROM c ORDER BY 1;
}
expect {
    1|50
}

test fk-deferred-update-fixes-child-before-commit {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 50); -- violation
    INSERT INTO p VALUES(32);
    UPDATE c SET pid=32 WHERE id=1; -- resolve child
    COMMIT;
    SELECT * FROM c ORDER BY 1;
}
expect {
    1|32
}

test fk-deferred-delete-fixes-child-before-commit {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 50); -- violation
    INSERT INTO p VALUES(32);
    DELETE FROM c WHERE id=1; -- resolve by deleting child
    COMMIT;
    SELECT * FROM c ORDER BY 1;
}
expect {
}

test fk-deferred-update-fixes-parent-before-commit {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 50); -- violation
    INSERT INTO p VALUES(32);
    UPDATE p SET id=50 WHERE id=32; -- resolve via parent
    COMMIT;
    SELECT * FROM c ORDER BY 1;
}
expect {
    1|50
}

# Self-referential: row referencing itself should succeed
test fk-deferred-self-ref-succeeds {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES t(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO t VALUES(1, 1);    -- self-match
    COMMIT;
    SELECT * FROM t ORDER BY 1;
}
expect {
    1|1
}

# Two-step self-ref: insert invalid, then create parent before COMMIT
test fk-deferred-self-ref-late-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES t(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO t VALUES(2, 3);  -- currently invalid
    INSERT INTO t VALUES(3, 3);  -- now parent exists
    COMMIT;
    SELECT * FROM t ORDER BY 1;
}
expect {
    2|3
    3|3
}

# counter must not be neutralized by later good statements
test fk-deferred-neutralize_1 {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE parent_comp(a INT NOT NULL, b INT NOT NULL, PRIMARY KEY(a,b));
    CREATE TABLE child_deferred(id INTEGER PRIMARY KEY, pid INT,
    FOREIGN KEY(pid) REFERENCES parent(id));
    CREATE TABLE child_comp_deferred(id INTEGER PRIMARY KEY, ca INT, cb INT,
    FOREIGN KEY(ca,cb) REFERENCES parent_comp(a,b));
    INSERT INTO parent_comp VALUES (4,-1);
    BEGIN;
    INSERT INTO child_deferred VALUES (1, 999);
    INSERT INTO child_comp_deferred VALUES (2, 4, -1);
    COMMIT;
}
expect error {
}

test fk-deferred-upsert-late-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 50);                 -- deferred violation
    INSERT INTO p VALUES(32);                    -- parent exists, but pid still 50
    INSERT INTO c(id,pid) VALUES(1,32)
        ON CONFLICT(id) DO UPDATE SET pid=excluded.pid;  -- resolve child via UPSERT
    COMMIT;
    -- Expect: row is (1,32) and no violations remain
    SELECT * FROM c ORDER BY id;
}
expect {
    1|32
}

test fk-deferred-upsert-late-child {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(
        id INTEGER PRIMARY KEY,
        u  INT UNIQUE
    );
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 50);                 -- deferred violation (no parent 50)
    INSERT INTO p VALUES(32, 7);                 -- parent row with u=7
    -- Trigger DO UPDATE via conflict on p.u, then change the PK id to 50,
    -- which satisfies the child reference.
    INSERT INTO p(id,u) VALUES(999,7)
        ON CONFLICT(u) DO UPDATE SET id=50;
    COMMIT;
    -- Expect: parent is now (50,7), child (1,50), no violations remain
    SELECT p.id, c.id FROM p  join c on c.pid = p.id;
}
expect {
    50|1
}

test fk-deferred-insert-commit-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INTEGER REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 99);  -- no parent -> deferred violation
    COMMIT;                          -- must fail
}
expect error {
}

test fk-deferred-insert-parent-fix-before-commit {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id  INTEGER PRIMARY KEY,
        pid INTEGER REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO c VALUES(1, 99);   -- violation
    INSERT INTO p VALUES(99);      -- fix by inserting parent
    COMMIT;
    SELECT id, pid FROM c ORDER BY id;
}
expect {
    1|99
}

test fk-deferred-insert-multi-children-one-parent-fix {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1, 50);
    INSERT INTO c VALUES(2, 50);   -- two violations pointing to same parent
    INSERT INTO p VALUES(50);      -- one parent fixes both
    COMMIT;
    SELECT id, pid FROM c ORDER BY id;
}
expect {
    1|50
    2|50
}

test fk-deferred-insert-then-delete-child-fix {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1, 77);   -- violation
    DELETE FROM c WHERE id=1;      -- resolve by removing the child
    COMMIT;
    SELECT count(*) FROM c;
}
expect {
    0
}

test fk-deferred-insert-self-ref-succeeds {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES t(id) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO t VALUES(1, 1);    -- self-reference, legal at COMMIT
    COMMIT;
    SELECT id, pid FROM t;
}
expect {
    1|1
}

test fk-deferred-update-child-breaks-commit-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(10);
    INSERT INTO c VALUES(1, 10);     -- valid
    BEGIN;
    UPDATE c SET pid=99 WHERE id=1;  -- create violation
    COMMIT;                             -- must fail
}
expect error {
}

test fk-deferred-update-child-fix-before-commit {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(10);
    INSERT INTO c VALUES(1, 10);
    BEGIN;
    UPDATE c SET pid=99 WHERE id=1;  -- violation
    UPDATE c SET pid=10 WHERE id=1;  -- fix child back
    COMMIT;
    SELECT id, pid FROM c;
}
expect {
    1|10
}

test fk-deferred-update-child-fix-by-inserting-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(10);
    INSERT INTO c VALUES(1, 10);
    BEGIN;
    UPDATE c SET pid=50 WHERE id=1;  -- violation
    INSERT INTO p VALUES(50);        -- fix by adding parent
    COMMIT;
    SELECT id, pid FROM c;
}
expect {
    1|50
}

test fk-deferred-update-parent-breaks-commit-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(32);
    INSERT INTO c VALUES(1, 32);      -- valid
    BEGIN;
    UPDATE p SET id=50 WHERE id=32;  -- break child reference
    COMMIT;                            -- must fail (no fix)
}
expect error {
}

test fk-deferred-update-parent-fix-by-updating-child {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(32);
    INSERT INTO c VALUES(1, 32);
    BEGIN;
    UPDATE p SET id=50 WHERE id=32;  -- break
    UPDATE c SET pid=50 WHERE id=1;  -- fix child to new parent key
    COMMIT;
    SELECT id, pid FROM c;
}
expect {
    1|50
}

test fk-deferred-update-parent-fix-by-reverting-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(32);
    INSERT INTO c VALUES(1, 32);
    BEGIN;
    UPDATE p SET id=50 WHERE id=32;  -- break
    UPDATE p SET id=32 WHERE id=50;  -- revert (fix)
    COMMIT;
    SELECT id, pid FROM c;
}
expect {
    1|32
}

test fk-deferred-update-self-ref-id-change-and-fix {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES t(id) DEFERRABLE INITIALLY DEFERRED
    );
    INSERT INTO t VALUES(1,1);
    BEGIN;
    UPDATE t SET id=2 WHERE id=1;   -- break self-ref
    UPDATE t SET pid=2 WHERE id=2;  -- fix to new self
    COMMIT;
    SELECT id, pid FROM t;
}
expect {
    2|2
}

test fk-deferred-delete-parent-commit-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(10);
    INSERT INTO c VALUES(1, 10);      -- valid
    BEGIN;
    DELETE FROM p WHERE id=10;      -- break reference
    COMMIT;                            -- must fail
}
expect error {
}

test fk-deferred-delete-parent-then-delete-child-fix {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(10);
    INSERT INTO c VALUES(1, 10);
    BEGIN;
    DELETE FROM p WHERE id=10;      -- break
    DELETE FROM c WHERE id=1;       -- fix by removing child
    COMMIT;
    SELECT count(*) FROM p, c;        -- both empty
}
expect {
    0
}

test fk-deferred-delete-parent-then-reinsert-parent-fix {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(10);
    INSERT INTO c VALUES(1, 10);
    BEGIN;
    DELETE FROM p WHERE id=10;      -- break
    INSERT INTO p VALUES(10);       -- fix by re-creating parent
    COMMIT;
    SELECT id, pid FROM c;
}
expect {
    1|10
}

test fk-deferred-delete-self-ref-row-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(
        id  INTEGER PRIMARY KEY,
        pid INT REFERENCES t(id) DEFERRABLE INITIALLY DEFERRED
    );
    INSERT INTO t VALUES(1,1);        -- valid
    BEGIN;
    DELETE FROM t WHERE id=1;       -- removes both child+parent (same row)
    COMMIT;                           -- should succeed
    SELECT count(*) FROM t;
}
expect {
    0
}

test fk-deferred-delete-parent-then-update-child-to-null-fix {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(
        id INTEGER PRIMARY KEY,
        pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED
    );
    INSERT INTO p VALUES(5);
    INSERT INTO c VALUES(1,5);
    BEGIN;
    DELETE FROM p WHERE id=5;       -- break
    UPDATE c SET pid=NULL WHERE id=1;  -- fix (NULL never violates)
    COMMIT;
    SELECT id, pid FROM c;
}
expect {
    1|
}

# AUTOCOMMIT: deferred FK still fails at end-of-statement
test fk-deferred-autocommit-insert-missing-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid INT REFERENCES parent(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO child VALUES(1, 3);   -- no BEGIN; should fail at statement end
}
expect error {
}

# AUTOCOMMIT: self-referential insert is OK (parent is same row)
test fk-deferred-autocommit-selfref-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(id INTEGER PRIMARY KEY, pid INT REFERENCES t(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO t VALUES(1,1);
    SELECT * FROM t;
}
expect {
    1|1
}

# AUTOCOMMIT: deleting a parent that has a child → fails at statement end
test fk-deferred-autocommit-delete-parent-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(1);
    INSERT INTO c VALUES(10,1);
    DELETE FROM p WHERE id=1;   -- no BEGIN; should fail at statement end
}
expect error {
}

# TX: delete a referenced parent then reinsert before COMMIT -> OK
test fk-deferred-tx-delete-parent-then-reinsert-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(5);
    INSERT INTO c VALUES(1,5);
    BEGIN;
    DELETE FROM p WHERE id=5;  -- violation (deferred)
    INSERT INTO p VALUES(5);   -- fix in same tx
    COMMIT;
    SELECT count(*) FROM p WHERE id=5;
}
expect {
    1
}

# TX: multiple violating children, later insert parent, COMMIT -> OK
test fk-deferred-tx-multi-children-fixed-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1,99);
    INSERT INTO c VALUES(2,99);
    INSERT INTO p VALUES(99);
    COMMIT;
    SELECT id,pid FROM c ORDER BY id;
}
expect {
    1|99
    2|99
}

#  one of several children left unfixed -> COMMIT fails
test fk-deferred-tx-multi-children-one-left-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1,42);
    INSERT INTO c VALUES(2,42);
    INSERT INTO p VALUES(42);
    UPDATE c SET pid=777 WHERE id=2;  -- reintroduce a bad reference
    COMMIT;  -- should fail
}
expect error {
}

# composite PK parent, fix via parent UPDATE before COMMIT -> OK
test fk-deferred-composite-parent-update-fix {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a INT NOT NULL, b INT NOT NULL, PRIMARY KEY(a,b));
    CREATE TABLE child(id INT PRIMARY KEY, ca INT, cb INT,
    FOREIGN KEY(ca,cb) REFERENCES parent(a,b) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO parent VALUES(1,1);
    BEGIN;
    INSERT INTO child VALUES(10, 7, 7);        -- violation
    UPDATE parent SET a=7, b=7 WHERE a=1 AND b=1;  -- fix composite PK
    COMMIT;
    SELECT id, ca, cb FROM child;
}
expect {
    10|7|7
}

# TX: NULL in child FK -> never a violation
test fk-deferred-null-fk-never-violates {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1, NULL);  -- always OK
    COMMIT;
    SELECT id, pid FROM c;
}
expect {
    1|
}

# TX: child UPDATE to NULL resolves before COMMIT
test fk-deferred-update-child-null-resolves {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1, 500);  -- violation
    UPDATE c SET pid=NULL WHERE id=1; -- resolves
    COMMIT;
    SELECT * FROM c;
}
expect {
    1|
}

# TX: delete violating child resolves before COMMIT
test fk-deferred-delete-child-resolves {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1, 777);  -- violation
    DELETE FROM c WHERE id=1;      -- resolves
    COMMIT;
    SELECT count(*) FROM c;
}
expect {
    0
}

# TX: update parent PK to match child before COMMIT -> OK
test fk-deferred-update-parent-pk-resolves {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO p VALUES(10);
    BEGIN;
    INSERT INTO c VALUES(1, 20);   -- violation
    UPDATE p SET id=20 WHERE id=10; -- resolve via parent
    COMMIT;
    SELECT * FROM c;
}
expect {
    1|20
}

# Two-table cycle; both inserted before COMMIT -> OK
test fk-deferred-cycle-two-tables-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE a(id INT PRIMARY KEY, b_id INT, FOREIGN KEY(b_id) REFERENCES b(id) DEFERRABLE INITIALLY DEFERRED);
    CREATE TABLE b(id INT PRIMARY KEY, a_id INT, FOREIGN KEY(a_id) REFERENCES a(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO a VALUES(1, 1);  -- refers to b(1) (not yet present)
    INSERT INTO b VALUES(1, 1);  -- refers to a(1)
    COMMIT;
    SELECT count(b.id), count(a.id) FROM a, b;
}
expect {
    1|1
}

# Delete a row that self-references (child==parent) within a tx -> OK
test fk-deferred-selfref-delete-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t(id INTEGER PRIMARY KEY, pid INT REFERENCES t(id) DEFERRABLE INITIALLY DEFERRED);
    INSERT INTO t VALUES(1,1);
    BEGIN;
    DELETE FROM t WHERE id=1;
    COMMIT;
    SELECT count(*) FROM t;
}
expect {
    0
}

test fk-parentcomp-donothing-noconflict-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent (id INTEGER PRIMARY KEY, a INT, b INT);
    CREATE TABLE child_deferred (
        id INTEGER PRIMARY KEY, pid INT, x INT,
        FOREIGN KEY(pid) REFERENCES parent(id) DEFERRABLE INITIALLY DEFERRED
    );
    CREATE TABLE parent_comp (a INT NOT NULL, b INT NOT NULL, c INT, PRIMARY KEY(a,b));
    CREATE TABLE child_comp_deferred (
        id INTEGER PRIMARY KEY, ca INT, cb INT, z INT,
        FOREIGN KEY (ca,cb) REFERENCES parent_comp(a,b) DEFERRABLE INITIALLY DEFERRED
    );
    -- No conflict on (a,b); should insert 1 row, no FK noise
    INSERT INTO parent_comp VALUES (-1,-1,9) ON CONFLICT DO NOTHING;
    SELECT a,b,c FROM parent_comp ORDER BY a,b;
}
expect {
    -1|-1|9
}

test fk-parentcomp-donothing-conflict-noop {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent_comp (a INT NOT NULL, b INT NOT NULL, c INT, PRIMARY KEY(a,b));
    CREATE TABLE child_comp_deferred (
        id INTEGER PRIMARY KEY, ca INT, cb INT, z INT,
        FOREIGN KEY (ca,cb) REFERENCES parent_comp(a,b) DEFERRABLE INITIALLY DEFERRED
    );
    INSERT INTO parent_comp VALUES (10,20,1);
    -- Conflicts with existing (10,20); must do nothing (no triggers, no FK scans that mutate counters)
    INSERT INTO parent_comp VALUES (10,20,999) ON CONFLICT DO NOTHING;
    SELECT a,b,c FROM parent_comp;
}
expect {
    10|20|1
}

test fk-parentcomp-donothing-unrelated-immediate-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent (id INTEGER PRIMARY KEY);
    CREATE TABLE child_immediate (
        id INTEGER PRIMARY KEY, pid INT,
        FOREIGN KEY(pid) REFERENCES parent(id)          -- IMMEDIATE
    );
    CREATE TABLE parent_comp (a INT NOT NULL, b INT NOT NULL, c INT, PRIMARY KEY(a,b));
    CREATE TABLE child_comp_deferred (
        id INTEGER PRIMARY KEY, ca INT, cb INT, z INT,
        FOREIGN KEY(ca,cb) REFERENCES parent_comp(a,b) DEFERRABLE INITIALLY DEFERRED
    );
    INSERT INTO parent_comp VALUES (-1,-1,9) ON CONFLICT DO NOTHING;
    SELECT a,b,c FROM parent_comp;
}
expect {
    -1|-1|9
}

test fk-parentcomp-deferred-fix-inside-tx-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent_comp (a INT NOT NULL, b INT NOT NULL, c INT, PRIMARY KEY(a,b));
    CREATE TABLE child_comp_deferred (
        id INTEGER PRIMARY KEY, ca INT, cb INT,
        FOREIGN KEY(ca,cb) REFERENCES parent_comp(a,b) DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    INSERT INTO child_comp_deferred VALUES (1, -5, -6);  -- violation
    INSERT INTO parent_comp VALUES (-5, -6, 9);          -- fix via parent insert
    COMMIT;
    SELECT id,ca,cb FROM child_comp_deferred;
}
expect {
    1|-5|-6
}

test fk-parentcomp-autocommit-unrelated-children-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent_comp (a INT NOT NULL, b INT NOT NULL, c INT, PRIMARY KEY(a,b));
    CREATE TABLE child_comp_deferred (
        id INTEGER PRIMARY KEY, ca INT, cb INT,
        FOREIGN KEY(ca,cb) REFERENCES parent_comp(a,b) DEFERRABLE INITIALLY DEFERRED
    );
    INSERT INTO parent_comp VALUES (1,1,0);
    INSERT INTO child_comp_deferred VALUES (10,1,1);    -- valid
    INSERT INTO parent_comp VALUES (2,2,0) ON CONFLICT DO NOTHING;  -- unrelated insert; must not raise
    SELECT a,b,c FROM parent_comp ORDER BY a,b;
}
expect {
    1|1|0
    2|2|0
}

# ROLLBACK must clear any deferred state; next statement must not trip.
test fk-rollback-clears-then-donothing-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    CREATE TABLE parent_comp(a INT NOT NULL, b INT NOT NULL, c INT, PRIMARY KEY(a,b));
    BEGIN;
    INSERT INTO c VALUES(1, 456);   -- create deferred violation
    ROLLBACK;                          -- must clear counters
    INSERT INTO parent_comp VALUES(-2,-2,0) ON CONFLICT DO NOTHING;
    SELECT a,b,c FROM parent_comp;
}
expect {
    -2|-2|0
}

# DO NOTHING conflict path must touch no FK maintenance at all.
test fk-parentcomp-donothing-conflict-stays-quiet {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent_comp(a INT NOT NULL, b INT NOT NULL, c INT, PRIMARY KEY(a,b));
    CREATE TABLE child_comp_deferred(
        id INTEGER PRIMARY KEY, ca INT, cb INT,
        FOREIGN KEY(ca,cb) REFERENCES parent_comp(a,b) DEFERRABLE INITIALLY DEFERRED
    );
    INSERT INTO parent_comp VALUES(10,20,1);
    -- This conflicts with (10,20) and must be a no-op; if counters move here, it’s a bug.
    INSERT INTO parent_comp VALUES(10,20,999) ON CONFLICT DO NOTHING;
    -- Prove DB is sane afterwards (no stray FK error)
    INSERT INTO parent_comp VALUES(11,22,3) ON CONFLICT DO NOTHING;
    SELECT a,b FROM parent_comp ORDER BY a,b;
}
expect {
    10|20
    11|22
}

# Two-statement fix inside an explicit transaction (separate statements).
#Insert child (violation), then insert parent in a new statement; commit must pass.
test fk-deferred-two-stmt-fix-inside-tx-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid INT REFERENCES p(id) DEFERRABLE INITIALLY DEFERRED);
    BEGIN;
    INSERT INTO c VALUES(1, 777);   -- violation recorded in tx
    INSERT INTO p VALUES(777);      -- next statement fixes it
    COMMIT;
    SELECT * FROM c;
}
expect {
    1|777
}

test fk-delete-composite-bounds {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT NOT NULL, b INT NOT NULL, v INT, PRIMARY KEY(a,b));
    CREATE TABLE c(id INTEGER PRIMARY KEY, x INT, y INT, w INT,
    FOREIGN KEY(x,y) REFERENCES p(a,b));
    INSERT INTO p VALUES (5,1,0),(5,2,0),(5,4,0);
    INSERT INTO c VALUES (1,5,4,0);  -- child references (5,4)
    -- This should be a no-op (no row (5,3)), and MUST NOT error.
    DELETE FROM p WHERE a=5 AND b=3;
}
expect {
}

# Single column unique index on parent, FK referenced by child
test fk-update-parent-unique-single-col {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id UNIQUE);
    CREATE TABLE child(pid REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(1);
    UPDATE parent SET id = 2 WHERE id = 1;
}
expect error {
}

# Single column with explicit CREATE UNIQUE INDEX
test fk-update-parent-explicit-unique-single-col {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id);
    CREATE UNIQUE INDEX parent_id_idx ON parent(id);
    CREATE TABLE child(pid REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(1);
    UPDATE parent SET id = 2 WHERE id = 1;
}
expect error {
}

# Multi-column unique index on parent, FK referenced by multi-column FK in child
test fk-update-parent-unique-multi-col {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a, b, UNIQUE(a, b));
    CREATE TABLE child(ca, cb, FOREIGN KEY(ca, cb) REFERENCES parent(a, b));
    INSERT INTO parent VALUES(1, 2);
    INSERT INTO child VALUES(1, 2);
    UPDATE parent SET a = 3 WHERE a = 1 AND b = 2;
}
expect error {
}

# Multi-column unique index on parent, FK referenced by multi-column FK in child
test fk-update-parent-unique-multi-col-2 {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a, b, UNIQUE(a, b));
    CREATE TABLE child(ca, cb, FOREIGN KEY(ca, cb) REFERENCES parent(a, b));
    INSERT INTO parent VALUES(1, 2);
    INSERT INTO child VALUES(1, 2);
    UPDATE parent SET b = 3 WHERE a = 1 AND b = 2;
}
expect error {
}

# Multi-column index defined explicitly as CREATE UNIQUE INDEX
test fk-update-parent-explicit-unique-multi-col {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a, b);
    CREATE UNIQUE INDEX parent_ab_idx ON parent(a, b);
    CREATE TABLE child(ca, cb, FOREIGN KEY(ca, cb) REFERENCES parent(a, b));
    INSERT INTO parent VALUES(1, 2);
    INSERT INTO child VALUES(1, 2);
    UPDATE parent SET a = 3 WHERE a = 1 AND b = 2;
}
expect error {
}

# Multi-column index defined explicitly as CREATE UNIQUE INDEX
test fk-update-parent-explicit-unique-multi-col-2 {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a, b);
    CREATE UNIQUE INDEX parent_ab_idx ON parent(a, b);
    CREATE TABLE child(ca, cb, FOREIGN KEY(ca, cb) REFERENCES parent(a, b));
    INSERT INTO parent VALUES(1, 2);
    INSERT INTO child VALUES(1, 2);
    UPDATE parent SET b = 3 WHERE a = 1 AND b = 2;
}
expect error {
}

# Single column INTEGER PRIMARY KEY
test fk-update-parent-int-pk {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(pid REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(1);
    UPDATE parent SET id = 2 WHERE id = 1;
}
expect error {
}

# Single column TEXT PRIMARY KEY
test fk-update-parent-text-pk {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id PRIMARY KEY);
    CREATE TABLE child(pid REFERENCES parent(id));
    INSERT INTO parent VALUES('key1');
    INSERT INTO child VALUES('key1');
    UPDATE parent SET id = 'key2' WHERE id = 'key1';
}
expect error {
}

# Multi-column PRIMARY KEY
test fk-update-parent-multi-col-pk {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a, b, PRIMARY KEY(a, b));
    CREATE TABLE child(ca, cb, FOREIGN KEY(ca, cb) REFERENCES parent(a, b));
    INSERT INTO parent VALUES(1, 2);
    INSERT INTO child VALUES(1, 2);
    UPDATE parent SET a = 3 WHERE a = 1 AND b = 2;
}
expect error {
}

# Multi-column PRIMARY KEY
test fk-update-parent-multi-col-pk-2 {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a, b, PRIMARY KEY(a, b));
    CREATE TABLE child(ca, cb, FOREIGN KEY(ca, cb) REFERENCES parent(a, b));
    INSERT INTO parent VALUES(1, 2);
    INSERT INTO child VALUES(1, 2);
    UPDATE parent SET b = 3 WHERE a = 1 AND b = 2;
}
expect error {
}

# https://github.com/tursodatabase/turso/issues/3965
test fk-no-val-on-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t1(
        a INT,
        b INT
    );
    CREATE TABLE t2(
        x INT,
        y INT,
        FOREIGN KEY (x, y) REFERENCES t1(a, b)
    );
    INSERT INTO t1(a, b) VALUES (5, 10);
    SELECT * FROM t1;
}
expect {
    5|10
}

test fk-val-on-parent {
    PRAGMA foreign_keys=ON;
    CREATE TABLE t1(
        a INT,
        b INT
    );
    CREATE TABLE t2(
        x INT,
        y INT,
        FOREIGN KEY (x, y) REFERENCES t1(a, b)
    );
    INSERT INTO t2(a, b) VALUES (5, 10);
    SELECT * FROM t2;
}
expect error {
}

# Basic ON DELETE CASCADE - single child row
test fk-cascade-delete-basic {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1),(2);
    INSERT INTO child VALUES(10,1),(11,1),(12,2);
    DELETE FROM parent WHERE id=1;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    12|2
}

# ON DELETE CASCADE - delete parent with no children
test fk-cascade-delete-no-children {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1),(2);
    INSERT INTO child VALUES(10,1);
    DELETE FROM parent WHERE id=2;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    10|1
}

# ON DELETE CASCADE - composite key
test fk-cascade-delete-composite {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT, b INT, PRIMARY KEY(a,b));
    CREATE TABLE c(id INTEGER PRIMARY KEY, x INT, y INT,
        FOREIGN KEY(x,y) REFERENCES p(a,b) ON DELETE CASCADE);
    INSERT INTO p VALUES(1,2),(3,4);
    INSERT INTO c VALUES(1,1,2),(2,3,4);
    DELETE FROM p WHERE a=1 AND b=2;
    SELECT id, x, y FROM c ORDER BY id;
}
expect {
    2|3|4
}

# ON DELETE CASCADE - child with NULL FK value should not be deleted
test fk-cascade-delete-null-child {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10,1),(11,NULL);
    DELETE FROM parent WHERE id=1;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    11|
}

# ON DELETE CASCADE - recursive cascade (A->B->C)
test fk-cascade-delete-recursive {
    PRAGMA foreign_keys=ON;
    CREATE TABLE a(id INTEGER PRIMARY KEY);
    CREATE TABLE b(id INTEGER PRIMARY KEY, aid REFERENCES a(id) ON DELETE CASCADE);
    CREATE TABLE c(id INTEGER PRIMARY KEY, bid REFERENCES b(id) ON DELETE CASCADE);
    INSERT INTO a VALUES(1);
    INSERT INTO b VALUES(10,1);
    INSERT INTO c VALUES(100,10);
    DELETE FROM a WHERE id=1;
    SELECT count(*) FROM b;
}
expect {
    0
}

test fk-cascade-delete-recursive-check-c {
    PRAGMA foreign_keys=ON;
    CREATE TABLE a(id INTEGER PRIMARY KEY);
    CREATE TABLE b(id INTEGER PRIMARY KEY, aid REFERENCES a(id) ON DELETE CASCADE);
    CREATE TABLE c(id INTEGER PRIMARY KEY, bid REFERENCES b(id) ON DELETE CASCADE);
    INSERT INTO a VALUES(1);
    INSERT INTO b VALUES(10,1);
    INSERT INTO c VALUES(100,10);
    DELETE FROM a WHERE id=1;
    SELECT count(*) FROM c;
}
expect {
    0
}

# Basic ON UPDATE CASCADE - single child row
test fk-cascade-update-basic {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON UPDATE CASCADE);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10,1);
    UPDATE parent SET id=100 WHERE id=1;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    10|100
}

# ON UPDATE CASCADE - multiple children
test fk-cascade-update-multi-children {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid REFERENCES p(id) ON UPDATE CASCADE);
    INSERT INTO p VALUES(1);
    INSERT INTO c VALUES(10,1),(11,1),(12,1);
    UPDATE p SET id=99 WHERE id=1;
    SELECT id, pid FROM c ORDER BY id;
}
expect {
    10|99
    11|99
    12|99
}

# ON UPDATE CASCADE - composite key
test fk-cascade-update-composite {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT, b INT, PRIMARY KEY(a,b));
    CREATE TABLE c(id INTEGER PRIMARY KEY, x INT, y INT,
        FOREIGN KEY(x,y) REFERENCES p(a,b) ON UPDATE CASCADE);
    INSERT INTO p VALUES(1,2);
    INSERT INTO c VALUES(1,1,2);
    UPDATE p SET a=10, b=20 WHERE a=1 AND b=2;
    SELECT id, x, y FROM c;
}
expect {
    1|10|20
}

# Basic ON DELETE SET NULL
test fk-setnull-delete-basic {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid REFERENCES p(id) ON DELETE SET NULL);
    INSERT INTO p VALUES(1);
    INSERT INTO c VALUES(10,1);
    DELETE FROM p WHERE id=1;
    SELECT id, pid FROM c;
}
expect {
    10|
}

# ON DELETE SET NULL - multiple children
test fk-setnull-delete-multi-children {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid REFERENCES p(id) ON DELETE SET NULL);
    INSERT INTO p VALUES(1),(2);
    INSERT INTO c VALUES(10,1),(11,1),(12,2);
    DELETE FROM p WHERE id=1;
    SELECT id, pid FROM c ORDER BY id;
}
expect {
    10|
    11|
    12|2
}

# ON DELETE SET NULL - composite key
test fk-setnull-delete-composite {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT, b INT, PRIMARY KEY(a,b));
    CREATE TABLE c(id INTEGER PRIMARY KEY, x INT, y INT,
        FOREIGN KEY(x,y) REFERENCES p(a,b) ON DELETE SET NULL);
    INSERT INTO p VALUES(1,2);
    INSERT INTO c VALUES(1,1,2);
    DELETE FROM p WHERE a=1 AND b=2;
    SELECT id, x, y FROM c;
}
expect {
    1||
}

# Basic ON UPDATE SET NULL
test fk-setnull-update-basic {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid REFERENCES p(id) ON UPDATE SET NULL);
    INSERT INTO p VALUES(1);
    INSERT INTO c VALUES(10,1);
    UPDATE p SET id=100 WHERE id=1;
    SELECT id, pid FROM c;
}
expect {
    10|
}

# ON DELETE CASCADE with ON UPDATE NO ACTION
test fk-cascade-delete-noaction-update {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid REFERENCES p(id) ON DELETE CASCADE ON UPDATE NO ACTION);
    INSERT INTO p VALUES(1),(2);
    INSERT INTO c VALUES(10,1),(11,2);
    DELETE FROM p WHERE id=1;
    SELECT id, pid FROM c ORDER BY id;
}
expect {
    11|2
}

# ON DELETE NO ACTION with ON UPDATE CASCADE
test fk-noaction-delete-cascade-update {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY);
    CREATE TABLE c(id INTEGER PRIMARY KEY, pid REFERENCES p(id) ON DELETE NO ACTION ON UPDATE CASCADE);
    INSERT INTO p VALUES(1);
    INSERT INTO c VALUES(10,1);
    UPDATE p SET id=100 WHERE id=1;
    SELECT id, pid FROM c;
}
expect {
    10|100
}

# INSERT OR REPLACE with ON DELETE CASCADE
test fk-replace-delete-cascade {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, name TEXT);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1,'Alice'),(2,'Bob');
    INSERT INTO child VALUES(10,1),(20,1),(30,2);
    INSERT OR REPLACE INTO parent VALUES(1,'Alice Updated');
    SELECT id, parent_id FROM child ORDER BY id;
}
expect {
    30|2
}

# INSERT OR REPLACE with ON DELETE SET NULL
test fk-replace-delete-setnull {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, name TEXT);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON DELETE SET NULL);
    INSERT INTO parent VALUES(1,'Alice'),(2,'Bob');
    INSERT INTO child VALUES(10,1),(20,1),(30,2);
    INSERT OR REPLACE INTO parent VALUES(1,'Alice Updated');
    SELECT id, parent_id FROM child ORDER BY id;
}
expect {
    10|
    20|
    30|2
}

# INSERT OR REPLACE with ON DELETE SET DEFAULT
test fk-replace-delete-setdefault {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, name TEXT);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id INTEGER DEFAULT 999 REFERENCES parent(id) ON DELETE SET DEFAULT);
    INSERT INTO parent VALUES(1,'Alice'),(2,'Bob'),(999,'Default');
    INSERT INTO child VALUES(10,1),(20,1),(30,2);
    INSERT OR REPLACE INTO parent VALUES(1,'Alice Updated');
    SELECT id, parent_id FROM child ORDER BY id;
}
expect {
    10|999
    20|999
    30|2
}

# INSERT OR REPLACE with composite FK and ON DELETE CASCADE
test fk-replace-delete-cascade-composite {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(a INT, b INT, name TEXT, PRIMARY KEY(a,b));
    CREATE TABLE c(id INTEGER PRIMARY KEY, x INT, y INT,
        FOREIGN KEY(x,y) REFERENCES p(a,b) ON DELETE CASCADE);
    INSERT INTO p VALUES(1,2,'orig'),(3,4,'other');
    INSERT INTO c VALUES(10,1,2),(20,3,4);
    INSERT OR REPLACE INTO p VALUES(1,2,'new');
    SELECT id, x, y FROM c ORDER BY id;
}
expect {
    20|3|4
}

# INSERT OR REPLACE with recursive cascade (A->B->C)
test fk-replace-delete-cascade-recursive {
    PRAGMA foreign_keys=ON;
    CREATE TABLE a(id INTEGER PRIMARY KEY, name TEXT);
    CREATE TABLE b(id INTEGER PRIMARY KEY, aid REFERENCES a(id) ON DELETE CASCADE);
    CREATE TABLE c(id INTEGER PRIMARY KEY, bid REFERENCES b(id) ON DELETE CASCADE);
    INSERT INTO a VALUES(1,'x');
    INSERT INTO b VALUES(10,1);
    INSERT INTO c VALUES(100,10);
    INSERT OR REPLACE INTO a VALUES(1,'y');
    SELECT count(*) FROM b;
}
expect {
    0
}

test fk-replace-delete-cascade-recursive-check-c {
    PRAGMA foreign_keys=ON;
    CREATE TABLE a(id INTEGER PRIMARY KEY, name TEXT);
    CREATE TABLE b(id INTEGER PRIMARY KEY, aid REFERENCES a(id) ON DELETE CASCADE);
    CREATE TABLE c(id INTEGER PRIMARY KEY, bid REFERENCES b(id) ON DELETE CASCADE);
    INSERT INTO a VALUES(1,'x');
    INSERT INTO b VALUES(10,1);
    INSERT INTO c VALUES(100,10);
    INSERT OR REPLACE INTO a VALUES(1,'y');
    SELECT count(*) FROM c;
}
expect {
    0
}

# UPSERT with ON UPDATE CASCADE
test fk-upsert-update-cascade {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, val INTEGER UNIQUE);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_val REFERENCES parent(val) ON UPDATE CASCADE);
    INSERT INTO parent VALUES(1,100);
    INSERT INTO child VALUES(10,100);
    INSERT INTO parent VALUES(1,200) ON CONFLICT(id) DO UPDATE SET val=200;
    SELECT id, parent_val FROM child;
}
expect {
    10|200
}

# UPSERT with ON UPDATE SET NULL
test fk-upsert-update-setnull {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, val INTEGER UNIQUE);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_val REFERENCES parent(val) ON UPDATE SET NULL);
    INSERT INTO parent VALUES(1,100);
    INSERT INTO child VALUES(10,100);
    INSERT INTO parent VALUES(1,200) ON CONFLICT(id) DO UPDATE SET val=200;
    SELECT id, parent_val FROM child;
}
expect {
    10|
}

# UPSERT with ON UPDATE SET DEFAULT
test fk-upsert-update-setdefault {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, val INTEGER UNIQUE);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_val INTEGER DEFAULT 999 REFERENCES parent(val) ON UPDATE SET DEFAULT);
    INSERT INTO parent VALUES(1,100),(2,999);
    INSERT INTO child VALUES(10,100);
    INSERT INTO parent VALUES(1,200) ON CONFLICT(id) DO UPDATE SET val=200;
    SELECT id, parent_val FROM child;
}
expect {
    10|999
}

# UPSERT with multiple children and ON UPDATE CASCADE
test fk-upsert-update-cascade-multi-children {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, val INTEGER UNIQUE);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_val REFERENCES parent(val) ON UPDATE CASCADE);
    INSERT INTO parent VALUES(1,100);
    INSERT INTO child VALUES(10,100),(11,100),(12,100);
    INSERT INTO parent VALUES(1,200) ON CONFLICT(id) DO UPDATE SET val=200;
    SELECT id, parent_val FROM child ORDER BY id;
}
expect {
    10|200
    11|200
    12|200
}

# UPSERT with composite FK and ON UPDATE CASCADE
test fk-upsert-update-cascade-composite {
    PRAGMA foreign_keys=ON;
    CREATE TABLE p(id INTEGER PRIMARY KEY, a INT, b INT, UNIQUE(a,b));
    CREATE TABLE c(id INTEGER PRIMARY KEY, x INT, y INT,
        FOREIGN KEY(x,y) REFERENCES p(a,b) ON UPDATE CASCADE);
    INSERT INTO p VALUES(1,10,20);
    INSERT INTO c VALUES(100,10,20);
    INSERT INTO p VALUES(1,30,40) ON CONFLICT(id) DO UPDATE SET a=30, b=40;
    SELECT id, x, y FROM c;
}
expect {
    100|30|40
}

# UPSERT recursive cascade (A->B->C)
test fk-upsert-update-cascade-recursive {
    PRAGMA foreign_keys=ON;
    CREATE TABLE a(id INTEGER PRIMARY KEY, val INTEGER UNIQUE);
    CREATE TABLE b(id INTEGER PRIMARY KEY, a_val REFERENCES a(val) ON UPDATE CASCADE, b_val INTEGER UNIQUE);
    CREATE TABLE c(id INTEGER PRIMARY KEY, b_val REFERENCES b(b_val) ON UPDATE CASCADE);
    INSERT INTO a VALUES(1,100);
    INSERT INTO b VALUES(10,100,200);
    INSERT INTO c VALUES(100,200);
    INSERT INTO a VALUES(1,999) ON CONFLICT(id) DO UPDATE SET val=999;
    SELECT id, a_val, b_val FROM b;
}
expect {
    10|999|200
}

# UPSERT that doesn't change the FK column should not trigger cascade
test fk-upsert-update-cascade-noop {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, val INTEGER UNIQUE, other TEXT);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_val REFERENCES parent(val) ON UPDATE CASCADE);
    INSERT INTO parent VALUES(1,100,'orig');
    INSERT INTO child VALUES(10,100);
    INSERT INTO parent VALUES(1,100,'new') ON CONFLICT(id) DO UPDATE SET other='new';
    SELECT id, parent_val FROM child;
}
expect {
    10|100
}

# ON DELETE RESTRICT should fail when child references the parent row
test fk-delete-restrict-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON DELETE RESTRICT);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, 1);
    DELETE FROM parent WHERE id=1;
}
expect error {
}

# ON DELETE RESTRICT should succeed when no child references the parent row
test fk-delete-restrict-ok-no-child {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON DELETE RESTRICT);
    INSERT INTO parent VALUES(1),(2);
    INSERT INTO child VALUES(10, 1);
    DELETE FROM parent WHERE id=2;
    SELECT id FROM parent;
}
expect {
    1
}

# ON UPDATE RESTRICT should fail when child references the parent key being updated
test fk-update-restrict-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON UPDATE RESTRICT);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, 1);
    UPDATE parent SET id=2 WHERE id=1;
}
expect error {
}

# ON UPDATE RESTRICT should succeed when no child references the parent key
test fk-update-restrict-ok-no-child {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON UPDATE RESTRICT);
    INSERT INTO parent VALUES(1),(2);
    INSERT INTO child VALUES(10, 1);
    UPDATE parent SET id=3 WHERE id=2;
    SELECT id FROM parent ORDER BY id;
}
expect {
    1
    3
}

# INSERT OR REPLACE with ON DELETE RESTRICT should fail
test fk-replace-restrict-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, name TEXT);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON DELETE RESTRICT);
    INSERT INTO parent VALUES(1, 'Alice');
    INSERT INTO child VALUES(10, 1);
    INSERT OR REPLACE INTO parent VALUES(1, 'Alice Updated');
}
expect error {
}

# UPSERT with ON UPDATE RESTRICT on PRIMARY KEY should fail
test fk-upsert-restrict-pk-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON UPDATE RESTRICT);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, 1);
    INSERT INTO parent VALUES(1) ON CONFLICT(id) DO UPDATE SET id=2;
}
expect error {
}

# UPSERT with ON UPDATE RESTRICT on UNIQUE column should fail
test fk-upsert-restrict-unique-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, val INTEGER UNIQUE);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_val REFERENCES parent(val) ON UPDATE RESTRICT);
    INSERT INTO parent VALUES(1, 100);
    INSERT INTO child VALUES(10, 100);
    INSERT INTO parent VALUES(1, 200) ON CONFLICT(id) DO UPDATE SET val=200;
}
expect error {
}

# UPSERT with ON UPDATE RESTRICT should succeed when FK column is not updated
test fk-upsert-restrict-ok-no-change {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY, val INTEGER UNIQUE, other TEXT);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_val REFERENCES parent(val) ON UPDATE RESTRICT);
    INSERT INTO parent VALUES(1, 100, 'orig');
    INSERT INTO child VALUES(10, 100);
    INSERT INTO parent VALUES(1, 100, 'new') ON CONFLICT(id) DO UPDATE SET other='new';
    SELECT id, parent_val FROM child;
}
expect {
    10|100
}

# RESTRICT with NULL child value should not block parent operations
test fk-restrict-null-child-ok {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id) ON DELETE RESTRICT);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, NULL);
    DELETE FROM parent WHERE id=1;
    SELECT count(*) FROM parent;
}
expect {
    0
}

# DROP parent table should fail when child rows reference it
test fk-drop-parent-with-child-references {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, 1);
    DROP TABLE parent;
}
expect error {
}

# DROP parent table should succeed when child FK values are all NULL
test fk-drop-parent-ok-when-child-fk-null {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, NULL);
    DROP TABLE parent;
    SELECT id, parent_id FROM child;
}
expect {
    10|
}

# DROP parent table should succeed when child table is empty
test fk-drop-parent-ok-when-child-empty {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    DROP TABLE parent;
    SELECT count(*) FROM child;
}
expect {
    0
}

# DROP parent table should succeed after child FK updated to NULL
test fk-drop-parent-ok-after-child-fk-set-null {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, 1);
    UPDATE child SET parent_id = NULL;
    DROP TABLE parent;
    SELECT id, parent_id FROM child;
}
expect {
    10|
}

# DROP parent table should succeed after child row deleted
test fk-drop-parent-ok-after-child-deleted {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, 1);
    DELETE FROM child WHERE id = 10;
    DROP TABLE parent;
    SELECT count(*) FROM child;
}
expect {
    0
}

# DROP parent with multiple children - some NULL, some not - should fail
test fk-drop-parent-mixed-null-references {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10, NULL);
    INSERT INTO child VALUES(11, 1);
    DROP TABLE parent;
}
expect error {
}

# DROP parent should succeed when child has orphaned FK value
test fk-drop-parent-ok-with-orphaned-fk {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1), (2);
    PRAGMA foreign_keys=OFF;
    INSERT INTO child VALUES(10, 999);
    PRAGMA foreign_keys=ON;
    DROP TABLE parent;
    SELECT id, parent_id FROM child;
}
expect {
    10|999
}

# DROP parent should succeed with multiple orphaned FK values
test fk-drop-parent-ok-with-multiple-orphaned-fks {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1), (2);
    PRAGMA foreign_keys=OFF;
    INSERT INTO child VALUES(10, 100);
    INSERT INTO child VALUES(11, 200);
    INSERT INTO child VALUES(12, 300);
    PRAGMA foreign_keys=ON;
    DROP TABLE parent;
    SELECT id, parent_id FROM child ORDER BY id;
}
expect {
    10|100
    11|200
    12|300
}

# DROP parent should succeed with mixed orphaned and NULL FK values
test fk-drop-parent-ok-with-orphaned-and-null {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1), (2);
    INSERT INTO child VALUES(10, NULL);
    PRAGMA foreign_keys=OFF;
    INSERT INTO child VALUES(11, 999);
    PRAGMA foreign_keys=ON;
    DROP TABLE parent;
    SELECT id, parent_id FROM child ORDER BY id;
}
expect {
    10|
    11|999
}

# DROP parent should FAIL with mixed orphaned and valid FK references
test fk-drop-parent-fail-with-orphaned-and-valid {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id REFERENCES parent(id));
    INSERT INTO parent VALUES(1), (2);
    PRAGMA foreign_keys=OFF;
    INSERT INTO child VALUES(10, 999);
    PRAGMA foreign_keys=ON;
    INSERT INTO child VALUES(11, 1);
    DROP TABLE parent;
}
expect error {
}

# DROP parent should succeed with composite FK orphaned values
test fk-drop-parent-ok-composite-orphaned {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a INTEGER, b INTEGER, PRIMARY KEY(a, b));
    CREATE TABLE child(id INTEGER PRIMARY KEY, pa INTEGER, pb INTEGER, FOREIGN KEY(pa, pb) REFERENCES parent(a, b));
    INSERT INTO parent VALUES(1, 2), (3, 4);
    PRAGMA foreign_keys=OFF;
    INSERT INTO child VALUES(10, 1, 999);
    INSERT INTO child VALUES(11, 999, 2);
    PRAGMA foreign_keys=ON;
    DROP TABLE parent;
    SELECT id, pa, pb FROM child ORDER BY id;
}
expect {
    10|1|999
    11|999|2
}

# DROP parent should FAIL with composite FK that matches
test fk-drop-parent-fail-composite-valid {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a INTEGER, b INTEGER, PRIMARY KEY(a, b));
    CREATE TABLE child(id INTEGER PRIMARY KEY, pa INTEGER, pb INTEGER, FOREIGN KEY(pa, pb) REFERENCES parent(a, b));
    INSERT INTO parent VALUES(1, 2), (3, 4);
    INSERT INTO child VALUES(10, 1, 2);
    DROP TABLE parent;
}
expect error {
}

# DROP parent with ON DELETE CASCADE should delete child rows
test fk-drop-parent-cascade-deletes-children {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1),(2),(3);
    INSERT INTO child VALUES(10,1),(11,2),(12,3);
    DROP TABLE parent;
    SELECT * FROM child ORDER BY id;
}
expect {
}

# DROP parent with ON DELETE CASCADE - multiple children per parent
test fk-drop-parent-cascade-multi-children {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1),(2);
    INSERT INTO child VALUES(10,1),(11,1),(12,1),(20,2),(21,2);
    DROP TABLE parent;
    SELECT count(*) FROM child;
}
expect {
    0
}

# DROP parent with ON DELETE CASCADE - child with NULL FK preserved
test fk-drop-parent-cascade-null-preserved {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1),(2);
    INSERT INTO child VALUES(10,1),(11,NULL),(12,2);
    DROP TABLE parent;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    11|
}

# DROP parent with ON DELETE SET NULL should set child FK to NULL
test fk-drop-parent-setnull-sets-children {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE SET NULL);
    INSERT INTO parent VALUES(1),(2),(3);
    INSERT INTO child VALUES(10,1),(11,2),(12,3);
    DROP TABLE parent;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    10|
    11|
    12|
}

# DROP parent with ON DELETE SET NULL - multiple children per parent
test fk-drop-parent-setnull-multi-children {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE SET NULL);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10,1),(11,1),(12,1);
    DROP TABLE parent;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    10|
    11|
    12|
}

# DROP parent with ON DELETE SET NULL - already NULL values unchanged
test fk-drop-parent-setnull-null-unchanged {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE SET NULL);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10,1),(11,NULL);
    DROP TABLE parent;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    10|
    11|
}

# DROP parent with ON DELETE SET DEFAULT (default is NULL) should work like SET NULL
test fk-drop-parent-setdefault-null-default {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid INTEGER DEFAULT NULL REFERENCES parent(id) ON DELETE SET DEFAULT);
    INSERT INTO parent VALUES(1),(2);
    INSERT INTO child VALUES(10,1),(11,2);
    DROP TABLE parent;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    10|
    11|
}

# DROP parent with ON DELETE SET DEFAULT (non-null default) should fail if default doesn't exist
# This matches SQLite behavior - SET DEFAULT sets to default value, which then fails FK check
test fk-drop-parent-setdefault-nonexistent-default {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid INTEGER DEFAULT 999 REFERENCES parent(id) ON DELETE SET DEFAULT);
    INSERT INTO parent VALUES(1);
    INSERT INTO child VALUES(10,1);
    DROP TABLE parent;
}
expect error {
}

# DROP parent with ON DELETE CASCADE - composite FK
test fk-drop-parent-cascade-composite-fk {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a INTEGER, b INTEGER, PRIMARY KEY(a, b));
    CREATE TABLE child(id INTEGER PRIMARY KEY, pa INTEGER, pb INTEGER,
        FOREIGN KEY(pa, pb) REFERENCES parent(a, b) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1,2),(3,4);
    INSERT INTO child VALUES(10,1,2),(11,3,4);
    DROP TABLE parent;
    SELECT * FROM child;
}
expect {
}

# DROP parent with ON DELETE SET NULL - composite FK
test fk-drop-parent-setnull-composite-fk {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(a INTEGER, b INTEGER, PRIMARY KEY(a, b));
    CREATE TABLE child(id INTEGER PRIMARY KEY, pa INTEGER, pb INTEGER,
        FOREIGN KEY(pa, pb) REFERENCES parent(a, b) ON DELETE SET NULL);
    INSERT INTO parent VALUES(1,2),(3,4);
    INSERT INTO child VALUES(10,1,2),(11,3,4);
    DROP TABLE parent;
    SELECT id, pa, pb FROM child ORDER BY id;
}
expect {
    10||
    11||
}

# DROP parent with mixed FK actions - CASCADE and SET NULL on different children
test fk-drop-parent-mixed-cascade-setnull {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child_cascade(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    CREATE TABLE child_setnull(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE SET NULL);
    INSERT INTO parent VALUES(1),(2);
    INSERT INTO child_cascade VALUES(10,1),(11,2);
    INSERT INTO child_setnull VALUES(20,1),(21,2);
    DROP TABLE parent;
    SELECT 'cascade', count(*) FROM child_cascade
    UNION ALL
    SELECT 'setnull', count(*) FROM child_setnull;
}
expect {
    cascade|0
    setnull|2
}

# DROP parent with mixed actions - some RESTRICT (should fail)
test fk-drop-parent-mixed-with-restrict {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child_cascade(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    CREATE TABLE child_restrict(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE RESTRICT);
    INSERT INTO parent VALUES(1);
    INSERT INTO child_cascade VALUES(10,1);
    INSERT INTO child_restrict VALUES(20,1);
    DROP TABLE parent;
}
expect error {
}

# DROP parent with recursive CASCADE (A->B->C)
test fk-drop-parent-cascade-recursive {
    PRAGMA foreign_keys=ON;
    CREATE TABLE a(id INTEGER PRIMARY KEY);
    CREATE TABLE b(id INTEGER PRIMARY KEY, aid REFERENCES a(id) ON DELETE CASCADE);
    CREATE TABLE c(id INTEGER PRIMARY KEY, bid REFERENCES b(id) ON DELETE CASCADE);
    INSERT INTO a VALUES(1);
    INSERT INTO b VALUES(10,1);
    INSERT INTO c VALUES(100,10);
    DROP TABLE a;
    SELECT 'b', count(*) FROM b UNION ALL SELECT 'c', count(*) FROM c;
}
expect {
    b|0
    c|0
}

# DROP parent with orphaned FK values and CASCADE - orphaned should be ignored
test fk-drop-parent-cascade-with-orphaned {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, pid REFERENCES parent(id) ON DELETE CASCADE);
    INSERT INTO parent VALUES(1),(2);
    PRAGMA foreign_keys=OFF;
    INSERT INTO child VALUES(10,999);
    PRAGMA foreign_keys=ON;
    INSERT INTO child VALUES(11,1);
    DROP TABLE parent;
    SELECT id, pid FROM child ORDER BY id;
}
expect {
    10|999
}

# DROP COLUMN on child FK column should fail (FK column cannot be dropped)
test fk-drop-column-child-fk-fails {
    PRAGMA foreign_keys=OFF;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(fk INTEGER, other TEXT, FOREIGN KEY(fk) REFERENCES parent(id));
    ALTER TABLE child DROP COLUMN fk;
}
expect error {
}

# DROP COLUMN on child FK column should also fail when FK is enabled
test fk-drop-column-child-fk-enabled-fails {
    PRAGMA foreign_keys=ON;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(fk INTEGER, other TEXT, FOREIGN KEY(fk) REFERENCES parent(id));
    ALTER TABLE child DROP COLUMN fk;
}
expect error {
}

# DROP COLUMN on child FK column should fail even with orphaned FK (parent dropped)
test fk-drop-column-orphaned-fk-fails {
    PRAGMA foreign_keys=OFF;
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(fk INTEGER, other TEXT, FOREIGN KEY(fk) REFERENCES parent(id));
    DROP TABLE parent;
    ALTER TABLE child DROP COLUMN fk;
}
expect error {
}

# DROP COLUMN on composite FK column should fail
test fk-drop-column-composite-fk-fails {
    PRAGMA foreign_keys=OFF;
    CREATE TABLE parent(a INTEGER, b INTEGER, PRIMARY KEY(a, b));
    CREATE TABLE child(fa INTEGER, fb INTEGER, other TEXT,
        FOREIGN KEY(fa, fb) REFERENCES parent(a, b));
    ALTER TABLE child DROP COLUMN fa;
}
expect error {
}
