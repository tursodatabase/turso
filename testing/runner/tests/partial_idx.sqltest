@database :memory:
@skip-file-if mvcc "partial indexes not fully supported in MVCC mode"

test partial-index-unique-basic {
    CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT, status TEXT);
    CREATE UNIQUE INDEX idx_active_email ON users(email) WHERE status = 'active';
    INSERT INTO users VALUES (1, 'user@test.com', 'active');
    INSERT INTO users VALUES (2, 'user@test.com', 'inactive');
    INSERT INTO users VALUES (3, 'user@test.com', 'deleted');
    SELECT id, email, status FROM users ORDER BY id;
}
expect {
    1|user@test.com|active
    2|user@test.com|inactive
    3|user@test.com|deleted
}

test partial-index-unique-violation {
    CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT, status TEXT);
    CREATE UNIQUE INDEX idx_active_email ON users(email) WHERE status = 'active';
    INSERT INTO users VALUES (1, 'user@test.com', 'active');
    INSERT INTO users VALUES (2, 'user@test.com', 'inactive');
    INSERT INTO users VALUES (3, 'user@test.com', 'deleted');
    INSERT INTO users VALUES (4, 'user@test.com', 'active');
}
expect error {
    UNIQUE constraint failed: users.email
}

test partial-index-expression-where {
    CREATE TABLE products (id INTEGER PRIMARY KEY, sku TEXT, price INTEGER);
    CREATE UNIQUE INDEX idx_expensive ON products(sku) WHERE price > 100;
    INSERT INTO products VALUES (1, 'ABC123', 50);
    INSERT INTO products VALUES (2, 'ABC123', 150);
    INSERT INTO products VALUES (3, 'XYZ789', 200);
    INSERT INTO products VALUES (4, 'ABC123', 75);
    SELECT id, sku, price FROM products ORDER BY id;
}
expect {
    1|ABC123|50
    2|ABC123|150
    3|XYZ789|200
    4|ABC123|75
}

test partial-index-expensive-violation {
    CREATE TABLE products (id INTEGER PRIMARY KEY, sku TEXT, price INTEGER);
    CREATE UNIQUE INDEX idx_expensive ON products(sku) WHERE price > 100;
    INSERT INTO products VALUES (1, 'ABC123', 50);
    INSERT INTO products VALUES (2, 'ABC123', 150);
    INSERT INTO products VALUES (3, 'XYZ789', 200);
    INSERT INTO products VALUES (4, 'ABC123', 75);
    INSERT INTO products VALUES (5, 'ABC123', 250);
}
expect error {
    UNIQUE constraint failed: products.sku
}

test partial-index-expensive-violation-update {
    CREATE TABLE products (id INTEGER PRIMARY KEY, sku TEXT, price INTEGER);
    CREATE UNIQUE INDEX idx_expensive ON products(sku) WHERE price > 100;
    INSERT INTO products VALUES (1, 'ABC123', 50);
    INSERT INTO products VALUES (2, 'ABC123', 150);
    INSERT INTO products VALUES (3, 'XYZ789', 200);
    INSERT INTO products VALUES (4, 'ABC123', 75);
    UPDATE products SET price = 300 WHERE id = 1;
}
expect error {
    UNIQUE constraint failed: products.sku
}

test partial-index-null-where {
    CREATE TABLE items (id INTEGER PRIMARY KEY, code TEXT, category TEXT);
    CREATE UNIQUE INDEX idx_categorized ON items(code) WHERE category IS NOT NULL;
    INSERT INTO items VALUES (1, 'ITEM1', 'electronics');
    INSERT INTO items VALUES (2, 'ITEM1', NULL);
    INSERT INTO items VALUES (3, 'ITEM1', NULL);
    INSERT INTO items VALUES (4, 'ITEM2', 'books');
    SELECT id, code, category FROM items ORDER BY id;
}
expect {
    1|ITEM1|electronics
    2|ITEM1|
    3|ITEM1|
    4|ITEM2|books
}

test partial-index-function-where {
    CREATE TABLE docs (id INTEGER PRIMARY KEY, title TEXT);
    CREATE UNIQUE INDEX idx_lower_title ON docs(title) WHERE LOWER(title) = title;
    INSERT INTO docs VALUES (1, 'lowercase');
    INSERT INTO docs VALUES (2, 'UPPERCASE');
    INSERT INTO docs VALUES (3, 'lowercase');
}
expect error {
    UNIQUE constraint failed: docs.title
}

test partial-index-multiple {
    CREATE TABLE tasks (id INTEGER PRIMARY KEY, name TEXT, priority INTEGER, status TEXT);
    CREATE UNIQUE INDEX idx_urgent ON tasks(name) WHERE priority = 1;
    CREATE UNIQUE INDEX idx_completed ON tasks(name) WHERE status = 'done';
    INSERT INTO tasks VALUES (1, 'task1', 1, 'open');
    INSERT INTO tasks VALUES (2, 'task1', 2, 'open');
    INSERT INTO tasks VALUES (3, 'task1', 3, 'done');
    INSERT INTO tasks VALUES (4, 'task2', 1, 'done');
    SELECT id, name, priority, status FROM tasks ORDER BY id;
}
expect {
    1|task1|1|open
    2|task1|2|open
    3|task1|3|done
    4|task2|1|done
}

test partial-index-multiple-violation-priority {
    CREATE TABLE tasks (id INTEGER PRIMARY KEY, name TEXT, priority INTEGER, status TEXT);
    CREATE UNIQUE INDEX idx_urgent ON tasks(name) WHERE priority = 1;
    CREATE UNIQUE INDEX idx_completed ON tasks(name) WHERE status = 'done';
    INSERT INTO tasks VALUES (1, 'task1', 1, 'open');
    INSERT INTO tasks VALUES (2, 'task1', 2, 'open');
    INSERT INTO tasks VALUES (3, 'task1', 3, 'done');
    INSERT INTO tasks VALUES (4, 'task2', 1, 'done');
    INSERT INTO tasks VALUES (5, 'task1', 1, 'pending');
}
expect error {
    UNIQUE constraint failed: tasks.name
}

test partial-index-multiple-violation-status {
    CREATE TABLE tasks (id INTEGER PRIMARY KEY, name TEXT, priority INTEGER, status TEXT);
    CREATE UNIQUE INDEX idx_urgent ON tasks(name) WHERE priority = 1;
    CREATE UNIQUE INDEX idx_completed ON tasks(name) WHERE status = 'done';
    INSERT INTO tasks VALUES (1, 'task1', 1, 'open');
    INSERT INTO tasks VALUES (2, 'task1', 2, 'open');
    INSERT INTO tasks VALUES (3, 'task1', 3, 'done');
    INSERT INTO tasks VALUES (4, 'task2', 1, 'done');
    INSERT INTO tasks VALUES (6, 'task1', 2, 'done');
}
expect error {
    UNIQUE constraint failed: tasks.name
}

test partial-index-update-rowid {
    CREATE TABLE rowid_test (id INTEGER PRIMARY KEY, val TEXT, flag INTEGER);
    CREATE UNIQUE INDEX idx_flagged ON rowid_test(val) WHERE flag = 1;
    INSERT INTO rowid_test VALUES (1, 'test', 1);
    INSERT INTO rowid_test VALUES (2, 'test', 0);
    UPDATE rowid_test SET id = 10 WHERE id = 1;
    SELECT id, val, flag FROM rowid_test ORDER BY id;
}
expect {
    2|test|0
    10|test|1
}

test partial-index-update-complex {
    CREATE TABLE complex (id INTEGER PRIMARY KEY, a TEXT, b INTEGER, c TEXT);
    CREATE UNIQUE INDEX idx_complex ON complex(a) WHERE b > 10 AND c = 'active';
    INSERT INTO complex VALUES (1, 'dup', 5, 'active');
    INSERT INTO complex VALUES (2, 'dup', 15, 'inactive');
    INSERT INTO complex VALUES (3, 'dup', 15, 'active');
    INSERT INTO complex VALUES (4, 'dup', 20, 'active');
}
expect error {
    UNIQUE constraint failed: complex.a
}

test partial-index-delete {
    CREATE TABLE products (id INTEGER PRIMARY KEY, sku TEXT, price INTEGER);
    CREATE UNIQUE INDEX idx_expensive ON products(sku) WHERE price > 100;
    INSERT INTO products VALUES (1, 'ABC123', 50);
    INSERT INTO products VALUES (2, 'ABC123', 150);
    INSERT INTO products VALUES (3, 'XYZ789', 200);
    INSERT INTO products VALUES (4, 'ABC123', 75);
    DELETE FROM products WHERE price > 100;
    INSERT INTO products VALUES (5, 'ABC123', 500);
    INSERT INTO products VALUES (6, 'XYZ789', 600);
    SELECT id, sku, price FROM products WHERE price > 100 ORDER BY id;
}
expect {
    5|ABC123|500
    6|XYZ789|600
}

test partial-index-delete-function-where {
    CREATE TABLE func_del (id INTEGER PRIMARY KEY, name TEXT);
    CREATE UNIQUE INDEX idx_lower ON func_del(name) WHERE LOWER(name) = name;
    INSERT INTO func_del VALUES (1, 'lowercase');
    INSERT INTO func_del VALUES (2, 'UPPERCASE');
    INSERT INTO func_del VALUES (3, 'MixedCase');
    DELETE FROM func_del WHERE LOWER(name) = name;
    INSERT INTO func_del VALUES (4, 'lowercase');
    INSERT INTO func_del VALUES (5, 'another');
    SELECT id, name FROM func_del ORDER BY id;
}
expect {
    2|UPPERCASE
    3|MixedCase
    4|lowercase
    5|another
}

test partial-index-delete-all {
    CREATE TABLE del_all (id INTEGER PRIMARY KEY, val TEXT, flag INTEGER);
    CREATE UNIQUE INDEX idx_all ON del_all(val) WHERE flag = 1;
    INSERT INTO del_all VALUES (1, 'test', 1), (2, 'test', 0), (3, 'other', 1);
    DELETE FROM del_all;
    INSERT INTO del_all VALUES (4, 'test', 1);
    INSERT INTO del_all VALUES (5, 'test', 1);
}
expect error {
    UNIQUE constraint failed: del_all.val
}

test partial-index-delete-cascade-scenario {
    CREATE TABLE parent_del (id INTEGER PRIMARY KEY, status TEXT);
    CREATE TABLE child_del (id INTEGER PRIMARY KEY, parent_id INTEGER, name TEXT, active INTEGER);
    CREATE UNIQUE INDEX idx_active_child ON child_del(name) WHERE active = 1;
    INSERT INTO parent_del VALUES (1, 'active'), (2, 'inactive');
    INSERT INTO child_del VALUES (1, 1, 'child1', 1);
    INSERT INTO child_del VALUES (2, 1, 'child2', 1);
    INSERT INTO child_del VALUES (3, 2, 'child1', 0);
    DELETE FROM child_del WHERE parent_id = 1;
    INSERT INTO child_del VALUES (4, 2, 'child1', 1);
    INSERT INTO child_del VALUES (5, 2, 'child2', 1);
    SELECT COUNT(*) FROM child_del WHERE active = 1;
}
expect {
    2
}

test partial-index-delete-null-where {
    CREATE TABLE null_del (id INTEGER PRIMARY KEY, code TEXT, category TEXT);
    CREATE UNIQUE INDEX idx_with_category ON null_del(code) WHERE category IS NOT NULL;
    INSERT INTO null_del VALUES (1, 'CODE1', 'cat1');
    INSERT INTO null_del VALUES (2, 'CODE1', NULL);
    INSERT INTO null_del VALUES (3, 'CODE2', 'cat2');
    INSERT INTO null_del VALUES (4, 'CODE1', NULL);
    DELETE FROM null_del WHERE code = 'CODE1' AND category IS NOT NULL;
    INSERT INTO null_del VALUES (5, 'CODE1', 'cat3');
    SELECT id, code, category FROM null_del WHERE code = 'CODE1' ORDER BY id;
}
expect {
    2|CODE1|
    4|CODE1|
    5|CODE1|cat3
}

test partial-index-delete-complex-where {
    CREATE TABLE complex_del (id INTEGER PRIMARY KEY, a INTEGER, b INTEGER, c TEXT);
    CREATE UNIQUE INDEX idx_complex ON complex_del(c) WHERE a > 10 AND b < 20;
    INSERT INTO complex_del VALUES (1, 15, 10, 'dup');
    INSERT INTO complex_del VALUES (2, 5, 15, 'dup');
    INSERT INTO complex_del VALUES (3, 15, 25, 'dup');
    INSERT INTO complex_del VALUES (4, 20, 10, 'unique');
    DELETE FROM complex_del WHERE a > 10 AND b < 20;
    INSERT INTO complex_del VALUES (5, 12, 18, 'dup');
    SELECT COUNT(*) FROM complex_del WHERE c = 'dup';
}
expect {
    3
}

test partial-index-update-enter-conflict-1 {
    CREATE TABLE products (id INTEGER PRIMARY KEY, sku TEXT, price INTEGER);
    CREATE UNIQUE INDEX idx_expensive ON products(sku) WHERE price > 100;
    INSERT INTO products VALUES (1, 'ABC123', 50);
    INSERT INTO products VALUES (2, 'ABC123', 150);
    UPDATE products SET price = 200 WHERE id = 1;
}
expect error {
    UNIQUE constraint failed: products.sku
}

test partial-index-update-change-key-conflict {
    CREATE TABLE products (id INTEGER PRIMARY KEY, sku TEXT, price INTEGER);
    CREATE UNIQUE INDEX idx_expensive ON products(sku) WHERE price > 100;
    INSERT INTO products VALUES (1, 'ABC123', 150);
    INSERT INTO products VALUES (2, 'XYZ789', 200);
    UPDATE products SET sku = 'XYZ789' WHERE id = 1;
}
expect error {
    UNIQUE constraint failed: products.sku
}

test partial-index-update-exit-then-reenter {
    CREATE TABLE products (id INTEGER PRIMARY KEY, sku TEXT, price INTEGER);
    CREATE UNIQUE INDEX idx_expensive ON products(sku) WHERE price > 100;
    INSERT INTO products VALUES (1, 'ABC123', 150);
    UPDATE products SET price = 50 WHERE id = 1;
    INSERT INTO products VALUES (2, 'ABC123', 200);
    UPDATE products SET price = 300 WHERE id = 1;
}
expect error {
    UNIQUE constraint failed: products.sku
}

test partial-index-update-multirow-conflict {
    CREATE TABLE products (id INTEGER PRIMARY KEY, sku TEXT, price INTEGER);
    CREATE UNIQUE INDEX idx_expensive ON products(sku) WHERE price > 100;
    INSERT INTO products VALUES (1, 'ABC123', 50);
    INSERT INTO products VALUES (2, 'ABC123', 150);
    INSERT INTO products VALUES (3, 'ABC123', 75);
    UPDATE products SET price = 150 WHERE sku = 'ABC123';
}
expect error {
    UNIQUE constraint failed: products.sku
}

test partial-index-update-unrelated-column {
    CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT, status TEXT, note TEXT);
    CREATE UNIQUE INDEX idx_active_email ON users(email) WHERE status = 'active';
    INSERT INTO users VALUES (1, 'u@test.com', 'active',  'n1');
    INSERT INTO users VALUES (2, 'u@test.com', 'inactive','n2');
    UPDATE users SET note = 'changed' WHERE id = 2;
    SELECT id,email,status,note FROM users ORDER BY id;
}
expect {
    1|u@test.com|active|n1
    2|u@test.com|inactive|changed
}

test partial-index-update-null-enters-conflict {
    CREATE TABLE items (id INTEGER PRIMARY KEY, code TEXT, category TEXT);
    CREATE UNIQUE INDEX idx_categorized ON items(code) WHERE category IS NOT NULL;
    INSERT INTO items VALUES (1,'CODE1','electronics');
    INSERT INTO items VALUES (2,'CODE1',NULL);
    UPDATE items SET category = 'x' WHERE id = 2;
}
expect error {
    UNIQUE constraint failed: items.code
}

test partial-index-update-function-enters {
    CREATE TABLE docs (id INTEGER PRIMARY KEY, title TEXT);
    CREATE UNIQUE INDEX idx_lower_title ON docs(title) WHERE LOWER(title) = title;
    INSERT INTO docs VALUES (1, 'lowercase');
    INSERT INTO docs VALUES (2, 'UPPERCASE');
    UPDATE docs SET title = 'lowercase' WHERE id = 2;
}
expect error {
    UNIQUE constraint failed: docs.title
}

test partial-index-update-multicol-enter-conflict {
    CREATE TABLE inv (id INTEGER PRIMARY KEY, sku TEXT, region TEXT, price INT);
    CREATE UNIQUE INDEX idx_sr ON inv(sku,region) WHERE price > 100;
    INSERT INTO inv VALUES (1,'A','US', 50);
    INSERT INTO inv VALUES (2,'A','US',150);
    INSERT INTO inv VALUES (3,'A','EU',150);
    UPDATE inv SET price = 200 WHERE id = 1;
}
expect error {
    UNIQUE constraint failed: inv.sku, inv.region
}

test partial-index-update-multicol-change-second {
    CREATE TABLE inv2 (id INTEGER PRIMARY KEY, sku TEXT, region TEXT, price INT);
    CREATE UNIQUE INDEX idx_sr2 ON inv2(sku,region) WHERE price > 100;
    INSERT INTO inv2 VALUES (1,'A','US',150);
    INSERT INTO inv2 VALUES (2,'A','EU',150);
    UPDATE inv2 SET region = 'US' WHERE id = 2;
}
expect error {
    UNIQUE constraint failed: inv2.sku, inv2.region
}

test partial-index-update-exit-change-key-reenter {
    CREATE TABLE t (id INTEGER PRIMARY KEY, a TEXT, b INT);
    CREATE UNIQUE INDEX idx_a ON t(a) WHERE b > 0;
    INSERT INTO t VALUES (1,'K', 10);
    INSERT INTO t VALUES (2,'X', 10);
    UPDATE t SET b = 0 WHERE id = 1;
    UPDATE t SET a = 'X' WHERE id = 1;
    UPDATE t SET b = 5 WHERE id = 1;
}
expect error {
    UNIQUE constraint failed: t.a
}

test partial-index-update-rowid-no-self-conflict {
    CREATE TABLE rowid_test (id INTEGER PRIMARY KEY, val TEXT, flag INT);
    CREATE UNIQUE INDEX idx_flagged ON rowid_test(val) WHERE flag = 1;
    INSERT INTO rowid_test VALUES (1,'v',1);
    UPDATE rowid_test SET id = 9 WHERE id = 1;
    SELECT id,val,flag FROM rowid_test ORDER BY id;
}
expect {
    9|v|1
}

test partial-index-update-batch-crossing {
    CREATE TABLE p (id INTEGER PRIMARY KEY, k TEXT, x INT);
    CREATE UNIQUE INDEX idx_k ON p(k) WHERE x > 0;
    INSERT INTO p VALUES (1,'A', 1);
    INSERT INTO p VALUES (2,'A', 0);
    INSERT INTO p VALUES (3,'A', 0);
    UPDATE p SET x = CASE id WHEN 1 THEN 0 ELSE 1 END;
}
expect error {
    UNIQUE constraint failed: p.k
}

test partial-index-update-stay-in-predicate-change-to-unique {
    CREATE TABLE q (id INTEGER PRIMARY KEY, k TEXT, x INT);
    CREATE UNIQUE INDEX idx_kx ON q(k) WHERE x > 0;
    INSERT INTO q VALUES (1,'A',1);
    INSERT INTO q VALUES (2,'B',1);
    UPDATE q SET k='C' WHERE id=1;
    SELECT id,k,x FROM q ORDER BY id;
}
expect {
    1|C|1
    2|B|1
}

test partial-index-update-only-predicate-col-error {
    CREATE TABLE r2 (id INTEGER PRIMARY KEY, k TEXT, x INT);
    CREATE UNIQUE INDEX idx_k ON r2(k) WHERE x > 0;
    INSERT INTO r2 VALUES (1,'A',0);
    INSERT INTO r2 VALUES (2,'A',1);
    UPDATE r2 SET x = 1 WHERE id = 1;
}
expect error {
    UNIQUE constraint failed: r2.k
}

test partial-index-multi-predicate-references {
    CREATE TABLE r2 (id INTEGER PRIMARY KEY, k TEXT, x INT);
    CREATE UNIQUE INDEX idx_k ON r2(k) WHERE x < 10 AND id > 10;
    INSERT INTO r2 (k,x) VALUES ('A',1), ('A',2), ('A',3), ('A',4), ('A',5), ('A',6), ('A',7), ('A',8), ('A', 9), ('A', 10), ('A', 10);
    INSERT INTO r2 (k,x) VALUES ('A',11);
    INSERT INTO r2 (k,x) VALUES ('A',12);
    SELECT id FROM r2 ORDER BY id DESC LIMIT 1;
}
expect {
    13
}

test partial-index-multi-predicate-references-rowid-alias {
    CREATE TABLE r2 (id INTEGER PRIMARY KEY, k TEXT, x INT);
    CREATE UNIQUE INDEX idx_k ON r2(k) WHERE x < 10 AND id > 10;
    INSERT INTO r2 (k,x) VALUES ('A',1), ('A',2), ('A',3), ('A',4), ('A',5), ('A',6), ('A',7), ('A',8), ('A', 9), ('A', 10), ('A', 10);
    INSERT INTO r2 (k,x) VALUES ('A',11);
    INSERT INTO r2 (k,x) VALUES ('A',12);
    INSERT INTO r2 (k,x) VALUES ('A', 3);
    INSERT INTO r2 (k,x) VALUES ('A', 9);
}
expect error {
    UNIQUE constraint failed: r2.k
}

test upsert-partial-donothing-basic {
    CREATE TABLE u1(id INTEGER PRIMARY KEY, email TEXT, status TEXT, note TEXT);
    CREATE UNIQUE INDEX idx_active_email ON u1(email) WHERE status='active';
    INSERT INTO u1(email,status,note)
        VALUES('a@test','active','n3')
        ON CONFLICT(email) DO NOTHING;
}
expect error {
}

test upsert-partial-doupdate-basic {
    CREATE TABLE u2(id INTEGER PRIMARY KEY, email TEXT, status TEXT, note TEXT);
    CREATE UNIQUE INDEX idx_active_email ON u2(email) WHERE status='active';
    INSERT INTO u2 VALUES (1,'a@test','active','n1');
    INSERT INTO u2(email,status,note)
        VALUES('a@test','active','nNEW')
        ON CONFLICT DO UPDATE SET note=excluded.note;
    SELECT id,email,status,note FROM u2;
}
expect {
    1|a@test|active|nNEW
}

test upsert-partial-doupdate-leave-predicate {
    CREATE TABLE u3(id INTEGER PRIMARY KEY, email TEXT, status TEXT);
    CREATE UNIQUE INDEX idx_active_email ON u3(email) WHERE status='active';
    INSERT INTO u3 VALUES (1,'a@test','active');
    INSERT INTO u3(email,status)
        VALUES('a@test','active')
        ON CONFLICT DO UPDATE SET status='inactive';
    INSERT INTO u3 VALUES (2,'a@test','active');
    SELECT id,email,status FROM u3 ORDER BY id;
}
expect {
    1|a@test|inactive
    2|a@test|active
}

test upsert-partial-doupdate-where-skip {
    CREATE TABLE u4(id INTEGER PRIMARY KEY, email TEXT, status TEXT, hits INT DEFAULT 0);
    CREATE UNIQUE INDEX idx_active_email ON u4(email) WHERE status='active';
    INSERT INTO u4 VALUES(1,'a@test','active',5);
    INSERT INTO u4(email,status)
        VALUES('a@test','active')
        ON CONFLICT DO UPDATE SET hits=hits+1 WHERE excluded.status='inactive';
    SELECT id,email,status,hits FROM u4 ORDER BY id;
}
expect {
    1|a@test|active|5
}

test upsert-partial-omitted-target-matches {
    CREATE TABLE u6(id INTEGER PRIMARY KEY, email TEXT, status TEXT, n INT);
    CREATE UNIQUE INDEX idx_active_email ON u6(email) WHERE status='active';
    INSERT INTO u6 VALUES (1,'a@test','active',0);
    INSERT INTO u6(email,status,n)
        VALUES('a@test','active',10)
        ON CONFLICT DO UPDATE SET n = excluded.n;
    SELECT id,email,status,n FROM u6;
}
expect {
    1|a@test|active|10
}

test upsert-partial-multicol-leave-predicate {
    CREATE TABLE m2(id INTEGER PRIMARY KEY, sku TEXT, region TEXT, price INT);
    CREATE UNIQUE INDEX idx_sr ON m2(sku,region) WHERE price > 100;
    INSERT INTO m2 VALUES(1,'A','US',150);
    INSERT INTO m2(sku,region,price)
        VALUES('A','US',150)
        ON CONFLICT DO UPDATE SET price=50;
    INSERT INTO m2 VALUES(2,'A','US',200);
    SELECT id,sku,region,price FROM m2 ORDER BY id;
}
expect {
    1|A|US|50
    2|A|US|200
}

test upsert-partial-func-predicate {
    CREATE TABLE d1(id INTEGER PRIMARY KEY, title TEXT, n INT DEFAULT 0);
    CREATE UNIQUE INDEX idx_lower_title ON d1(title) WHERE LOWER(title)=title;
    INSERT INTO d1 VALUES(1,'lower',0);
    INSERT INTO d1(title)
        VALUES('lower')
        ON CONFLICT DO UPDATE SET n = n+1;
    SELECT id,title,n FROM d1;
}
expect {
    1|lower|1
}

test upsert-partial-rowid-predicate {
    CREATE TABLE r1(id INTEGER PRIMARY KEY, k TEXT, x INT, hits INT DEFAULT 0);
    CREATE UNIQUE INDEX idx_k ON r1(k) WHERE x < 10 AND id > 10;
    INSERT INTO r1(k,x) VALUES('A',10),('A',10),('A',10),('A',10),('A',10),
                              ('A',10),('A',10),('A',10),('A',10),('A',10),('A',11),('A',12);
    INSERT INTO r1(k,x,hits)
        VALUES('A',5,1)
        ON CONFLICT DO UPDATE SET hits = hits + excluded.hits;
    SELECT k, SUM(hits) FROM r1 GROUP BY k;
}
expect {
    A|1
}

test upsert-partial-excluded-rewrite {
    CREATE TABLE ex1(id INTEGER PRIMARY KEY, a TEXT, b INT, c TEXT);
    CREATE UNIQUE INDEX idx_a ON ex1(a) WHERE b>0;
    INSERT INTO ex1 VALUES(1,'X',1,'old');
    INSERT INTO ex1(a,b,c)
        VALUES('X',1,'new')
        ON CONFLICT DO UPDATE SET c = excluded.c, b = excluded.b;
    SELECT id,a,b,c FROM ex1;
}
expect {
    1|X|1|new
}

test upsert-partial-stay-change-to-unique {
    CREATE TABLE s1(id INTEGER PRIMARY KEY, a TEXT, flag INT);
    CREATE UNIQUE INDEX idx_a ON s1(a) WHERE flag=1;
    INSERT INTO s1 VALUES(1,'K',1);
    INSERT INTO s1(a,flag)
        VALUES('K',1)
        ON CONFLICT DO UPDATE SET a='K2';
    SELECT id,a,flag FROM s1;
}
expect {
    1|K2|1
}

test upsert-partial-toggle-predicate {
    CREATE TABLE tgl(id INTEGER PRIMARY KEY, k TEXT, x INT);
    CREATE UNIQUE INDEX idx_k ON tgl(k) WHERE x>0;
    INSERT INTO tgl VALUES(1,'A',1);
    INSERT INTO tgl(k,x)
        VALUES('A',1)
        ON CONFLICT DO UPDATE SET x=0;
    INSERT INTO tgl VALUES(2,'A',5);
    SELECT id,k,x FROM tgl ORDER BY id;
}
expect {
    1|A|0
    2|A|5
}

test upsert-partial-target-pk-only {
    CREATE TABLE pko(id INTEGER PRIMARY KEY, k TEXT, x INT);
    CREATE UNIQUE INDEX idx_k ON pko(k) WHERE x>0;
    INSERT INTO pko VALUES(1,'A',1);
    INSERT INTO pko(id,k,x)
        VALUES(2,'A',1)
        ON CONFLICT(id) DO UPDATE SET x=99;
}
expect error {
    UNIQUE constraint failed: pko.k
}

test upsert-partial-omitted-no-conflict {
    CREATE TABLE insfree(id INTEGER PRIMARY KEY, k TEXT, x INT);
    CREATE UNIQUE INDEX idx_k ON insfree(k) WHERE x>0;
    INSERT INTO insfree VALUES(1,'A',1);
    INSERT INTO insfree(k,x)
        VALUES('A',0)
        ON CONFLICT DO NOTHING;
    SELECT COUNT(*) FROM insfree WHERE k='A';
}
expect {
    2
}

# Create a partial index with BETWEEN and verify it exists
test partial-index-between-create {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val INTEGER, data TEXT);
    CREATE INDEX idx_between ON t1(val) WHERE val BETWEEN 10 AND 20;
    SELECT name FROM sqlite_master WHERE type='index';
}
expect {
    idx_between
}

# INSERT into table with partial index containing BETWEEN
test partial-index-between-insert {
    CREATE TABLE t2(id INTEGER PRIMARY KEY, val INTEGER, data TEXT);
    CREATE INDEX idx_t2 ON t2(val) WHERE val BETWEEN 5 AND 15;
    INSERT INTO t2 VALUES(1, 3, 'below');
    INSERT INTO t2 VALUES(2, 10, 'inside');
    INSERT INTO t2 VALUES(3, 15, 'boundary');
    INSERT INTO t2 VALUES(4, 20, 'above');
    SELECT id, val FROM t2 ORDER BY id;
}
expect {
    1|3
    2|10
    3|15
    4|20
}

# UPDATE rows with partial index containing BETWEEN - moving in/out of index range
test partial-index-between-update {
    CREATE TABLE t3(id INTEGER PRIMARY KEY, val INTEGER);
    CREATE INDEX idx_t3 ON t3(val) WHERE val BETWEEN 0 AND 10;
    INSERT INTO t3 VALUES(1, 5);
    INSERT INTO t3 VALUES(2, 15);
    UPDATE t3 SET val = 20 WHERE id = 1;
    UPDATE t3 SET val = 5 WHERE id = 2;
    SELECT id, val FROM t3 ORDER BY id;
}
expect {
    1|20
    2|5
}

# DELETE rows with partial index containing BETWEEN
test partial-index-between-delete {
    CREATE TABLE t4(id INTEGER PRIMARY KEY, val INTEGER);
    CREATE INDEX idx_t4 ON t4(val) WHERE val BETWEEN 100 AND 200;
    INSERT INTO t4 VALUES(1, 50);
    INSERT INTO t4 VALUES(2, 150);
    INSERT INTO t4 VALUES(3, 250);
    DELETE FROM t4 WHERE id = 2;
    SELECT id, val FROM t4 ORDER BY id;
}
expect {
    1|50
    3|250
}

# SELECT with partial index containing BETWEEN - verify data integrity
test partial-index-between-select {
    CREATE TABLE t5(id INTEGER PRIMARY KEY, val INTEGER, name TEXT);
    CREATE INDEX idx_t5 ON t5(val) WHERE val BETWEEN 1 AND 100;
    INSERT INTO t5 VALUES(1, 0, 'zero');
    INSERT INTO t5 VALUES(2, 50, 'fifty');
    INSERT INTO t5 VALUES(3, 100, 'hundred');
    INSERT INTO t5 VALUES(4, 101, 'over');
    SELECT name FROM t5 WHERE val BETWEEN 1 AND 100 ORDER BY val;
}
expect {
    fifty
    hundred
}

# Multiple partial indexes with BETWEEN on same table
test partial-index-between-multiple {
    CREATE TABLE t6(id INTEGER PRIMARY KEY, a INTEGER, b INTEGER);
    CREATE INDEX idx_t6_a ON t6(a) WHERE a BETWEEN 0 AND 50;
    CREATE INDEX idx_t6_b ON t6(b) WHERE b BETWEEN 50 AND 100;
    INSERT INTO t6 VALUES(1, 25, 75);
    INSERT INTO t6 VALUES(2, 75, 25);
    INSERT INTO t6 VALUES(3, 25, 25);
    SELECT id, a, b FROM t6 ORDER BY id;
}
expect {
    1|25|75
    2|75|25
    3|25|25
}

# Partial index with BETWEEN on text column
test partial-index-between-text {
    CREATE TABLE t7(id INTEGER PRIMARY KEY, code TEXT);
    CREATE INDEX idx_t7 ON t7(code) WHERE code BETWEEN 'A' AND 'M';
    INSERT INTO t7 VALUES(1, 'Alpha');
    INSERT INTO t7 VALUES(2, 'Beta');
    INSERT INTO t7 VALUES(3, 'Zeta');
    SELECT id, code FROM t7 ORDER BY id;
}
expect {
    1|Alpha
    2|Beta
    3|Zeta
}

# Partial index with BETWEEN combined with other conditions
test partial-index-between-combined {
    CREATE TABLE t8(id INTEGER PRIMARY KEY, val INTEGER, active INTEGER);
    CREATE INDEX idx_t8 ON t8(val) WHERE val BETWEEN 1 AND 10 AND active = 1;
    INSERT INTO t8 VALUES(1, 5, 1);
    INSERT INTO t8 VALUES(2, 5, 0);
    INSERT INTO t8 VALUES(3, 15, 1);
    SELECT id, val, active FROM t8 ORDER BY id;
}
expect {
    1|5|1
    2|5|0
    3|15|1
}

# UNIQUE partial index with BETWEEN - should enforce uniqueness only within range
test partial-index-between-unique {
    CREATE TABLE t9(id INTEGER PRIMARY KEY, val INTEGER, code TEXT);
    CREATE UNIQUE INDEX idx_t9 ON t9(code) WHERE val BETWEEN 1 AND 10;
    INSERT INTO t9 VALUES(1, 5, 'A');
    INSERT INTO t9 VALUES(2, 15, 'A');
    INSERT INTO t9 VALUES(3, 20, 'A');
    SELECT id, val, code FROM t9 ORDER BY id;
}
expect {
    1|5|A
    2|15|A
    3|20|A
}

# UNIQUE partial index with BETWEEN - conflict within range should fail
test partial-index-between-unique-conflict {
    CREATE TABLE t10(id INTEGER PRIMARY KEY, val INTEGER, code TEXT);
    CREATE UNIQUE INDEX idx_t10 ON t10(code) WHERE val BETWEEN 1 AND 10;
    INSERT INTO t10 VALUES(1, 5, 'A');
    INSERT INTO t10 VALUES(2, 7, 'A');
}
expect error {
}

# UPSERT with partial index containing BETWEEN
test partial-index-between-upsert {
    CREATE TABLE t11(id INTEGER PRIMARY KEY, val INTEGER, data TEXT);
    CREATE UNIQUE INDEX idx_t11 ON t11(val) WHERE val BETWEEN 0 AND 100;
    INSERT INTO t11 VALUES(1, 50, 'first');
    INSERT OR REPLACE INTO t11 VALUES(2, 50, 'replaced');
    SELECT id, val, data FROM t11 ORDER BY id;
}
expect {
    2|50|replaced
}

# Bulk operations with partial index containing BETWEEN
test partial-index-between-bulk {
    CREATE TABLE t12(id INTEGER PRIMARY KEY, val INTEGER);
    CREATE INDEX idx_t12 ON t12(val) WHERE val BETWEEN -10 AND 10;
    INSERT INTO t12 VALUES(1, -15);
    INSERT INTO t12 VALUES(2, -5);
    INSERT INTO t12 VALUES(3, 0);
    INSERT INTO t12 VALUES(4, 5);
    INSERT INTO t12 VALUES(5, 15);
    DELETE FROM t12 WHERE val BETWEEN -5 AND 5;
    SELECT id, val FROM t12 ORDER BY id;
}
expect {
    1|-15
    5|15
}

# Update moving multiple rows in/out of BETWEEN range
test partial-index-between-update-multi {
    CREATE TABLE t13(id INTEGER PRIMARY KEY, val INTEGER);
    CREATE INDEX idx_t13 ON t13(val) WHERE val BETWEEN 10 AND 20;
    INSERT INTO t13 VALUES(1, 5);
    INSERT INTO t13 VALUES(2, 15);
    INSERT INTO t13 VALUES(3, 25);
    UPDATE t13 SET val = val + 10;
    SELECT id, val FROM t13 ORDER BY id;
}
expect {
    1|15
    2|25
    3|35
}

# NOT BETWEEN in partial index
test partial-index-not-between {
    CREATE TABLE t14(id INTEGER PRIMARY KEY, val INTEGER);
    CREATE INDEX idx_t14 ON t14(val) WHERE val NOT BETWEEN 10 AND 20;
    INSERT INTO t14 VALUES(1, 5);
    INSERT INTO t14 VALUES(2, 15);
    INSERT INTO t14 VALUES(3, 25);
    SELECT id, val FROM t14 ORDER BY id;
}
expect {
    1|5
    2|15
    3|25
}

# Partial index with BETWEEN and NULL handling
test partial-index-between-null {
    CREATE TABLE t15(id INTEGER PRIMARY KEY, val INTEGER);
    CREATE INDEX idx_t15 ON t15(val) WHERE val BETWEEN 1 AND 100;
    INSERT INTO t15 VALUES(1, NULL);
    INSERT INTO t15 VALUES(2, 50);
    INSERT INTO t15 VALUES(3, NULL);
    SELECT id, val FROM t15 ORDER BY id;
}
expect {
    1|
    2|50
    3|
}

# Nested BETWEEN expressions in partial index
test partial-index-between-nested {
    CREATE TABLE t16(id INTEGER PRIMARY KEY, a INTEGER, b INTEGER);
    CREATE INDEX idx_t16 ON t16(a, b) WHERE a BETWEEN 1 AND 10 AND b BETWEEN 20 AND 30;
    INSERT INTO t16 VALUES(1, 5, 25);
    INSERT INTO t16 VALUES(2, 5, 50);
    INSERT INTO t16 VALUES(3, 15, 25);
    INSERT INTO t16 VALUES(4, 15, 50);
    SELECT id, a, b FROM t16 ORDER BY id;
}
expect {
    1|5|25
    2|5|50
    3|15|25
    4|15|50
}

# Partial index with function call using qualified column reference (issue #5037)
test partial-index-qualified-column-in-function {
    CREATE TABLE t0(c0 INT, c1 INT, c2 BOOLEAN, c3 BOOLEAN, PRIMARY KEY(c0, c2));
    CREATE UNIQUE INDEX t0i0 ON t0 (c1, c2) WHERE LENGTH(t0.c0);
    INSERT INTO t0 VALUES (123, 1, 1, 0);
    INSERT INTO t0 VALUES (456, 2, 0, 1);
    SELECT c0, c1, c2, c3 FROM t0 ORDER BY c0;
}
expect {
    123|1|1|0
    456|2|0|1
}

# Partial index with doubly qualified column reference in function
test partial-index-doubly-qualified-column-in-function {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, val TEXT, flag INTEGER);
    CREATE INDEX idx_t1 ON t1(val) WHERE LENGTH(main.t1.val) > 3;
    INSERT INTO t1 VALUES (1, 'ab', 1);
    INSERT INTO t1 VALUES (2, 'abcdef', 1);
    SELECT id, val FROM t1 ORDER BY id;
}
expect {
    1|ab
    2|abcdef
}

# OR in partial index WHERE clause (issue #5429)
# The OR expression requires jump_target_when_true to be a real label
test partial-index-or-where-clause {
    CREATE TABLE t_or(x INTEGER);
    INSERT INTO t_or VALUES(0);
    CREATE INDEX i_or ON t_or(x) WHERE x > 5 OR x < -5;
    INSERT INTO t_or VALUES(10);
    INSERT INTO t_or VALUES(-10);
    INSERT INTO t_or VALUES(3);
    SELECT x FROM t_or ORDER BY x;
}
expect {
    -10
    0
    3
    10
}

# NOT BETWEEN in partial index WHERE clause (desugars to OR, issue #5429)
test partial-index-not-between-existing-rows {
    CREATE TABLE t_nb(c0 INTEGER);
    INSERT INTO t_nb VALUES(1);
    CREATE INDEX i_nb ON t_nb(c0) WHERE c0 NOT BETWEEN 0 AND 0;
    INSERT INTO t_nb VALUES(5);
    INSERT INTO t_nb VALUES(-1);
    INSERT INTO t_nb VALUES(0);
    SELECT c0 FROM t_nb ORDER BY c0;
}
expect {
    -1
    0
    1
    5
}

# OR with multiple existing rows that match different sides
test partial-index-or-multiple-existing {
    CREATE TABLE t_or2(val INTEGER);
    INSERT INTO t_or2 VALUES(-10);
    INSERT INTO t_or2 VALUES(0);
    INSERT INTO t_or2 VALUES(10);
    CREATE INDEX i_or2 ON t_or2(val) WHERE val > 5 OR val < -5;
    SELECT val FROM t_or2 ORDER BY val;
}
expect {
    -10
    0
    10
}

# OR in partial index with UNIQUE constraint
test partial-index-or-unique {
    CREATE TABLE t_oru(x INTEGER, y TEXT);
    INSERT INTO t_oru VALUES(10, 'a');
    INSERT INTO t_oru VALUES(-10, 'b');
    INSERT INTO t_oru VALUES(0, 'c');
    CREATE UNIQUE INDEX i_oru ON t_oru(y) WHERE x > 5 OR x < -5;
    INSERT INTO t_oru VALUES(20, 'a');
}
expect error {
    UNIQUE constraint failed: t_oru.y
}

# Complex OR with nested AND in partial index
test partial-index-or-and-combined {
    CREATE TABLE t_oa(a INTEGER, b INTEGER);
    INSERT INTO t_oa VALUES(1, 100);
    INSERT INTO t_oa VALUES(50, 1);
    INSERT INTO t_oa VALUES(3, 3);
    CREATE INDEX i_oa ON t_oa(a) WHERE (a > 10 AND b > 10) OR (a < 2 AND b < 2);
    INSERT INTO t_oa VALUES(50, 50);
    SELECT a, b FROM t_oa ORDER BY a;
}
expect {
    1|100
    3|3
    50|1
    50|50
}
