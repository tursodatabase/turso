@database :memory:

# ============================================================================
# INSERT RETURNING tests
# ============================================================================
# Basic column references
test insert-returning-single-column {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5) RETURNING id;
}
expect {
    1
}

test insert-returning-multiple-columns {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5) RETURNING id, name;
}
expect {
    1|test
}

test insert-returning-all-columns {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5) RETURNING *;
}
expect {
    1|test|10.5
}

# Table-qualified column references
test insert-returning-table-qualified {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING t.id, t.name;
}
expect {
    1|test
}

# Arbitrary expressions not referencing columns
test insert-returning-literal {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING 42;
}
expect {
    42
}

test insert-returning-constant-expression {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING 2 + 3 * 4;
}
expect {
    14
}

test insert-returning-string-literal {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING 'hello world';
}
expect {
    hello world
}

# Expressions referencing result columns
test insert-returning-column-arithmetic {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10) RETURNING 2 * value;
}
expect {
    20
}

test insert-returning-complex-expression {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 5, 3) RETURNING x + y * 2;
}
expect {
    11
}

test insert-returning-multiple-column-expression {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER, c INTEGER);
    INSERT INTO t VALUES (1, 2, 3, 4) RETURNING a * b + c;
}
expect {
    10
}

# Function calls
test insert-returning-function-call {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello') RETURNING upper(name);
}
expect {
    HELLO
}

test insert-returning-function-multiple-columns {
    CREATE TABLE t (id INTEGER, first TEXT, last TEXT);
    INSERT INTO t VALUES (1, 'john', 'doe') RETURNING upper(first) || ' ' || upper(last);
}
expect {
    JOHN DOE
}

test insert-returning-function-with-expression {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 5, 3) RETURNING abs(x - y);
}
expect {
    2
}

# Mixed expressions
test insert-returning-mixed-expressions {
    CREATE TABLE t (id INTEGER, name TEXT, value INTEGER);
    INSERT INTO t VALUES (1, 'test', 10) RETURNING id, upper(name), value * 3, 42;
}
expect {
    1|TEST|30|42
}

# Multiple rows
test insert-returning-multiple-rows {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'first'), (2, 'second'), (3, 'third') RETURNING id, name;
}
expect {
    1|first
    2|second
    3|third
}

test insert-returning-multiple-rows-expressions {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10), (2, 20), (3, 30) RETURNING id, value * 2;
}
expect {
    1|20
    2|40
    3|60
}

# NULL handling
test insert-returning-null-values {
    CREATE TABLE t (id INTEGER, name TEXT, value INTEGER);
    INSERT INTO t VALUES (1, NULL, NULL) RETURNING id, name, value;
}
expect {
    1||
}

test insert-returning-null-expression {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, NULL) RETURNING coalesce(name, 'default');
}
expect {
    default
}

# Rowid
test insert-returning-rowid {
    CREATE TABLE t (name TEXT);
    INSERT INTO t VALUES ('test') RETURNING rowid, name;
}
expect {
    1|test
}

test insert-returning-rowid-expression {
    CREATE TABLE t (name TEXT);
    INSERT INTO t VALUES ('test') RETURNING rowid * 2;
}
expect {
    2
}

# Auto-increment
test insert-returning-autoincrement {
    CREATE TABLE t (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT);
    INSERT INTO t (name) VALUES ('test') RETURNING id, name;
}
expect {
    1|test
}

# Complex nested expressions
test insert-returning-nested-expressions {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER, z INTEGER);
    INSERT INTO t VALUES (1, 2, 3, 4) RETURNING (x + y) * (z - 1);
}
expect {
    15
}

test insert-returning-case-expression {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5) RETURNING CASE WHEN value > 10 THEN 'high' WHEN value > 0 THEN 'low' ELSE 'zero' END;
}
expect {
    low
}

# String operations
test insert-returning-string-concat {
    CREATE TABLE t (id INTEGER, first TEXT, last TEXT);
    INSERT INTO t VALUES (1, 'John', 'Doe') RETURNING first || ' ' || last;
}
expect {
    John Doe
}

test insert-returning-substring {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello world') RETURNING substr(name, 1, 5);
}
expect {
    hello
}

# ============================================================================
# INSERT ON CONFLICT RETURNING tests
# ============================================================================
# RETURNING on INSERT path (no conflict)
test upsert-returning-insert-path {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'new')
    ON CONFLICT DO UPDATE SET name = excluded.name
    RETURNING id, name;
}
expect {
    1|new
}

# RETURNING on UPDATE path (conflict occurs)
test upsert-returning-update-path {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'old');
    INSERT INTO t VALUES (1, 'new')
    ON CONFLICT DO UPDATE SET name = excluded.name
    RETURNING id, name;
}
expect {
    1|new
}

# RETURNING on DO NOTHING (should return empty)
test upsert-returning-do-nothing {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'old');
    INSERT INTO t VALUES (1, 'ignored')
    ON CONFLICT DO NOTHING
    RETURNING id, name;
}
expect {
}

# RETURNING with table-qualified columns
test upsert-returning-table-qualified {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'old');
    INSERT INTO t VALUES (1, 'new')
    ON CONFLICT DO UPDATE SET name = excluded.name
    RETURNING t.id, t.name;
}
expect {
    1|new
}

# RETURNING with expressions on INSERT path
test upsert-returning-expression-insert {
    CREATE TABLE t (id INTEGER PRIMARY KEY, value INTEGER);
    INSERT INTO t VALUES (1, 10)
    ON CONFLICT DO UPDATE SET value = excluded.value
    RETURNING id, value * 2;
}
expect {
    1|20
}

# RETURNING with expressions on UPDATE path
test upsert-returning-expression-update {
    CREATE TABLE t (id INTEGER PRIMARY KEY, value INTEGER);
    INSERT INTO t VALUES (1, 5);
    INSERT INTO t VALUES (1, 10)
    ON CONFLICT DO UPDATE SET value = excluded.value
    RETURNING id, value * 3;
}
expect {
    1|30
}

# RETURNING with complex expressions
test upsert-returning-complex-expression {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 2, 3);
    INSERT INTO t VALUES (1, 5, 7)
    ON CONFLICT DO UPDATE SET x = excluded.x, y = excluded.y
    RETURNING id, x + y * 2;
}
expect {
    1|19
}

# RETURNING with function calls
test upsert-returning-function {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'hello');
    INSERT INTO t VALUES (1, 'world')
    ON CONFLICT DO UPDATE SET name = excluded.name
    RETURNING id, upper(name);
}
expect {
    1|WORLD
}

# RETURNING with multiple rows (mixed insert/update)
test upsert-returning-multiple-rows {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'old1'), (2, 'old2');
    INSERT INTO t VALUES (1, 'new1'), (2, 'new2'), (3, 'new3')
    ON CONFLICT DO UPDATE SET name = excluded.name
    RETURNING id, name;
}
expect {
    1|new1
    2|new2
    3|new3
}

# RETURNING with WHERE clause in DO UPDATE
test upsert-returning-where-update {
    CREATE TABLE t (id INTEGER PRIMARY KEY, value INTEGER);
    INSERT INTO t VALUES (1, 5);
    INSERT INTO t VALUES (1, 10)
    ON CONFLICT DO UPDATE SET value = excluded.value WHERE excluded.value > t.value
    RETURNING id, value;
}
expect {
    1|10
}

test upsert-returning-where-no-update {
    CREATE TABLE t (id INTEGER PRIMARY KEY, value INTEGER);
    INSERT INTO t VALUES (1, 10);
    INSERT INTO t VALUES (1, 5)
    ON CONFLICT DO UPDATE SET value = excluded.value WHERE excluded.value > t.value
    RETURNING id, value;
}
expect {
}

# RETURNING with arbitrary expressions not referencing columns
test upsert-returning-literal {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'test')
    ON CONFLICT DO UPDATE SET name = excluded.name
    RETURNING 42;
}
expect {
    42
}

# RETURNING with mixed insert/update in single statement (first one doesn't conflict, second one does)
test upsert-returning-mixed-operations {
    CREATE TABLE t (id INTEGER PRIMARY KEY, value INTEGER);
    INSERT INTO t VALUES (1, 5);
    INSERT INTO t VALUES (1, 10), (2, 20)
    ON CONFLICT DO UPDATE SET value = excluded.value + t.value
    RETURNING id, value;
}
expect {
    1|15
    2|20
}

# ============================================================================
# INSERT ... SELECT ... RETURNING tests
# ============================================================================
# Basic INSERT ... SELECT with RETURNING
test insert-select-returning-basic {
    CREATE TABLE u (a INTEGER, b INTEGER PRIMARY KEY, c TEXT);
    CREATE TABLE t (a TEXT, b INTEGER, c INTEGER PRIMARY KEY);
    INSERT INTO u VALUES (1, 2, 'test'), (2, 4, 'data'), (3, 6, 'more');
    INSERT INTO t SELECT c, b, b * 2 FROM u RETURNING *;
}
expect {
    test|2|4
    data|4|8
    more|6|12
}

# INSERT ... SELECT with WHERE clause and RETURNING
test insert-select-returning-where {
    CREATE TABLE u (a INTEGER, b INTEGER PRIMARY KEY, c TEXT);
    CREATE TABLE t (a TEXT, b INTEGER, c INTEGER PRIMARY KEY);
    INSERT INTO u SELECT value, value * 2, 'kekkers' FROM generate_series(1, 10);
    INSERT INTO t SELECT concat(c, '-lollers') as lul, b, b * 2 FROM u WHERE a > 5 RETURNING *;
}
expect {
    kekkers-lollers|12|24
    kekkers-lollers|14|28
    kekkers-lollers|16|32
    kekkers-lollers|18|36
    kekkers-lollers|20|40
}

# INSERT ... SELECT with RETURNING specific columns
test insert-select-returning-columns {
    CREATE TABLE u (a INTEGER, b INTEGER, c TEXT);
    CREATE TABLE t (a TEXT, b INTEGER, c INTEGER);
    INSERT INTO u VALUES (1, 10, 'x'), (2, 20, 'y'), (3, 30, 'z');
    INSERT INTO t SELECT c, b, a FROM u RETURNING a, c;
}
expect {
    x|1
    y|2
    z|3
}

# INSERT ... SELECT with RETURNING expressions
test insert-select-returning-expressions {
    CREATE TABLE u (a INTEGER, b INTEGER);
    CREATE TABLE t (x INTEGER, y INTEGER);
    INSERT INTO u VALUES (5, 10), (15, 20);
    INSERT INTO t SELECT a, b FROM u RETURNING x + y, x * y;
}
expect {
    15|50
    35|300
}

# INSERT ... SELECT with RETURNING and function calls
test insert-select-returning-functions {
    CREATE TABLE u (name TEXT, value INTEGER);
    CREATE TABLE t (name TEXT, value INTEGER);
    INSERT INTO u VALUES ('hello', 100), ('world', 200);
    INSERT INTO t SELECT name, value FROM u RETURNING upper(name), value / 10;
}
expect {
    HELLO|10
    WORLD|20
}

# INSERT ... SELECT with RETURNING and aggregates in source
test insert-select-returning-aggregate-source {
    CREATE TABLE u (category TEXT, amount INTEGER);
    CREATE TABLE t (category TEXT, total INTEGER);
    INSERT INTO u VALUES ('A', 10), ('A', 20), ('B', 30), ('B', 40);
    INSERT INTO t SELECT category, SUM(amount) FROM u GROUP BY category RETURNING *;
}
expect {
    A|30
    B|70
}

# INSERT ... SELECT with RETURNING literal values
test insert-select-returning-literals {
    CREATE TABLE u (id INTEGER);
    CREATE TABLE t (id INTEGER, constant INTEGER);
    INSERT INTO u VALUES (1), (2), (3);
    INSERT INTO t SELECT id, 42 FROM u RETURNING constant;
}
expect {
    42
    42
    42
}

# INSERT ... SELECT with RETURNING and ORDER BY in source
test insert-select-returning-ordered {
    CREATE TABLE u (value INTEGER);
    CREATE TABLE t (value INTEGER);
    INSERT INTO u VALUES (30), (10), (20);
    INSERT INTO t SELECT value FROM u ORDER BY value RETURNING value;
}
expect {
    10
    20
    30
}

# ============================================================================
# UPDATE RETURNING tests
# ============================================================================
# Basic column references
test update-returning-single-column {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5);
    UPDATE t SET value = 20.5 WHERE id = 1 RETURNING id;
}
expect {
    1
}

test update-returning-multiple-columns {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5);
    UPDATE t SET value = 20.5 WHERE id = 1 RETURNING id, name, value;
}
expect {
    1|test|20.5
}

test update-returning-all-columns {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5);
    UPDATE t SET value = 20.5 WHERE id = 1 RETURNING *;
}
expect {
    1|test|20.5
}

# Table-qualified column references
test update-returning-table-qualified {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'old');
    UPDATE t SET name = 'new' WHERE id = 1 RETURNING t.id, t.name;
}
expect {
    1|new
}

# Arbitrary expressions not referencing columns
test update-returning-literal {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10);
    UPDATE t SET value = 20 WHERE id = 1 RETURNING 42;
}
expect {
    42
}

test update-returning-constant-expression {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1);
    UPDATE t SET id = 2 RETURNING 2 + 3 * 4;
}
expect {
    14
}

# Expressions referencing updated columns
test update-returning-column-arithmetic {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10);
    UPDATE t SET value = 20 WHERE id = 1 RETURNING 2 * value;
}
expect {
    40
}

test update-returning-complex-expression {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 5, 3);
    UPDATE t SET x = 8 WHERE id = 1 RETURNING x + y * 2;
}
expect {
    14
}

test update-returning-multiple-column-expression {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER, c INTEGER);
    INSERT INTO t VALUES (1, 2, 3, 4);
    UPDATE t SET a = 5, b = 6 WHERE id = 1 RETURNING a * b + c;
}
expect {
    34
}

# Function calls
test update-returning-function-call {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello');
    UPDATE t SET name = 'world' WHERE id = 1 RETURNING upper(name);
}
expect {
    WORLD
}

test update-returning-function-multiple-columns {
    CREATE TABLE t (id INTEGER, first TEXT, last TEXT);
    INSERT INTO t VALUES (1, 'john', 'doe');
    UPDATE t SET first = 'jane', last = 'smith' WHERE id = 1 RETURNING upper(first) || ' ' || upper(last);
}
expect {
    JANE SMITH
}

# Mixed expressions
test update-returning-mixed-expressions {
    CREATE TABLE t (id INTEGER, name TEXT, value INTEGER);
    INSERT INTO t VALUES (1, 'test', 10);
    UPDATE t SET name = 'updated', value = 30 WHERE id = 1 RETURNING id, upper(name), value * 2, 42;
}
expect {
    1|UPDATED|60|42
}

# Multiple rows
test update-returning-multiple-rows {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'first'), (2, 'second'), (3, 'third');
    UPDATE t SET name = 'updated' RETURNING id, name;
}
expect {
    1|updated
    2|updated
    3|updated
}

test update-returning-multiple-rows-expressions {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10), (2, 20), (3, 30);
    UPDATE t SET value = value * 2 RETURNING id, value;
}
expect {
    1|20
    2|40
    3|60
}

# WHERE clause filtering
test update-returning-with-where {
    CREATE TABLE t (id INTEGER, name TEXT, active INTEGER);
    INSERT INTO t VALUES (1, 'first', 1), (2, 'second', 0), (3, 'third', 1);
    UPDATE t SET name = 'updated' WHERE active = 1 RETURNING id, name;
}
expect {
    1|updated
    3|updated
}

# Old vs new values
test update-returning-old-vs-new-values {
    CREATE TABLE t (id INTEGER, counter INTEGER);
    INSERT INTO t VALUES (1, 5);
    UPDATE t SET counter = counter + 10 WHERE id = 1 RETURNING id, counter;
}
expect {
    1|15
}

# NULL handling
test update-returning-null-values {
    CREATE TABLE t (id INTEGER, name TEXT, value INTEGER);
    INSERT INTO t VALUES (1, 'test', 10);
    UPDATE t SET name = NULL, value = NULL WHERE id = 1 RETURNING id, name, value;
}
expect {
    1||
}

test update-returning-null-expression {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test');
    UPDATE t SET name = NULL WHERE id = 1 RETURNING coalesce(name, 'default');
}
expect {
    default
}

# Rowid
test update-returning-rowid {
    CREATE TABLE t (name TEXT);
    INSERT INTO t VALUES ('test');
    UPDATE t SET name = 'updated' RETURNING rowid, name;
}
expect {
    1|updated
}

test update-returning-rowid-expression {
    CREATE TABLE t (name TEXT);
    INSERT INTO t VALUES ('test');
    UPDATE t SET name = 'updated' RETURNING rowid * 2;
}
expect {
    2
}

# Complex nested expressions
test update-returning-nested-expressions {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER, z INTEGER);
    INSERT INTO t VALUES (1, 2, 3, 4);
    UPDATE t SET x = 5, y = 6 WHERE id = 1 RETURNING (x + y) * (z - 1);
}
expect {
    33
}

test update-returning-case-expression {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5);
    UPDATE t SET value = 15 WHERE id = 1 RETURNING CASE WHEN value > 10 THEN 'high' WHEN value > 0 THEN 'low' ELSE 'zero' END;
}
expect {
    high
}

# String operations
test update-returning-string-concat {
    CREATE TABLE t (id INTEGER, first TEXT, last TEXT);
    INSERT INTO t VALUES (1, 'John', 'Doe');
    UPDATE t SET first = 'Jane', last = 'Smith' WHERE id = 1 RETURNING first || ' ' || last;
}
expect {
    Jane Smith
}

test update-returning-substring {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello world');
    UPDATE t SET name = 'goodbye world' WHERE id = 1 RETURNING substr(name, 1, 7);
}
expect {
    goodbye
}

# Row value updates
test update-returning-row-values {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test');
    UPDATE t SET (id, name) = (2, 'mordor') RETURNING id, name;
}
expect {
    2|mordor
}

# ============================================================================
# DELETE RETURNING tests
# ============================================================================
# Basic column references
test delete-returning-single-column {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5);
    DELETE FROM t WHERE id = 1 RETURNING id;
}
expect {
    1
}

test delete-returning-multiple-columns {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5);
    DELETE FROM t WHERE id = 1 RETURNING id, name;
}
expect {
    1|test
}

test delete-returning-all-columns {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5);
    DELETE FROM t WHERE id = 1 RETURNING *;
}
expect {
    1|test|10.5
}

# Table-qualified column references
test delete-returning-table-qualified {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test');
    DELETE FROM t WHERE id = 1 RETURNING t.id, t.name;
}
expect {
    1|test
}

# Arbitrary expressions not referencing columns
test delete-returning-literal {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1);
    DELETE FROM t WHERE id = 1 RETURNING 42;
}
expect {
    42
}

test delete-returning-constant-expression {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1);
    DELETE FROM t WHERE id = 1 RETURNING 2 + 3 * 4;
}
expect {
    14
}

# Expressions referencing deleted columns
test delete-returning-column-arithmetic {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10);
    DELETE FROM t WHERE id = 1 RETURNING 2 * value;
}
expect {
    20
}

test delete-returning-complex-expression {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 5, 3);
    DELETE FROM t WHERE id = 1 RETURNING x + y * 2;
}
expect {
    11
}

test delete-returning-function-call {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello');
    DELETE FROM t WHERE id = 1 RETURNING upper(name);
}
expect {
    HELLO
}

test delete-returning-mixed-expressions {
    CREATE TABLE t (id INTEGER, name TEXT, value INTEGER);
    INSERT INTO t VALUES (1, 'test', 10);
    DELETE FROM t WHERE id = 1 RETURNING id, upper(name), value * 3;
}
expect {
    1|TEST|30
}

# Multiple rows deleted
test delete-returning-multiple-rows {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'first'), (2, 'second'), (3, 'third');
    DELETE FROM t RETURNING id, name;
}
expect {
    1|first
    2|second
    3|third
}

test delete-returning-multiple-rows-expressions {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10), (2, 20), (3, 30);
    DELETE FROM t RETURNING id, value * 2;
}
expect {
    1|20
    2|40
    3|60
}

# NULL handling
test delete-returning-null-values {
    CREATE TABLE t (id INTEGER, name TEXT, value INTEGER);
    INSERT INTO t VALUES (1, NULL, NULL);
    DELETE FROM t WHERE id = 1 RETURNING id, name, value;
}
expect {
    1||
}

test delete-returning-null-expression {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, NULL);
    DELETE FROM t WHERE id = 1 RETURNING coalesce(name, 'default');
}
expect {
    default
}

# Rowid
test delete-returning-rowid {
    CREATE TABLE t (name TEXT);
    INSERT INTO t VALUES ('test');
    DELETE FROM t RETURNING rowid, name;
}
expect {
    1|test
}

test delete-returning-rowid-expression {
    CREATE TABLE t (name TEXT);
    INSERT INTO t VALUES ('test');
    DELETE FROM t RETURNING rowid * 2;
}
expect {
    2
}

# WHERE clause filtering
test delete-returning-with-where {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'a'), (2, 'b'), (3, 'c');
    DELETE FROM t WHERE id > 1 RETURNING id, name;
}
expect {
    2|b
    3|c
}

test delete-returning-no-matches {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test');
    DELETE FROM t WHERE id = 999 RETURNING *;
}
expect {
}

# Expressions with string operations
test delete-returning-string-concat {
    CREATE TABLE t (id INTEGER, first TEXT, last TEXT);
    INSERT INTO t VALUES (1, 'John', 'Doe');
    DELETE FROM t WHERE id = 1 RETURNING first || ' ' || last;
}
expect {
    John Doe
}

test delete-returning-substring {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello world');
    DELETE FROM t WHERE id = 1 RETURNING substr(name, 1, 5);
}
expect {
    hello
}

# Case expressions
test delete-returning-case-expression {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5);
    DELETE FROM t WHERE id = 1 RETURNING CASE WHEN value > 10 THEN 'high' WHEN value > 0 THEN 'low' ELSE 'zero' END;
}
expect {
    low
}

# Nested expressions
test delete-returning-nested-expressions {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER, z INTEGER);
    INSERT INTO t VALUES (1, 2, 3, 4);
    DELETE FROM t WHERE id = 1 RETURNING (x + y) * (z - 1);
}
expect {
    15
}

# ============================================================================
# DELETE RETURNING NASTY EDGE CASES
# ============================================================================
# Multiple references to same column in RETURNING
test delete-returning-multiple-column-references {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER);
    INSERT INTO t VALUES (1, 10), (2, 20), (3, 30);
    DELETE FROM t WHERE id = 2 RETURNING x, x * 2, x + x;
}
expect {
    20|40|40
}

# Column aliases in RETURNING
test delete-returning-column-aliases {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 1, 2), (2, 3, 4);
    DELETE FROM t WHERE x = 1 RETURNING x AS deleted_x, y AS deleted_y, x + y AS sum;
}
expect {
    1|2|3
}

# Complex WHERE clauses with IN
test delete-returning-where-in {
    CREATE TABLE t (id INTEGER PRIMARY KEY, val INTEGER);
    INSERT INTO t VALUES (1, 1), (2, 2), (3, 3);
    DELETE FROM t WHERE val IN (1, 3) RETURNING *;
}
expect {
    1|1
    3|3
}

# Complex WHERE clauses with BETWEEN
test delete-returning-where-between {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 1, 10), (2, 2, 20), (3, 3, 30);
    DELETE FROM t WHERE x BETWEEN 1 AND 2 RETURNING id, x, y, x + y;
}
expect {
    1|1|10|11
    2|2|20|22
}

# Complex WHERE clauses with LIKE
test delete-returning-where-like {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
    DELETE FROM t WHERE name LIKE 'B%' RETURNING *;
}
expect {
    2|Bob
}

# Complex WHERE clauses with AND/OR
test delete-returning-where-complex {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER);
    INSERT INTO t VALUES (1, 5), (2, 10), (3, 15);
    DELETE FROM t WHERE x > 5 AND x < 15 RETURNING id, x, x * x, x + x + x;
}
expect {
    2|10|100|30
}

# WHERE clause with modulo operator
test delete-returning-where-modulo {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT, val INTEGER);
    INSERT INTO t VALUES (1, 'a', 1), (2, 'b', 2), (3, 'c', 3);
    DELETE FROM t WHERE val % 2 = 0 RETURNING id, name, val, length(name), abs(val);
}
expect {
    2|b|2|1|2
}

# WHERE clause with subquery (correlated) - NOT SUPPORTED YET
# do_execsql_test_on_specific_db {:memory:} delete-returning-where-subquery {
#     CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER);
#     INSERT INTO t VALUES (1, 1), (2, 2), (3, 3);
#     DELETE FROM t WHERE x = (SELECT MAX(x) FROM t) RETURNING *;
# } {3|3}
# WHERE clause with IN subquery - NOT SUPPORTED YET
# do_execsql_test_on_specific_db {:memory:} delete-returning-where-in-subquery {
#     CREATE TABLE t (id INTEGER PRIMARY KEY, a INTEGER, b INTEGER);
#     INSERT INTO t VALUES (1, 1, 2), (2, 3, 4), (3, 5, 6);
#     DELETE FROM t WHERE a IN (SELECT a FROM t WHERE a > 3) RETURNING *;
# } {3|5|6}
# WHERE clause that matches nothing
test delete-returning-where-false {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'test');
    DELETE FROM t WHERE 1=0 RETURNING *;
}
expect {
}

# Rowid and INTEGER PRIMARY KEY together
test delete-returning-rowid-and-pk {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'a'), (2, 'b');
    DELETE FROM t RETURNING rowid, id, name;
}
expect {
    1|1|a
    2|2|b
}

# AUTOINCREMENT with RETURNING
test delete-returning-autoincrement {
    CREATE TABLE t (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT);
    INSERT INTO t VALUES (NULL, 'a'), (NULL, 'b');
    DELETE FROM t RETURNING id, name;
}
expect {
    1|a
    2|b
}

# Type functions in RETURNING
test delete-returning-typeof {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x REAL, y TEXT);
    INSERT INTO t VALUES (1, 1.5, 'test'), (2, 2.5, 'foo');
    DELETE FROM t RETURNING id, x, y, typeof(x), typeof(y);
}
expect {
    1|1.5|test|real|text
    2|2.5|foo|real|text
}

# NULL handling with coalesce
test delete-returning-null-coalesce {
    CREATE TABLE t (id INTEGER PRIMARY KEY, val INTEGER);
    INSERT INTO t VALUES (1, NULL), (2, 42), (3, NULL);
    DELETE FROM t WHERE val IS NULL RETURNING id, val, coalesce(val, 999);
}
expect {
    1||999
    3||999
}

# BLOB handling
test delete-returning-blob {
    CREATE TABLE t (id INTEGER PRIMARY KEY, val BLOB);
    INSERT INTO t VALUES (1, zeroblob(10)), (2, x'0102');
    DELETE FROM t RETURNING id, length(val), typeof(val);
}
expect {
    1|10|blob
    2|2|blob
}

# printf function in RETURNING
test delete-returning-printf {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'hello'), (2, 'world');
    DELETE FROM t WHERE name = 'hello' RETURNING printf('Deleted: %s', name);
}
expect {
    Deleted: hello
}

# Additional edge cases
test delete-returning-empty-string-null {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'hello'), (2, ''), (3, NULL);
    DELETE FROM t RETURNING id, name, length(name), name IS NULL;
}
expect {
    1|hello|5|0
    2||0|0
    3|||1
}

test delete-returning-string-concat-numbers {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 1, 2), (2, 3, 4);
    DELETE FROM t WHERE x = 1 RETURNING x, y, x + y, x * y, x || y;
}
expect {
    1|2|3|2|12
}

test delete-returning-round-precision {
    CREATE TABLE t (id INTEGER PRIMARY KEY, val REAL);
    INSERT INTO t VALUES (1, 1.23456789), (2, 9.999999);
    DELETE FROM t RETURNING id, val, round(val, 2);
}
expect {
    1|1.23456789|1.23
    2|9.999999|10.0
}
expect @js {
    1|1.23456789|1.23
    2|9.999999|10
}

test delete-returning-glob-pattern {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
    DELETE FROM t WHERE name GLOB '[BC]*' RETURNING *;
}
expect {
    2|Bob
    3|Charlie
}

test delete-returning-operator-precedence {
    CREATE TABLE t (id INTEGER PRIMARY KEY, a INTEGER, b INTEGER, c INTEGER);
    INSERT INTO t VALUES (1, 1, 2, 3), (2, 4, 5, 6);
    DELETE FROM t RETURNING a, b, c, a + b * c, (a + b) * c;
}
expect {
    1|2|3|7|9
    4|5|6|34|54
}

test delete-returning-large-numbers {
    CREATE TABLE t (id INTEGER PRIMARY KEY, val INTEGER);
    INSERT INTO t VALUES (1, 999999999), (2, -999999999), (3, 0);
    DELETE FROM t RETURNING id, val, val + 1, val * 2;
}
expect {
    1|999999999|1000000000|1999999998
    2|-999999999|-999999998|-1999999998
    3|0|1|0
}

test delete-returning-nullif-coalesce {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'test'), (2, 'test'), (3, 'other');
    DELETE FROM t WHERE name = 'test' RETURNING id, name, NULLIF(name, 'test'), COALESCE(NULLIF(name, 'test'), 'was_test');
}
expect {
    1|test||was_test
    2|test||was_test
}

test delete-returning-iif-null-handling {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 5, 10), (2, NULL, 20), (3, 15, NULL);
    DELETE FROM t RETURNING id, x, y, IIF(x IS NULL OR y IS NULL, 'has_null', x + y);
}
expect {
    1|5|10|15
    2||20|has_null
    3|15||has_null
}

test delete-returning-string-functions {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'hello'), (2, 'world');
    DELETE FROM t RETURNING id, name, upper(name), lower(name), length(name);
}
expect {
    1|hello|HELLO|hello|5
    2|world|WORLD|world|5
}

test delete-returning-replace-function {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'hello world'), (2, 'foo bar');
    DELETE FROM t RETURNING id, name, replace(name, ' ', '_') AS replaced;
}
expect {
    1|hello world|hello_world
    2|foo bar|foo_bar
}

test delete-returning-abs-sign {
    CREATE TABLE t (id INTEGER PRIMARY KEY, val INTEGER);
    INSERT INTO t VALUES (1, 42), (2, -10), (3, 0);
    DELETE FROM t RETURNING id, val, abs(val), sign(val);
}
expect {
    1|42|42|1
    2|-10|10|-1
    3|0|0|0
}

test delete-returning-coalesce-arithmetic {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 5, NULL), (2, NULL, 10), (3, NULL, NULL);
    DELETE FROM t RETURNING id, x, y, coalesce(x, 0) + coalesce(y, 0);
}
expect {
    1|5||5
    2||10|10
    3|||0
}

test delete-returning-case-expression-2 {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT, val INTEGER);
    INSERT INTO t VALUES (1, 'test', 10), (2, 'test', 20);
    DELETE FROM t WHERE val = 10 RETURNING id, name, val, CASE WHEN val > 15 THEN 'high' ELSE 'low' END;
}
expect {
    1|test|10|low
}

test delete-returning-type-cast {
    CREATE TABLE t (id INTEGER PRIMARY KEY, x REAL, y INTEGER);
    INSERT INTO t VALUES (1, 1.5, 2), (2, 3.7, 4);
    DELETE FROM t RETURNING id, x, y, round(x), cast(x AS INTEGER);
}
expect {
    1|1.5|2|2.0|1
    2|3.7|4|4.0|3
}
expect @js {
    1|1.5|2|2|1
    2|3.7|4|4|3
}

# ============================================================================
# Edge cases and complex scenarios
# ============================================================================
# RETURNING expressions that don't reference any columns
test insert-returning-no-column-reference {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING 1 + 1, 'constant', NULL;
}
expect {
    2|constant|
}

test update-returning-no-column-reference {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1);
    UPDATE t SET id = 2 RETURNING 1 + 1, 'constant', NULL;
}
expect {
    2|constant|
}

test delete-returning-no-column-reference {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1);
    DELETE FROM t WHERE id = 1 RETURNING 1 + 1, 'constant', NULL;
}
expect {
    2|constant|
}

# RETURNING with aggregate-like expressions (should work per-row)
test insert-returning-sum-expression {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER);
    INSERT INTO t VALUES (1, 2, 3) RETURNING a + b;
}
expect {
    5
}

test update-returning-sum-expression {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER);
    INSERT INTO t VALUES (1, 2, 3);
    UPDATE t SET a = 5, b = 7 WHERE id = 1 RETURNING a + b;
}
expect {
    12
}

# ============================================================================
# NASTY EDGE CASES - Things that should work but might break
# ============================================================================
# Column name same as table name - ambiguity resolution
test insert-returning-column-same-as-table-name {
    CREATE TABLE t (t INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING t.t, t.name;
}
expect {
    1|test
}

test insert-returning-column-same-as-table-name-unqualified {
    CREATE TABLE t (t INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING t, name;
}
expect {
    1|test
}

# RETURNING with rowid when INTEGER PRIMARY KEY exists - can reference both
test insert-returning-rowid-and-pk-alias {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING rowid, id, name;
}
expect {
    1|1|test
}

test update-returning-rowid-and-pk-alias {
    CREATE TABLE t (id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t VALUES (1, 'old');
    UPDATE t SET name = 'new' WHERE id = 1 RETURNING rowid, id, name;
}
expect {
    1|1|new
}

# RETURNING with expressions referencing updated columns in UPDATE
test update-returning-reference-updated-column {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 5, 10);
    UPDATE t SET x = 20 WHERE id = 1 RETURNING x, x * 2, x + y;
}
expect {
    20|40|30
}

test update-returning-reference-multiple-updated-columns {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER, c INTEGER);
    INSERT INTO t VALUES (1, 1, 2, 3);
    UPDATE t SET a = 10, b = 20 WHERE id = 1 RETURNING a, b, a + b, a * b + c;
}
expect {
    10|20|30|203
}

# RETURNING with NULLIF edge cases
test insert-returning-nullif {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5) RETURNING NULLIF(value, 5);
}
expect {
}

test insert-returning-nullif-no-match {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5) RETURNING NULLIF(value, 10);
}
expect {
    5
}

test update-returning-nullif {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5);
    UPDATE t SET value = 10 WHERE id = 1 RETURNING NULLIF(value, 5);
}
expect {
    10
}

# RETURNING with COALESCE multiple arguments
test insert-returning-coalesce-multiple {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER, c INTEGER);
    INSERT INTO t VALUES (1, NULL, NULL, 42) RETURNING COALESCE(a, b, c);
}
expect {
    42
}

test insert-returning-coalesce-all-null {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER);
    INSERT INTO t VALUES (1, NULL, NULL) RETURNING COALESCE(a, b, 'default');
}
expect {
    default
}

# RETURNING with arithmetic on NULL
test insert-returning-null-arithmetic {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, NULL, 5) RETURNING x + y, x * y, x - y;
}
expect {
    ||
}

test update-returning-null-arithmetic {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 10, 5);
    UPDATE t SET x = NULL WHERE id = 1 RETURNING x + y, x * y;
}
expect {
    |
}

# RETURNING with string functions on NULL
test insert-returning-string-func-null {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, NULL) RETURNING upper(name), length(name), substr(name, 1, 5);
}
expect {
    ||
}

test update-returning-string-func-null {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test');
    UPDATE t SET name = NULL WHERE id = 1 RETURNING upper(name), length(name);
}
expect {
    |
}

# RETURNING with CASE expressions having NULL branches
test insert-returning-case-with-null {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5) RETURNING CASE WHEN value > 10 THEN 'high' WHEN value > 0 THEN NULL ELSE 'zero' END;
}
expect {
}

test insert-returning-case-nested {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER);
    INSERT INTO t VALUES (1, 5, 10) RETURNING CASE WHEN a > b THEN a WHEN a < b THEN b ELSE NULL END;
}
expect {
    10
}

# RETURNING with type conversions
test insert-returning-type-conversion {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 42) RETURNING CAST(value AS TEXT), CAST(value AS REAL);
}
expect {
    42|42.0
}
expect @js {
    42|42
}

test update-returning-type-conversion {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 42);
    UPDATE t SET value = 100 WHERE id = 1 RETURNING CAST(value AS TEXT);
}
expect {
    100
}

# RETURNING when updating rowid directly (if supported)
test update-rowid-returning {
    CREATE TABLE t (name TEXT);
    INSERT INTO t VALUES ('test');
    UPDATE t SET rowid = 999 WHERE rowid = 1 RETURNING rowid, name;
}
expect {
    999|test
}

# RETURNING with expressions referencing columns not in result set
test insert-returning-reference-hidden-column {
    CREATE TABLE t (id INTEGER, secret INTEGER, public INTEGER);
    INSERT INTO t VALUES (1, 100, 50) RETURNING public, secret * 2;
}
expect {
    50|200
}

test update-returning-reference-hidden-column {
    CREATE TABLE t (id INTEGER, secret INTEGER, public INTEGER);
    INSERT INTO t VALUES (1, 100, 50);
    UPDATE t SET public = 75 WHERE id = 1 RETURNING public, secret + public;
}
expect {
    75|175
}

# RETURNING with duplicate column names in result (should work)
test insert-returning-duplicate-column-names {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING id, id, name, name;
}
expect {
    1|1|test|test
}

test update-returning-duplicate-column-names {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10);
    UPDATE t SET value = 20 WHERE id = 1 RETURNING value, value * 2, value;
}
expect {
    20|40|20
}

# RETURNING with expressions using column names as strings (should not work, but test anyway)
test insert-returning-column-name-as-string {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING 'id', 'name';
}
expect {
    id|name
}

# RETURNING with excluded in regular INSERT (should error)
test insert-returning-excluded-not-upsert {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING excluded.name;
}
expect error {
}

# RETURNING with expressions referencing columns that were updated to NULL
test update-returning-updated-to-null {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 42);
    UPDATE t SET value = NULL WHERE id = 1 RETURNING value, COALESCE(value, 0);
}
expect {
    |0
}

# RETURNING with expressions referencing columns that were updated from NULL
test update-returning-updated-from-null {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, NULL);
    UPDATE t SET value = 42 WHERE id = 1 RETURNING value, COALESCE(value, 0);
}
expect {
    42|42
}

# RETURNING with expressions that use backticks
test insert-returning-backtick-columns {
    CREATE TABLE t (`id` INTEGER, `name` TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING `id`, `name`;
}
expect {
    1|test
}

setup dqs_dml {
    .dbconfig dqs_dml on
}

# RETURNING with expressions that use double quotes (if DQS enabled)
@backend cli
@setup dqs_dml
test insert-returning-double-quote-columns {
    CREATE TABLE t ("id" INTEGER, "name" TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING "id", "name";
} 
expect {
    1|test
}

# RETURNING with expressions referencing columns in different cases (case sensitivity)
test insert-returning-case-insensitive {
    CREATE TABLE t (ID INTEGER, Name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING id, name, ID, Name;
}
expect {
    1|test|1|test
}

# RETURNING with expressions that reference columns that don't exist (should error)
test insert-returning-nonexistent-column {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING nonexistent;
}
expect error {
}

test update-returning-nonexistent-column {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1);
    UPDATE t SET id = 2 RETURNING nonexistent;
}
expect error {
}

# RETURNING with expressions that reference wrong table (should error)
test insert-returning-wrong-table {
    CREATE TABLE t1 (id INTEGER);
    CREATE TABLE t2 (id INTEGER);
    INSERT INTO t1 VALUES (1) RETURNING t2.id;
}
expect error {
}

# RETURNING with expressions that mix table-qualified and unqualified
test insert-returning-mixed-qualification {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test') RETURNING t.id, name, t.name, id;
}
expect {
    1|test|test|1
}

# RETURNING with expressions that reference columns updated in SET clause
test update-returning-set-clause-reference {
    CREATE TABLE t (id INTEGER, x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 5, 10);
    UPDATE t SET x = 20, y = x + 10 WHERE id = 1 RETURNING x, y;
}
expect {
    20|15
}

# RETURNING with expressions that reference columns in order of update
test update-returning-order-dependent {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER);
    INSERT INTO t VALUES (1, 1, 2);
    UPDATE t SET a = b, b = a WHERE id = 1 RETURNING a, b;
}
expect {
    2|1
}

# RETURNING with empty result set (no rows affected)
test update-returning-no-rows {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'test');
    UPDATE t SET name = 'updated' WHERE id = 999 RETURNING id, name;
}
expect {
}

# RETURNING with expressions using || operator on NULL
test insert-returning-concat-null {
    CREATE TABLE t (id INTEGER, first TEXT, last TEXT);
    INSERT INTO t VALUES (1, NULL, 'Doe') RETURNING first || ' ' || last;
}
expect {
}

test insert-returning-concat-both-null {
    CREATE TABLE t (id INTEGER, first TEXT, last TEXT);
    INSERT INTO t VALUES (1, NULL, NULL) RETURNING first || ' ' || last;
}
expect {
}

# RETURNING with expressions using IN operator
test insert-returning-in-operator {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5) RETURNING value IN (1, 2, 3, 4, 5);
}
expect {
    1
}

test insert-returning-in-operator-false {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 10) RETURNING value IN (1, 2, 3, 4, 5);
}
expect {
    0
}

# RETURNING with expressions using LIKE operator
test insert-returning-like-operator {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello world') RETURNING name LIKE 'hello%';
}
expect {
    1
}

test insert-returning-like-operator-false {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello world') RETURNING name LIKE 'goodbye%';
}
expect {
    0
}

# RETURNING with expressions using IS NULL
test insert-returning-is-null {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, NULL) RETURNING value IS NULL;
}
expect {
    1
}

test insert-returning-is-not-null {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 42) RETURNING value IS NOT NULL;
}
expect {
    1
}

# RETURNING with expressions using BETWEEN
test insert-returning-between {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5) RETURNING value BETWEEN 1 AND 10;
}
expect {
    1
}

test insert-returning-between-false {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 15) RETURNING value BETWEEN 1 AND 10;
}
expect {
    0
}

# RETURNING with expressions using GLOB (if supported)
test insert-returning-glob {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello.txt') RETURNING name GLOB '*.txt';
}
expect {
    1
}

# RETURNING with expressions that overflow (large numbers)
test insert-returning-large-number {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 9223372036854775807) RETURNING value;
}
expect {
    9223372036854775807
}

# RETURNING with expressions using ABS on negative
test insert-returning-abs-negative {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, -42) RETURNING ABS(value);
}
expect {
    42
}

# RETURNING with expressions using MAX/MIN (should work per-row, not aggregate)
test insert-returning-max-min-per-row {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER);
    INSERT INTO t VALUES (1, 5, 10) RETURNING MAX(a, b), MIN(a, b);
}
expect {
    10|5
}

# RETURNING with expressions using ROUND
test insert-returning-round {
    CREATE TABLE t (id INTEGER, value REAL);
    INSERT INTO t VALUES (1, 3.14159) RETURNING ROUND(value, 2);
}
expect {
    3.14
}

# RETURNING with expressions using LENGTH on empty string
test insert-returning-length-empty {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, '') RETURNING LENGTH(name);
}
expect {
    0
}

# RETURNING with expressions using TRIM
test insert-returning-trim {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, '  hello  ') RETURNING TRIM(name);
}
expect {
    hello
}

# RETURNING with expressions using REPLACE
test insert-returning-replace {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello world') RETURNING REPLACE(name, 'world', 'universe');
}
expect {
    hello universe
}

# RETURNING with expressions using LOWER/UPPER on mixed case
test insert-returning-lower-upper {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'HeLLo WoRLd') RETURNING LOWER(name), UPPER(name);
}
expect {
    hello world|HELLO WORLD
}

# RETURNING with expressions using SUBSTR with negative start
test insert-returning-substr-negative {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'hello') RETURNING SUBSTR(name, -3);
}
expect {
    llo
}

# RETURNING with expressions using CHAR (if supported)
test insert-returning-char {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 65) RETURNING CHAR(value);
}
expect {
    A
}

# RETURNING with expressions using UNICODE (if supported)
test insert-returning-unicode {
    CREATE TABLE t (id INTEGER, name TEXT);
    INSERT INTO t VALUES (1, 'A') RETURNING UNICODE(name);
}
expect {
    65
}

# RETURNING with expressions using DATE functions (if supported)
test insert-returning-date {
    CREATE TABLE t (id INTEGER, date_text TEXT);
    INSERT INTO t VALUES (1, '2023-01-01') RETURNING DATE(date_text);
}
expect {
    2023-01-01
}

# RETURNING with expressions using JULIANDAY (if supported)
test insert-returning-julianday {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING JULIANDAY('2023-01-01');
}
expect {
    2459945.5
}

# RETURNING with expressions using STRFTIME (if supported)
test insert-returning-strftime {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING STRFTIME('%Y-%m-%d', '2023-01-01');
}
expect {
    2023-01-01
}

# RETURNING with expressions using JSON functions (if supported)
test insert-returning-json {
    CREATE TABLE t (id INTEGER, data TEXT);
    INSERT INTO t VALUES (1, '{"key": "value"}') RETURNING JSON_EXTRACT(data, '$.key');
}
expect {
    value
}

# RETURNING with expressions using typeof
test insert-returning-typeof {
    CREATE TABLE t (id INTEGER, name TEXT, value REAL);
    INSERT INTO t VALUES (1, 'test', 10.5) RETURNING typeof(id), typeof(name), typeof(value);
}
expect {
    integer|text|real
}

# RETURNING with expressions using typeof on NULL
test insert-returning-typeof-null {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, NULL) RETURNING typeof(value);
}
expect {
    null
}

# RETURNING with expressions using printf (if supported)
test insert-returning-printf {
    CREATE TABLE t (id INTEGER, name TEXT, value INTEGER);
    INSERT INTO t VALUES (1, 'test', 42) RETURNING printf('id=%d name=%s value=%d', id, name, value);
}
expect {
    id=1 name=test value=42
}

# RETURNING with expressions using randomblob/zeroblob (if supported)
test insert-returning-zeroblob {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING LENGTH(zeroblob(100));
}
expect {
    100
}

# RETURNING with expressions using changes (if supported)
test insert-returning-changes {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING changes();
}
expect {
    0
}

# RETURNING with expressions using last_insert_rowid (if supported)
test insert-returning-last-insert-rowid {
    CREATE TABLE t (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT);
    INSERT INTO t (name) VALUES ('test') RETURNING last_insert_rowid();
}
expect {
    1
}

# RETURNING with expressions using total_changes (if supported)
test insert-returning-total-changes {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING total_changes();
}
expect {
    0
}

# RETURNING with expressions using likely/unlikely (optimization hints)
test insert-returning-likely {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5) RETURNING likely(value > 0);
}
expect {
    1
}

# RETURNING with expressions using iif (if supported)
test insert-returning-iif {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 5) RETURNING IIF(value > 0, 'positive', 'negative');
}
expect {
    positive
}

# RETURNING with expressions using json_array/json_object (if supported)
test insert-returning-json-array {
    CREATE TABLE t (id INTEGER, a INTEGER, b INTEGER);
    INSERT INTO t VALUES (1, 2, 3) RETURNING JSON_ARRAY(a, b);
}
expect {
    [2,3]
}

# RETURNING with expressions using aggregate functions (should error)
test insert-returning-aggregate {
    CREATE TABLE t (id INTEGER, value INTEGER);
    INSERT INTO t VALUES (1, 42) RETURNING SUM(value);
}
expect error {
}

test insert-returning-aggregate-count {
    CREATE TABLE t (id INTEGER);
    INSERT INTO t VALUES (1) RETURNING COUNT(*);
}
expect error {
}

