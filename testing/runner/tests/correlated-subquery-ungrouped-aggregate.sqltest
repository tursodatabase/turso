@database :memory:

# =============================================================================
# Bug: Correlated scalar subquery with COUNT(*) returns NULL instead of 0
# in ungrouped aggregate queries when no rows match the outer WHERE clause.
#
# When the outer loop produces no rows, correlated subqueries emitted inside
# the loop body never execute, leaving their result registers at NULL.
# COUNT(*) should return 0 for an empty result set, not NULL.
#
# This causes data corruption when the result is stored via INSERT...SELECT:
# NULL is persisted instead of 0 and cannot be recovered by a future patch.
#
# Related PRs (different bugs):
# - #5591: IN subquery returns wrong value (stale cursor, not missing eval)
# - #5578: stale values from coroutine columns (different root cause)
# =============================================================================

# -- Empty outer table: loop never runs, subquery should return 0 not NULL --

test correlated-count-empty-table {
    CREATE TABLE t1(a INTEGER, b INTEGER);
    CREATE TABLE t2(a INTEGER, b INTEGER);
    SELECT COUNT(*), (SELECT COUNT(*) FROM t2 WHERE t2.a = t1.a) FROM t1;
}
expect {
    0|0
}

# -- Non-empty outer table but WHERE filters all rows --

test correlated-count-no-matching-rows {
    CREATE TABLE t3(a INTEGER, b INTEGER);
    CREATE TABLE t4(a INTEGER, b INTEGER);
    INSERT INTO t3 VALUES (1, 10), (2, 20);
    INSERT INTO t4 VALUES (1, 100);
    SELECT COUNT(*), (SELECT COUNT(*) FROM t4 WHERE t4.a = t3.a) FROM t3 WHERE t3.b > 100;
}
expect {
    0|0
}

# -- Constant false condition (WHERE 0) --
# When WHERE 0 is present, the entire loop (including cursor init) is skipped
# via a Goto. The subquery result register stays at its default value (NULL).

test correlated-count-where-false {
    CREATE TABLE t5(a INTEGER, b INTEGER);
    CREATE TABLE t6(a INTEGER, b INTEGER);
    INSERT INTO t5 VALUES (1, 10);
    INSERT INTO t6 VALUES (1, 100);
    SELECT COUNT(*), (SELECT COUNT(*) FROM t6 WHERE t6.a = t5.a) FROM t5 WHERE 0;
}
expect {
    0|
}

# -- INSERT...SELECT persistence: proves data corruption --

test correlated-count-insert-select {
    CREATE TABLE t7(a INTEGER, b INTEGER);
    CREATE TABLE t8(a INTEGER, b INTEGER);
    CREATE TABLE dst(cnt INTEGER, sub_cnt INTEGER);
    INSERT INTO dst SELECT COUNT(*), (SELECT COUNT(*) FROM t8 WHERE t8.a = t7.a) FROM t7;
    SELECT cnt, typeof(cnt), sub_cnt, typeof(sub_cnt) FROM dst;
}
expect {
    0|integer|0|integer
}

# -- Positive case: verify normal operation when rows do match --

test correlated-count-with-matching-rows {
    CREATE TABLE t9(a INTEGER, b INTEGER);
    CREATE TABLE t10(a INTEGER, b INTEGER);
    INSERT INTO t9 VALUES (1, 10), (2, 20), (1, 30);
    INSERT INTO t10 VALUES (1, 100), (1, 200), (2, 300);
    SELECT COUNT(*), (SELECT COUNT(*) FROM t10 WHERE t10.a = t9.a) FROM t9;
}
expect {
    3|2
}

# -- SUM (another aggregate) inside correlated subquery --

test correlated-sum-no-matching-rows {
    CREATE TABLE t11(a INTEGER, b INTEGER);
    CREATE TABLE t12(a INTEGER, b INTEGER);
    INSERT INTO t11 VALUES (1, 10);
    INSERT INTO t12 VALUES (1, 100);
    SELECT COUNT(*), (SELECT SUM(b) FROM t12 WHERE t12.a = t11.a) FROM t11 WHERE t11.b > 100;
}
expect {
    0|
}
