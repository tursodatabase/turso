---
source: analyze.sqltest
expression: |-
  SELECT c.name, COUNT(*) as purchase_count, SUM(p.amount) as total
      FROM customers c
      JOIN purchases p ON c.id = p.customer_id
      GROUP BY c.id;
info:
  statement_type: SELECT
  tables:
  - c.id
  - customers
  - purchases
  setup_blocks:
  - join_tables
  database: ':memory:'
---
QUERY PLAN
|--SCAN customers AS c
`--SEARCH p USING INDEX ephemeral_purchases_t2

BYTECODE
addr  opcode                    p1  p2  p3  p4            p5  comment
   0          Init               0  60   0                 0  Start at 60
   1          Null               0  10  11                 0  r[10..11]=NULL
   2          Integer            0   6   0                 0  r[6]=0; clear group by abort flag
   3          Null               0   7   0                 0  r[7]=NULL; initialize group by comparison registers to NULL
   4          Gosub             16  56   0                 0  ; go to clear accumulator subroutine
   5          OpenRead           0   2   0  k(2,B,B)       0  table=customers, root=2, iDb=0
   6          OpenRead           1   3   0  k(3,B,B,B)     0  table=purchases, root=3, iDb=0
   7          Rewind             0  43   0                 0  Rewind table customers
   8            Once            18   0   0                 0  goto 18
   9            OpenAutoindex    2   0   0                 0  cursor=2
  10            Rewind           1  11   0                 0  Rewind table purchases
  11              Column         1   1  17                 0  r[17]=purchases.customer_id
  12              Column         1   2  18                 0  r[18]=purchases.amount
  13              RowId          1  19   0                 0  r[19]=purchases.rowid
  14              MakeRecord    17   3  20                 0  r[20]=mkrec(r[17..19]); for ephemeral_purchases_t2
  15              FilterAdd      2  17   1                 0  bloom_filter_add(r[17..18])
  16              IdxInsert      2  20  17                 0  key=r[20]
  17            Next             1  11   0                 0
  18            RowId            0  21   0                 0  r[21]=customers.rowid
  19            Filter           2  42  21                 1  if !bloom_filter(r[21..22]) goto 42
  20            SeekGE           2  42  21                 0  key=[21..21]
  21              IdxGT          2  42  21                 0  key=[21..21]
  22              DeferredSeek   2   1   0                 0
  23              RowId          0  23   0                 0  r[23]=customers.rowid
  24              Column         2   0  24                 0  r[24]=ephemeral_purchases_t2.customer_id
  25              Ne            23  24  41  Binary         0  if r[23]!=r[24] goto 41
  26              RowId          0  13   0                 0  r[13]=customers.rowid
  27              Column         0   1  14                 0  r[14]=customers.name
  28              Column         2   1  15                 0  r[15]=ephemeral_purchases_t2.amount
  29              RealAffinity  15   0   0                 0
  30              Compare        7  13   1  k(1, Binary)   0  r[7..7]==r[13..13]
  31              Jump          32  36  32                 0  ; start new group if comparison is not equal
  32              Gosub          4  47   0                 0  ; check if ended group had data, and output if so
  33              Move          13   7   1                 0  r[7..7]=r[13..13]
  34              IfPos          6  59   0                 0  r[6]>0 -> r[6]-=0, goto 59; check abort flag
  35              Gosub         16  56   0                 0  ; goto clear accumulator subroutine
  36              AggStep        0  25  10  count          0  accum=r[10] step(r[25])
  37              AggStep        0  15  11  sum            0  accum=r[11] step(r[15])
  38              If             5  40   0                 0  if r[5] goto 40; don't emit group columns if continuing existing group
  39              Column         0   1   8                 0  r[8]=customers.name
  40              Integer        1   5   0                 0  r[5]=1; indicate data in accumulator
  41            Next             2  21   0                 0
  42          Next               0   8   0                 0
  43          Gosub              4  47   0                 0  ; emit row for final group
  44          Goto               0  59   0                 0  ; group by finished
  45          Integer            1   6   0                 0  r[6]=1
  46        Return               4   0   0                 0
  47        IfPos                5  49   0                 0  r[5]>0 -> r[5]-=0, goto 49; output group by row subroutine start
  48      Return                 4   0   0                 0
  49      AggFinal               0  10   0  count          0  accum=r[10]
  50      AggFinal               0  11   0  sum            0  accum=r[11]
  51      Copy                   8   1   0                 0  r[1]=r[8]
  52      Copy                  10   2   0                 0  r[2]=r[10]
  53      Copy                  11   3   0                 0  r[3]=r[11]
  54      ResultRow              1   3   0                 0  output=r[1..3]
  55    Return                   4   0   0                 0
  56    Null                     0   8  11                 0  r[8..11]=NULL; clear accumulator subroutine start
  57    Integer                  0   5   0                 0  r[5]=0
  58  Return                    16   0   0                 0
  59  Halt                       0   0   0                 0
  60  Transaction                0   1   4                 0  iDb=0 tx_mode=Read
  61  Integer                    1  25   0                 0  r[25]=1
  62  Goto                       0   1   0                 0
