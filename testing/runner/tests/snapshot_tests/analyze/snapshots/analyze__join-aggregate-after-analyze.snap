---
source: analyze.sqltest
expression: |-
  SELECT c.name, COUNT(*) as purchase_count, SUM(p.amount) as total
      FROM customers c
      JOIN purchases p ON c.id = p.customer_id
      GROUP BY c.id;
info:
  statement_type: SELECT
  tables:
  - c.id
  - customers
  - purchases
  setup_blocks:
  - join_tables
  database: ':memory:'
---
QUERY PLAN
|--SCAN customers AS c
`--SEARCH p USING INDEX ephemeral_purchases_t2

BYTECODE
addr  opcode                    p1  p2  p3  p4            p5  comment
   0          Init               0  57   0                 0  Start at 57
   1          Null               0  10  11                 0  r[10..11]=NULL
   2          Integer            0   6   0                 0  r[6]=0; clear group by abort flag
   3          Null               0   7   0                 0  r[7]=NULL; initialize group by comparison registers to NULL
   4          Gosub             16  53   0                 0  ; go to clear accumulator subroutine
   5          OpenRead           0   2   0  k(2,B,B)       0  table=customers, root=2, iDb=0
   6          OpenRead           1   3   0  k(3,B,B,B)     0  table=purchases, root=3, iDb=0
   7          Rewind             0  40   0                 0  Rewind table customers
   8            Once            18   0   0                 0  goto 18
   9            OpenAutoindex    2   0   0                 0  cursor=2
  10            Rewind           1  11   0                 0  Rewind table purchases
  11              Column         1   1  17                 0  r[17]=purchases.customer_id
  12              Column         1   2  18                 0  r[18]=purchases.amount
  13              RowId          1  19   0                 0  r[19]=purchases.rowid
  14              MakeRecord    17   3  20                 0  r[20]=mkrec(r[17..19]); for ephemeral_purchases_t2
  15              FilterAdd      2  17   1                 0  bloom_filter_add(r[17..18])
  16              IdxInsert      2  20  17                 0  key=r[20]
  17            Next             1  11   0                 0
  18            RowId            0  21   0                 0  r[21]=customers.rowid
  19            Filter           2  39  21                 1  if !bloom_filter(r[21..22]) goto 39
  20            SeekGE           2  39  21                 0  key=[21..21]
  21              IdxGT          2  39  21                 0  key=[21..21]
  22              DeferredSeek   2   1   0                 0
  23              RowId          0  13   0                 0  r[13]=customers.rowid
  24              Column         0   1  14                 0  r[14]=customers.name
  25              Column         2   1  15                 0  r[15]=ephemeral(ephemeral_purchases_t2).amount
  26              RealAffinity  15   0   0                 0
  27              Compare        7  13   1  k(1, Binary)   0  r[7..7]==r[13..13]
  28              Jump          29  33  29                 0  ; start new group if comparison is not equal
  29              Gosub          4  44   0                 0  ; check if ended group had data, and output if so
  30              Move          13   7   1                 0  r[7..7]=r[13..13]
  31              IfPos          6  56   0                 0  r[6]>0 -> r[6]-=0, goto 56; check abort flag
  32              Gosub         16  53   0                 0  ; goto clear accumulator subroutine
  33              AggStep        0  22  10  count          0  accum=r[10] step(r[22])
  34              AggStep        0  15  11  sum            0  accum=r[11] step(r[15])
  35              If             5  37   0                 0  if r[5] goto 37; don't emit group columns if continuing existing group
  36              Column         0   1   8                 0  r[8]=customers.name
  37              Integer        1   5   0                 0  r[5]=1; indicate data in accumulator
  38            Next             2  21   0                 0
  39          Next               0   8   0                 0
  40          Gosub              4  44   0                 0  ; emit row for final group
  41          Goto               0  56   0                 0  ; group by finished
  42          Integer            1   6   0                 0  r[6]=1
  43        Return               4   0   0                 0
  44        IfPos                5  46   0                 0  r[5]>0 -> r[5]-=0, goto 46; output group by row subroutine start
  45      Return                 4   0   0                 0
  46      AggFinal               0  10   0  count          0  accum=r[10]
  47      AggFinal               0  11   0  sum            0  accum=r[11]
  48      Copy                   8   1   0                 0  r[1]=r[8]
  49      Copy                  10   2   0                 0  r[2]=r[10]
  50      Copy                  11   3   0                 0  r[3]=r[11]
  51      ResultRow              1   3   0                 0  output=r[1..3]
  52    Return                   4   0   0                 0
  53    Null                     0   8  11                 0  r[8..11]=NULL; clear accumulator subroutine start
  54    Integer                  0   5   0                 0  r[5]=0
  55  Return                    16   0   0                 0
  56  Halt                       0   0   0                 0
  57  Transaction                0   1   4                 0  iDb=0 tx_mode=Read
  58  Integer                    1  22   0                 0  r[22]=1
  59  Goto                       0   1   0                 0
