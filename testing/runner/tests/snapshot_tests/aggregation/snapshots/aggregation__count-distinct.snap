---
source: aggregation.sqltest
expression: "SELECT\n        category,\n        COUNT(DISTINCT salesperson_id) as unique_salespeople,\n        COUNT(DISTINCT region) as unique_regions\n    FROM\n        sales\n    GROUP BY\n        category\n    ORDER BY\n        unique_salespeople DESC;"
info:
  statement_type: SELECT
  tables:
    - sales
  setup_blocks:
    - schema
  database: ":memory:"
---
QUERY PLAN
|--SCAN sales USING INDEX idx_sales_category
`--USE TEMP B-TREE FOR ORDER BY

BYTECODE
addr  opcode                          p1  p2  p3  p4                  p5  comment
   0          Init                     0  55   0                       0  Start at 55
   1          SorterOpen               0   1   0  k(1,-B)              0  cursor=0
   2          Null                     0  10  11                       0  r[10..11]=NULL
   3          Integer                  0   7   0                       0  r[7]=0; clear group by abort flag
   4          Null                     0   8   0                       0  r[8]=NULL; initialize group by comparison registers to NULL
   5          Gosub                   16  41   0                       0  ; go to clear accumulator subroutine
   6          OpenRead                 1   2   0  k(7,B,B,B,B,B,B,B)   0  table=sales, root=2, iDb=0
   7          OpenRead                 2   4   0  k(2,B)               0  index=idx_sales_category, root=4, iDb=0
   8          Rewind                   2  27   0                       0  Rewind index idx_sales_category
   9            DeferredSeek           2   1   0                       0
  10            Column                 1   1  13                       0  r[13]=sales.category
  11            Column                 1   6  14                       0  r[14]=sales.salesperson_id
  12            Column                 1   2  15                       0  r[15]=sales.region
  13            Compare                8  13   1  k(1, Binary)         0  r[8..8]==r[13..13]
  14            Jump                  15  19  15                       0  ; start new group if comparison is not equal
  15            Gosub                  5  31   0                       0  ; check if ended group had data, and output if so
  16            Move                  13   8   1                       0  r[8..8]=r[13..13]
  17            IfPos                  7  46   0                       0  r[7]>0 -> r[7]-=0, goto 46; check abort flag
  18            Gosub                 16  41   0                       0  ; goto clear accumulator subroutine
  19            HashDistinct  1073741824  14   1  jmp=21               0
  20            AggStep                0  14  10  count                0  accum=r[10] step(r[14])
  21            HashDistinct  1073741825  15   1  jmp=23               0
  22            AggStep                0  15  11  count                0  accum=r[11] step(r[15])
  23            If                     6  25   0                       0  if r[6] goto 25; don't emit group columns if continuing existing group
  24            Column                 1   1   9                       0  r[9]=sales.category
  25            Integer                1   6   0                       0  r[6]=1; indicate data in accumulator
  26          Next                     2   9   0                       0
  27          Gosub                    5  31   0                       0  ; emit row for final group
  28          Goto                     0  46   0                       0  ; group by finished
  29          Integer                  1   7   0                       0  r[7]=1
  30        Return                     5   0   0                       0
  31        IfPos                      6  33   0                       0  r[6]>0 -> r[6]-=0, goto 33; output group by row subroutine start
  32      Return                       5   0   0                       0
  33      AggFinal                     0  10   0  count                0  accum=r[10]
  34      AggFinal                     0  11   0  count                0  accum=r[11]
  35      Copy                        10  17   0                       0  r[17]=r[10]
  36      Copy                         9  18   0                       0  r[18]=r[9]
  37      Copy                        11  19   0                       0  r[19]=r[11]
  38      MakeRecord                  17   3   4                       0  r[4]=mkrec(r[17..19])
  39      SorterInsert                 0   4   0  0                    0  key=r[4]
  40    Return                         5   0   0                       0
  41    Null                           0   9  11                       0  r[9..11]=NULL; clear accumulator subroutine start
  42    HashClear             1073741824   0   0                       0
  43    HashClear             1073741825   0   0                       0
  44    Integer                        0   6   0                       0  r[6]=0
  45  Return                          16   0   0                       0
  46  OpenPseudo                       3   4   3                       0  3 columns in r[4]
  47  SorterSort                       0  54   0                       0
  48    SorterData                     0   4   3                       0  r[4]=data
  49    Column                         3   1   1                       0  r[1]=pseudo.column 1
  50    Column                         3   0   2                       0  r[2]=pseudo.column 0
  51    Column                         3   2   3                       0  r[3]=pseudo.column 2
  52    ResultRow                      1   3   0                       0  output=r[1..3]
  53  SorterNext                       0  48   0                       0
  54  Halt                             0   0   0                       0
  55  Transaction                      0   1   8                       0  iDb=0 tx_mode=Read
  56  Goto                             0   1   0                       0
