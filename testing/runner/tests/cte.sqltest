@database :memory:

# =============================================================================
# Basic CTE tests
# =============================================================================

test cte-basic {
    WITH t AS (SELECT 1 as x) SELECT * FROM t;
}
expect {
    1
}

test cte-multiple {
    WITH t1 AS (SELECT 1 as x), t2 AS (SELECT 2 as y) SELECT * FROM t1, t2;
}
expect {
    1|2
}

# Test WITH ... AS MATERIALIZED syntax - forces materialization even for single-ref CTEs
test cte-as-materialized {
    WITH t AS MATERIALIZED (SELECT 1 as x, 2 as y) SELECT x, y FROM t;
}
expect {
    1|2
}

# Test AS NOT MATERIALIZED syntax (hint to avoid materialization)
test cte-as-not-materialized {
    WITH t AS NOT MATERIALIZED (SELECT 1 as x) SELECT * FROM t;
}
expect {
    1
}

# Test multiple CTEs with mixed materialization hints
test cte-mixed-materialization {
    WITH
      t1 AS MATERIALIZED (SELECT 1 as a),
      t2 AS NOT MATERIALIZED (SELECT 2 as b),
      t3 AS (SELECT 3 as c)
    SELECT * FROM t1, t2, t3;
}
expect {
    1|2|3
}

# Verify that AS MATERIALIZED actually materializes by using random().
# A materialized CTE should compute random() once and return the same value
# for multiple references, while non-materialized would re-evaluate.
test cte-materialized-random-same-value {
    WITH t AS MATERIALIZED (SELECT random() as r)
    SELECT (SELECT r FROM t) = (SELECT r FROM t) as same;
}
expect {
    1
}

test cte-chain {
    WITH a AS (SELECT 1 as x), b AS (SELECT x FROM a), c AS (SELECT x FROM b), d AS (SELECT x FROM c) SELECT * FROM d;
}
expect {
    1
}

# Test for long CTE chains - regression test for exponential re-planning issue
# See: https://github.com/tursodatabase/turso/issues/4887
@cross-check-integrity
test cte-chain-long {
    CREATE TABLE t (x INT);
    INSERT INTO t VALUES (1);
    WITH
      c1 AS (SELECT x FROM t),
      c2 AS (SELECT x FROM c1),
      c3 AS (SELECT x FROM c2),
      c4 AS (SELECT x FROM c3),
      c5 AS (SELECT x FROM c4),
      c6 AS (SELECT x FROM c5),
      c7 AS (SELECT x FROM c6)
    SELECT * FROM c7;
}
expect {
    1
}

# =============================================================================
# CTE with compound SELECT (UNION, UNION ALL, INTERSECT, EXCEPT)
# =============================================================================

test cte-union {
    WITH t AS (SELECT 1 as x UNION SELECT 2) SELECT * FROM t ORDER BY 1;
}
expect {
    1
    2
}

test cte-union-all {
    WITH t AS (SELECT 1 as x UNION ALL SELECT 2) SELECT * FROM t ORDER BY 1;
}
expect {
    1
    2
}

test cte-intersect {
    WITH t AS (SELECT 1 as x INTERSECT SELECT 1) SELECT * FROM t;
}
expect {
    1
}

test cte-except {
    WITH t AS (SELECT 1 as x EXCEPT SELECT 2) SELECT * FROM t;
}
expect {
    1
}

test cte-multiple-unions {
    WITH t AS (SELECT 1 as x UNION SELECT 2 UNION SELECT 3) SELECT * FROM t ORDER BY 1;
}
expect {
    1
    2
    3
}

test cte-union-ref {
    WITH t AS (SELECT 1 as x UNION SELECT 2), u AS (SELECT * FROM t) SELECT * FROM u ORDER BY 1;
}
expect {
    1
    2
}

test cte-union-multi-ref {
    WITH t AS (SELECT 1 as x UNION SELECT 2) SELECT * FROM t as a, t as b ORDER BY 1, 2;
}
expect {
    1|1
    1|2
    2|1
    2|2
}

test cte-union-aggregate {
    WITH t AS (SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) SELECT COUNT(*) FROM t;
}
expect {
    3
}

test cte-union-limit {
    WITH t AS (SELECT 1 UNION SELECT 2 UNION SELECT 3 LIMIT 2) SELECT * FROM t ORDER BY 1;
}
expect {
    1
    2
}

test cte-union-limit-one {
    WITH t AS (SELECT 1 UNION SELECT 2 LIMIT 1) SELECT * FROM t;
}
expect {
    1
}

test cte-union-limit-offset {
    WITH t AS (SELECT 1 UNION SELECT 2 UNION SELECT 3 LIMIT 2 OFFSET 1) SELECT * FROM t ORDER BY 1;
}
expect {
    2
    3
}

test cte-intersect-limit {
    WITH t AS (SELECT 1 INTERSECT SELECT 1 LIMIT 1) SELECT * FROM t;
}
expect {
    1
}

test cte-except-limit {
    WITH t AS (SELECT 1 UNION SELECT 2 EXCEPT SELECT 2 LIMIT 2) SELECT * FROM t;
}
expect {
    1
}

# =============================================================================
# CTE with DML statements (INSERT, UPDATE, DELETE)
# =============================================================================

@cross-check-integrity
test cte-insert-basic {
    CREATE TABLE t(x);
    WITH c AS (SELECT 1 as x) INSERT INTO t SELECT * FROM c;
    SELECT * FROM t;
}
expect {
    1
}

@cross-check-integrity
test cte-insert-union {
    CREATE TABLE t(x);
    WITH c AS (SELECT 1 UNION SELECT 2 UNION SELECT 3) INSERT INTO t SELECT * FROM c;
    SELECT * FROM t ORDER BY 1;
}
expect {
    1
    2
    3
}

@cross-check-integrity
test cte-insert-chain {
    CREATE TABLE t(x);
    WITH a AS (SELECT 1 as x), b AS (SELECT x + 10 FROM a) INSERT INTO t SELECT * FROM b;
    SELECT * FROM t;
}
expect {
    11
}

@cross-check-integrity
test cte-delete-basic {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH vals AS (SELECT 1 as x) DELETE FROM t WHERE x IN (SELECT x FROM vals);
    SELECT * FROM t ORDER BY 1;
}
expect {
    2
    3
}

@cross-check-integrity
test cte-delete-union {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3),(4);
    WITH odd AS (SELECT 1 UNION SELECT 3) DELETE FROM t WHERE x IN (SELECT * FROM odd);
    SELECT * FROM t ORDER BY 1;
}
expect {
    2
    4
}

@cross-check-integrity
test cte-delete-chain {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH a AS (SELECT 1 as x), b AS (SELECT x FROM a) DELETE FROM t WHERE x IN (SELECT x FROM b);
    SELECT * FROM t ORDER BY 1;
}
expect {
    2
    3
}

@cross-check-integrity
test cte-update-where {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH vals AS (SELECT 1 as x) UPDATE t SET x = x + 10 WHERE x IN (SELECT x FROM vals);
    SELECT * FROM t ORDER BY 1;
}
expect {
    2
    3
    11
}

@cross-check-integrity
test cte-update-chain {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH a AS (SELECT 2 as x), b AS (SELECT x FROM a) UPDATE t SET x = x * 100 WHERE x IN (SELECT x FROM b);
    SELECT * FROM t ORDER BY 1;
}
expect {
    1
    3
    200
}

@cross-check-integrity
test cte-delete-multiple-ctes {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3),(4),(5);
    WITH low AS (SELECT 1 UNION SELECT 2), high AS (SELECT 4 UNION SELECT 5)
    DELETE FROM t WHERE x IN (SELECT * FROM low) OR x IN (SELECT * FROM high);
    SELECT * FROM t;
}
expect {
    3
}

@cross-check-integrity
test cte-multi-ref-where {
    CREATE TABLE t(x, y);
    INSERT INTO t VALUES (1, 10), (2, 20), (3, 30);
    WITH vals AS (SELECT 2 as v)
    DELETE FROM t WHERE x IN (SELECT v FROM vals) AND y IN (SELECT v * 10 FROM vals);
    SELECT * FROM t ORDER BY 1;
}
expect {
    1|10
    3|30
}

@cross-check-integrity
test cte-insert-returning {
    CREATE TABLE t(x);
    WITH c AS (SELECT 42 as x) INSERT INTO t SELECT * FROM c RETURNING x;
}
expect {
    42
}

@cross-check-integrity
test cte-delete-returning {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH vals AS (SELECT 2 as x) DELETE FROM t WHERE x IN (SELECT x FROM vals) RETURNING x;
}
expect {
    2
}

@cross-check-integrity
test cte-update-returning {
    CREATE TABLE t(x);
    INSERT INTO t VALUES (1),(2),(3);
    WITH vals AS (SELECT 1 as x) UPDATE t SET x = x + 100 WHERE x IN (SELECT x FROM vals) RETURNING x;
}
expect {
    101
}

# =============================================================================
# CTE with UPDATE on keyed tables (INTEGER PRIMARY KEY)
#
# Keyed tables use an ephemeral table in the optimizer, which replaces
# table_references. CTE outer query refs must be preserved through that
# rewrite or they become unresolvable. (issue #5224)
# =============================================================================

# Direct CTE column reference in SET clause is invalid SQL (issue #5224).
# SQLite rejects with "no such column: c.v", we reject with "no such table: c".
@cross-check-integrity
test cte-update-direct-ref-keyed {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 2);
    WITH c(v) AS (SELECT 9) UPDATE t SET a = c.v;
}
expect error {
    no such
}

# Same on non-keyed table
@cross-check-integrity
test cte-update-direct-ref-nonkeyed {
    CREATE TABLE t(a, b);
    INSERT INTO t VALUES(1, 2);
    WITH c(v) AS (SELECT 9) UPDATE t SET a = c.v;
}
expect error {
    no such
}

# CTE in WHERE clause on INTEGER PRIMARY KEY table
@cross-check-integrity
test cte-update-keyed-where {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20), (3, 30);
    WITH c AS (SELECT 1 as v) UPDATE t SET b = 99 WHERE a IN (SELECT v FROM c);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|99
    2|20
    3|30
}

# Chained CTEs in WHERE on keyed table
@cross-check-integrity
test cte-update-keyed-chained-where {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20), (3, 30);
    WITH a AS (SELECT 2 as x), b AS (SELECT x FROM a) UPDATE t SET b = b + 100 WHERE a IN (SELECT x FROM b);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|10
    2|120
    3|30
}

# CTE with multi-row result in WHERE on keyed table
@cross-check-integrity
test cte-update-keyed-multirow-where {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20), (3, 30), (4, 40);
    WITH targets AS (SELECT 1 as v UNION ALL SELECT 3) UPDATE t SET b = -b WHERE a IN (SELECT v FROM targets);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|-10
    2|20
    3|-30
    4|40
}

# CTE with subquery in SET clause on keyed table (updates non-PK column)
@cross-check-integrity
test cte-update-keyed-set-subquery {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 2);
    WITH c(v) AS (SELECT 42) UPDATE t SET b = (SELECT v FROM c) WHERE a = 1;
    SELECT * FROM t;
}
expect {
    1|42
}

# CTE with subquery in SET updating the PRIMARY KEY itself
@cross-check-integrity
test cte-update-keyed-set-pk-subquery {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 2);
    WITH c(v) AS (SELECT 9) UPDATE t SET a = (SELECT v FROM c) WHERE a = 1;
    SELECT * FROM t;
}
expect {
    9|2
}

# CTE used in both SET subquery and WHERE on keyed table
@cross-check-integrity
test cte-update-keyed-set-and-where-subquery {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 2), (3, 4);
    WITH c AS (SELECT 1 as id, 100 as newval) UPDATE t SET a = (SELECT newval FROM c), b = 0 WHERE a = (SELECT id FROM c);
    SELECT * FROM t ORDER BY a;
}
expect {
    3|4
    100|0
}

# Multiple CTEs, one in WHERE one in SET subquery, keyed table
@cross-check-integrity
test cte-update-keyed-multiple-ctes-set-where {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 2), (3, 4);
    WITH x AS (SELECT 1 as id), y AS (SELECT 99 as val) UPDATE t SET b = (SELECT val FROM y) WHERE a IN (SELECT id FROM x);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|99
    3|4
}

# CTE with UPDATE + RETURNING on keyed table
@cross-check-integrity
test cte-update-keyed-returning {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 2), (3, 4);
    WITH c AS (SELECT 1 as v) UPDATE t SET b = b + 50 WHERE a IN (SELECT v FROM c) RETURNING a, b;
}
expect {
    1|52
}

# CTE updating PK with RETURNING on keyed table
@cross-check-integrity
test cte-update-keyed-pk-returning {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 2);
    WITH c(v) AS (SELECT 9) UPDATE t SET a = (SELECT v FROM c) WHERE a = 1 RETURNING a, b;
}
expect {
    9|2
}

# CTE + UPDATE on keyed table with secondary index
@cross-check-integrity
test cte-update-keyed-with-index {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    CREATE INDEX idx_b ON t(b);
    INSERT INTO t VALUES(1, 10), (2, 20);
    WITH c AS (SELECT 1 as v) UPDATE t SET b = 99 WHERE a IN (SELECT v FROM c);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|99
    2|20
}

# CTE in WHERE + SET + RETURNING with text column on keyed table
@cross-check-integrity
test cte-update-keyed-text-returning {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t VALUES(1, 'old'), (2, 'keep');
    WITH c AS (SELECT 1 as target, 'new' as replacement) UPDATE t SET b = (SELECT replacement FROM c) WHERE a = (SELECT target FROM c) RETURNING *;
}
expect {
    1|new
}

# CTE referencing the table being updated, used in WHERE on keyed table
@cross-check-integrity
test cte-update-keyed-self-ref-where {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20), (3, 30);
    WITH snapshot AS (SELECT a, b FROM t WHERE b > 15) UPDATE t SET b = 0 WHERE a IN (SELECT a FROM snapshot);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|10
    2|0
    3|0
}

# CTE referencing table being updated, used in SET subquery on keyed table
@cross-check-integrity
test cte-update-keyed-self-ref-set {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 100), (2, 200);
    WITH vals AS (SELECT a, b FROM t WHERE a = 2) UPDATE t SET b = (SELECT b FROM vals) WHERE a = 1;
    SELECT * FROM t ORDER BY a;
}
expect {
    1|200
    2|200
}

# CTE with aggregate in SET subquery on keyed table
@cross-check-integrity
test cte-update-keyed-aggregate-set {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20), (3, 30);
    WITH totals AS (SELECT SUM(b) as s FROM t) UPDATE t SET b = (SELECT s FROM totals) WHERE a = 1;
    SELECT * FROM t ORDER BY a;
}
expect {
    1|60
    2|20
    3|30
}

# CTE with LIMIT in WHERE on keyed table
@cross-check-integrity
test cte-update-keyed-limit-where {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20), (3, 30);
    WITH top AS (SELECT a FROM t ORDER BY b DESC LIMIT 2) UPDATE t SET b = 0 WHERE a IN (SELECT a FROM top);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|10
    2|0
    3|0
}

# CTE WHERE with no matches on keyed table (updates nothing)
@cross-check-integrity
test cte-update-keyed-no-match {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20);
    WITH c AS (SELECT 999 as v) UPDATE t SET b = 0 WHERE a IN (SELECT v FROM c);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|10
    2|20
}

# CTE with empty result set in WHERE on keyed table
@cross-check-integrity
test cte-update-keyed-empty-cte {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10);
    WITH empty AS (SELECT a FROM t WHERE 0) UPDATE t SET b = 0 WHERE a IN (SELECT a FROM empty);
    SELECT * FROM t;
}
expect {
    1|10
}

# CTE setting multiple columns via subqueries on keyed table
@cross-check-integrity
test cte-update-keyed-multi-col-set {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b, c);
    INSERT INTO t VALUES(1, 'old_b', 'old_c');
    WITH vals AS (SELECT 'new_b' as b, 'new_c' as c) UPDATE t SET b = (SELECT b FROM vals), c = (SELECT c FROM vals) WHERE a = 1;
    SELECT * FROM t;
}
expect {
    1|new_b|new_c
}

# CTE DELETE on keyed table
@cross-check-integrity
test cte-delete-keyed-where {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20), (3, 30);
    WITH c AS (SELECT 2 as v) DELETE FROM t WHERE a IN (SELECT v FROM c);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|10
    3|30
}

# CTE with UNIQUE constraint (non-PK) table
@cross-check-integrity
test cte-update-unique-where {
    CREATE TABLE t(a INTEGER, b TEXT UNIQUE);
    INSERT INTO t VALUES(1, 'x'), (2, 'y');
    WITH c AS (SELECT 'x' as v) UPDATE t SET a = 99 WHERE b IN (SELECT v FROM c);
    SELECT * FROM t ORDER BY a;
}
expect {
    2|y
    99|x
}

# CTE UPDATE all rows on keyed table (no WHERE filter)
@cross-check-integrity
test cte-update-keyed-all-rows {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20);
    WITH c AS (SELECT 0 as v) UPDATE t SET b = (SELECT v FROM c);
    SELECT * FROM t ORDER BY a;
}
expect {
    1|0
    2|0
}

# CTE DELETE with RETURNING on keyed table
@cross-check-integrity
test cte-delete-keyed-returning {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b);
    INSERT INTO t VALUES(1, 10), (2, 20), (3, 30);
    WITH c AS (SELECT 2 as v) DELETE FROM t WHERE a IN (SELECT v FROM c) RETURNING a, b;
}
expect {
    2|20
}

# =============================================================================
# Compound SELECT column name propagation to downstream CTEs
# =============================================================================

test cte-compound-colname-union {
    WITH t1 AS (SELECT 1 AS x UNION SELECT 2), t2 AS (SELECT x FROM t1) SELECT * FROM t2 ORDER BY 1;
}
expect {
    1
    2
}

test cte-compound-colname-union-all {
    WITH t1 AS (SELECT 1 AS x UNION ALL SELECT 2), t2 AS (SELECT x FROM t1 WHERE x > 0) SELECT * FROM t2 ORDER BY 1;
}
expect {
    1
    2
}

test cte-compound-colname-intersect {
    WITH t1 AS (SELECT 1 AS x INTERSECT SELECT 1), t2 AS (SELECT x FROM t1) SELECT * FROM t2;
}
expect {
    1
}

test cte-compound-colname-except {
    WITH t1 AS (SELECT 1 AS x EXCEPT SELECT 2), t2 AS (SELECT x FROM t1) SELECT * FROM t2;
}
expect {
    1
}

test cte-compound-colname-multi {
    WITH t1 AS (SELECT 1 AS a, 2 AS b UNION SELECT 3, 4), t2 AS (SELECT a, b, a + b AS sum FROM t1) SELECT * FROM t2 ORDER BY a;
}
expect {
    1|2|3
    3|4|7
}

# =============================================================================
# Compound SELECT in FROM clause subqueries
# =============================================================================

test cte-compound-from-union {
    SELECT * FROM (SELECT 1 UNION SELECT 2) ORDER BY 1;
}
expect {
    1
    2
}

test cte-compound-from-union-all {
    SELECT * FROM (SELECT 1 UNION ALL SELECT 2) ORDER BY 1;
}
expect {
    1
    2
}

test cte-compound-from-intersect {
    SELECT * FROM (SELECT 1 INTERSECT SELECT 1);
}
expect {
    1
}

test cte-compound-from-except {
    SELECT * FROM (SELECT 1 EXCEPT SELECT 2);
}
expect {
    1
}

test cte-compound-from-alias {
    SELECT * FROM (SELECT 1 UNION SELECT 2) AS t ORDER BY 1;
}
expect {
    1
    2
}

test cte-compound-from-aggregate {
    SELECT COUNT(*), SUM(val) FROM (SELECT 1 AS val UNION ALL SELECT 2 UNION ALL SELECT 3);
}
expect {
    3|6
}

# =============================================================================
# CTEs visibility in scalar subqueries in SELECT list
# =============================================================================

test cte-scalar-subquery-no-from {
    WITH t AS (SELECT 1 AS x) SELECT (SELECT x FROM t) AS subq;
}
expect {
    1
}

test cte-scalar-subquery-aggregate {
    WITH t AS (SELECT 1 AS x UNION ALL SELECT 2 UNION ALL SELECT 3) SELECT (SELECT SUM(x) FROM t) AS total;
}
expect {
    6
}

@cross-check-integrity
test cte-scalar-subquery-with-from {
    CREATE TABLE tbl(id);
    INSERT INTO tbl VALUES (1),(2);
    WITH c AS (SELECT 100 AS val) SELECT id, (SELECT val FROM c) AS const FROM tbl ORDER BY id;
}
expect {
    1|100
    2|100
}

test cte-scalar-subquery-multi-cte {
    WITH a AS (SELECT 10 AS x), b AS (SELECT 20 AS y) SELECT (SELECT x FROM a), (SELECT y FROM b);
}
expect {
    10|20
}

test cte-scalar-subquery-chain {
    WITH a AS (SELECT 5 AS x), b AS (SELECT x * 2 AS y FROM a) SELECT (SELECT y FROM b);
}
expect {
    10
}

test cte-scalar-subquery-compound {
    WITH t AS (SELECT 1 UNION SELECT 2 UNION SELECT 3) SELECT (SELECT COUNT(*) FROM t);
}
expect {
    3
}

# =============================================================================
# CTE with explicit column names
# =============================================================================

test cte-explicit-columns-basic {
    WITH t(a, b) AS (SELECT 1, 2) SELECT * FROM t;
}
expect {
    1|2
}

test cte-explicit-columns-ref {
    WITH t(a, b) AS (SELECT 1, 2) SELECT a, b FROM t;
}
expect {
    1|2
}

test cte-explicit-columns-rename {
    WITH t(x, y) AS (SELECT 1 as a, 2 as b) SELECT x, y FROM t;
}
expect {
    1|2
}

test cte-explicit-columns-expr {
    WITH t(sum, product) AS (SELECT 3 + 4, 3 * 4) SELECT sum, product FROM t;
}
expect {
    7|12
}

test cte-explicit-columns-multi {
    WITH t1(a) AS (SELECT 1), t2(b) AS (SELECT 2) SELECT a, b FROM t1, t2;
}
expect {
    1|2
}

test cte-explicit-columns-chain {
    WITH t1(a, b) AS (SELECT 1, 2), t2(x, y) AS (SELECT a, b FROM t1) SELECT x, y FROM t2;
}
expect {
    1|2
}

# # @skip-if sqlite "sqlite has different error message"
# test cte-explicit-columns-count-mismatch {
#     With t(a, b, c) AS (SELECT 1, 2) SELECT * FROM t;
# }
# expect error {
#     table t has 2 columns but 3 column names were provided
# }

# =============================================================================
# CTE column count mismatch - unreferenced CTEs (deferred validation)
# =============================================================================

# SQLite defers CTE column count validation until the CTE is actually
# referenced. Unreferenced CTEs with mismatched column counts should
# not produce errors.

@cross-check-integrity
test cte-unreferenced-column-mismatch-delete {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT, c INTEGER);
    CREATE TABLE t2(x INTEGER PRIMARY KEY);
    INSERT INTO t1 VALUES(1, 'hello', 10);
    INSERT INTO t2 VALUES(1);
    WITH cte(col0) AS (SELECT * FROM t1) DELETE FROM t2 WHERE x = 1;
    SELECT count(*) FROM t2;
}
expect {
    0
}

@cross-check-integrity
test cte-unreferenced-column-mismatch-update {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT, c INTEGER);
    CREATE TABLE t2(x INTEGER PRIMARY KEY, y TEXT);
    INSERT INTO t1 VALUES(1, 'hello', 10);
    INSERT INTO t2 VALUES(1, 'yes');
    WITH cte(col0) AS (SELECT * FROM t1) UPDATE t2 SET y = 'no' WHERE x = 1;
    SELECT y FROM t2;
}
expect {
    no
}

test cte-unreferenced-column-mismatch-select {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT, c INTEGER);
    INSERT INTO t1 VALUES(1, 'hello', 10);
    WITH cte(col0) AS (SELECT * FROM t1) SELECT 42;
}
expect {
    42
}

test cte-unreferenced-column-mismatch-multi-cte {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT, c INTEGER);
    INSERT INTO t1 VALUES(1, 'hello', 10);
    WITH cte_ok(x, y, z) AS (SELECT * FROM t1), cte_bad(col0) AS (SELECT * FROM t1) SELECT x, y, z FROM cte_ok;
}
expect {
    1|hello|10
}

# =============================================================================
# CTE visibility in VALUES and RETURNING clause subqueries
# =============================================================================

@cross-check-integrity
test cte-insert-values-subquery {
    CREATE TABLE t(a);
    WITH test AS (SELECT 99 as x) INSERT INTO t VALUES ((SELECT x FROM test));
    SELECT * FROM t;
}
expect {
    99
}

@cross-check-integrity
test cte-insert-values-multi-subquery {
    CREATE TABLE t(a, b);
    WITH test AS (SELECT 1 as x, 2 as y) INSERT INTO t VALUES ((SELECT x FROM test), (SELECT y FROM test));
    SELECT * FROM t;
}
expect {
    1|2
}

@cross-check-integrity
test cte-insert-values-multiple-rows {
    CREATE TABLE t(a);
    WITH test AS (SELECT 10 as x) INSERT INTO t VALUES ((SELECT x FROM test)), ((SELECT x + 1 FROM test));
    SELECT * FROM t ORDER BY a;
}
expect {
    10
    11
}

@cross-check-integrity
test cte-insert-returning-subquery {
    CREATE TABLE t(a);
    WITH test AS (SELECT 99 as x) INSERT INTO t VALUES (1) RETURNING (SELECT x FROM test);
}
expect {
    99
}

@cross-check-integrity
test cte-insert-returning-multi-subquery {
    CREATE TABLE t(a);
    WITH test AS (SELECT 1 as x, 2 as y) INSERT INTO t VALUES (100) RETURNING (SELECT x FROM test), (SELECT y FROM test);
}
expect {
    1|2
}

@cross-check-integrity
test cte-delete-returning-subquery {
    CREATE TABLE t(a);
    INSERT INTO t VALUES (1), (2), (3);
    WITH test AS (SELECT 99 as x) DELETE FROM t WHERE a = 2 RETURNING (SELECT x FROM test);
}
expect {
    99
}

@cross-check-integrity
test cte-update-returning-subquery {
    CREATE TABLE t(a);
    INSERT INTO t VALUES (1);
    WITH test AS (SELECT 99 as x) UPDATE t SET a = 10 WHERE a = 1 RETURNING (SELECT x FROM test);
}
expect {
    99
}

@cross-check-integrity
test cte-insert-values-and-returning-subquery {
    CREATE TABLE t(a);
    WITH test AS (SELECT 42 as x) INSERT INTO t VALUES ((SELECT x FROM test)) RETURNING (SELECT x + 1 FROM test);
}
expect {
    43
}

# =============================================================================
# CTE referenced twice in subquery with indexed table (issue #5074)
# =============================================================================

@cross-check-integrity
test cte-dual-ref-indexed-subquery-empty {
    CREATE TABLE t(a);
    CREATE INDEX i ON t(a);
    WITH c AS (SELECT 0 c0 FROM(SELECT*FROM t)x)
    SELECT*FROM(SELECT*FROM c,c c2 JOIN(SELECT 1)u ON c2.c0=0)y;
}
expect {
}

@cross-check-integrity
test cte-dual-ref-indexed-subquery {
    CREATE TABLE t(a);
    CREATE INDEX i ON t(a);
    INSERT INTO t VALUES (1),(2);
    WITH c AS (SELECT 0 c0 FROM(SELECT*FROM t)x)
    SELECT*FROM(SELECT*FROM c,c c2 JOIN(SELECT 1)u ON c2.c0=0)y;
}
expect {
    0|0|1
    0|0|1
    0|0|1
    0|0|1
}

# =============================================================================
# Error cases
# =============================================================================

test cte-duplicate-name {
    WITH t AS (SELECT 1), t AS (SELECT 2) SELECT * FROM t;
}
expect error {
    duplicate WITH table name
}

@cross-check-integrity
test cte-duplicate-name-view {
    CREATE TABLE cte_dup_table(x);
    CREATE VIEW cte_dup_view AS
        WITH cte AS (SELECT 1), cte AS (SELECT 2)
        SELECT * FROM cte_dup_table;
}
expect error {
    duplicate WITH table name
}

# @skip-if sqlite "sqlite supports recursive CTEs"
# test cte-recursive-unsupported {
#     WITH RECURSIVE cnt(x) AS (SELECT 1 UNION ALL SELECT x+1 FROM cnt WHERE x<5) SELECT * FROM cnt;
# }
# expect error {
#     Recursive CTEs are not yet supported
# }
#
# @skip-if sqlite "sqlite supports materialized CTEs"
# test cte-materialized-unsupported {
#     WITH t AS MATERIALIZED (SELECT 1) SELECT * FROM t;
# }
# expect error {
#     Materialized CTEs are not yet supported
# }

setup cte_shadow_view {
    CREATE VIEW v AS SELECT 1 as val;
}

setup cte_shadow_table {
    CREATE TABLE t(x TEXT);
    INSERT INTO t VALUES('from_table');
}

# CTE can shadow a view (sqlite compat)
@skip-if mvcc "views not supported in MVCC"
@setup cte_shadow_view
test cte-shadows-view {
    WITH v AS (SELECT 'from_cte' as val) SELECT * FROM v;
}
expect {
    from_cte
}

# CTE can shadow a table
@setup cte_shadow_table
test cte-shadows-table {
    WITH t AS (SELECT 'from_cte' as x) SELECT * FROM t;
}
expect {
    from_cte
}

# Self-referencing non-recursive CTE with same name as view = circular reference
@skip-if mvcc "views not supported in MVCC"
@setup cte_shadow_view
test cte-circular-ref-view {
    WITH v AS (SELECT * FROM v) SELECT * FROM v;
}
expect error {
    circular reference: v
}

# Self-referencing non-recursive CTE with same name as table = circular reference
@setup cte_shadow_table
test cte-circular-ref-table {
    WITH t AS (SELECT * FROM t) SELECT * FROM t;
}
expect error {
    circular reference: t
}

# CTE shadows table but references different table
@setup cte_shadow_table
@cross-check-integrity
test cte-shadows-table-refs-other {
    CREATE TABLE other(y TEXT);
    INSERT INTO other VALUES('from_other');
    WITH t AS (SELECT y as x FROM other) SELECT * FROM t;
}
expect {
    from_other
}

# CTE does not leak into view expansion — view sees the real table
@skip-if mvcc "views not supported in MVCC"
@setup cte_shadow_table
test cte-does-not-leak-into-view {
    CREATE VIEW v AS SELECT * FROM t;
    WITH t AS (SELECT 'from_cte' as x) SELECT * FROM v;
}
expect {
    from_table
}

# =============================================================================
# Multi-reference CTE with materialization - regression tests
# =============================================================================

# Original reproducer: multi-ref CTE with UNION where materialization is triggered.
# The bug was that UNION deduplication was bypassed when the second reference
# triggered materialization via ephemeral index, producing duplicate rows.
test cte-multi-ref-union-dedupe {
    WITH cte0 AS (SELECT -13 AS c0_0 UNION SELECT -14 UNION SELECT 19 UNION SELECT -13),
         cte2 AS (SELECT c0_0 AS c2_0 FROM cte0)
    SELECT t1.c2_0, t2.c0_0
    FROM cte2 t1 INNER JOIN cte0 t2 ON t1.c2_0 = t2.c0_0
    ORDER BY 1, 2;
}
expect {
    -14|-14
    -13|-13
    19|19
}

# VALUES-based CTE with multiple references
test cte-values-multi-ref {
    WITH cte AS (VALUES (1), (2), (3))
    SELECT * FROM cte t1 INNER JOIN cte t2 ON t1.column1 = t2.column1 ORDER BY 1, 2;
}
expect {
    1|1
    2|2
    3|3
}

# Multi-ref UNION ALL (should preserve duplicates, not dedupe)
test cte-multi-ref-union-all {
    WITH cte AS (SELECT 1 AS x UNION ALL SELECT 1 UNION ALL SELECT 2)
    SELECT a.x, b.x FROM cte a INNER JOIN cte b ON a.x = b.x ORDER BY 1, 2;
}
expect {
    1|1
    1|1
    1|1
    1|1
    2|2
}

# Multi-ref CTE with join and WHERE clause
test cte-multi-ref-join-where {
    WITH cte AS (SELECT 1 AS x UNION SELECT 2 UNION SELECT 3)
    SELECT a.x, b.x FROM cte a, cte b WHERE a.x = b.x ORDER BY 1;
}
expect {
    1|1
    2|2
    3|3
}

# Multi-ref CTE with INTERSECT
test cte-multi-ref-intersect {
    WITH cte AS (SELECT 1 AS x INTERSECT SELECT 1)
    SELECT a.x, b.x FROM cte a, cte b WHERE a.x = b.x;
}
expect {
    1|1
}

# Multi-ref CTE with EXCEPT
test cte-multi-ref-except {
    WITH cte AS (SELECT 1 AS x UNION SELECT 2 EXCEPT SELECT 2)
    SELECT a.x, b.x FROM cte a, cte b WHERE a.x = b.x;
}
expect {
    1|1
}

# =============================================================================
# CTE name shadowing in nested scopes
# =============================================================================

# Inner CTE shadows outer CTE in EXISTS subquery
test cte-shadow-in-exists {
    WITH cte AS (SELECT 1 AS a)
    SELECT EXISTS (WITH cte AS (SELECT 2 AS b) SELECT * FROM cte);
}
expect {
    1
}

# Inner CTE shadows outer, inner value is used
test cte-shadow-inner-value {
    WITH cte AS (SELECT 100 AS v)
    SELECT (WITH cte AS (SELECT 200 AS v) SELECT v FROM cte);
}
expect {
    200
}

# Outer CTE still accessible outside inner scope
test cte-shadow-outer-still-accessible {
    WITH cte AS (SELECT 100 AS v)
    SELECT v, (WITH cte AS (SELECT 200 AS v) SELECT v FROM cte) AS inner_v FROM cte;
}
expect {
    100|200
}

# Three levels of CTE shadowing
test cte-shadow-three-levels {
    WITH cte AS (SELECT 1 AS lvl)
    SELECT (
      WITH cte AS (SELECT 2 AS lvl)
      SELECT (
        WITH cte AS (SELECT 3 AS lvl)
        SELECT lvl FROM cte
      )
    );
}
expect {
    3
}

# Inner CTE with different column schema than outer
test cte-shadow-different-columns {
    WITH cte AS (SELECT 1 AS a, 2 AS b)
    SELECT (WITH cte AS (SELECT 99 AS z) SELECT z FROM cte);
}
expect {
    99
}

# CTE shadowing with UNION ALL across scopes
@cross-check-integrity
test cte-shadow-union-all {
    CREATE TABLE cte_shadow_t(x INTEGER);
    INSERT INTO cte_shadow_t VALUES(1);
    INSERT INTO cte_shadow_t VALUES(2);
    WITH cte AS (SELECT x FROM cte_shadow_t WHERE x = 1)
    SELECT * FROM cte
    UNION ALL
    SELECT * FROM (WITH cte AS (SELECT x FROM cte_shadow_t WHERE x = 2) SELECT * FROM cte);
    DROP TABLE cte_shadow_t;
}
expect {
    1
    2
}

# CTE shadowing in FROM-clause subquery
test cte-shadow-in-from-subquery {
    WITH cte AS (SELECT 'outer' AS src)
    SELECT * FROM (WITH cte AS (SELECT 'inner' AS src) SELECT * FROM cte);
}
expect {
    inner
}

# Inner CTE shadows outer, outer CTE is unused
test cte-shadow-outer-unused {
    WITH cte AS (SELECT 1 AS a)
    SELECT (WITH cte AS (SELECT 2 AS a) SELECT a FROM cte) + 10;
}
expect {
    12
}

# =============================================================================
# CTE aggregate with empty result set
# =============================================================================

# Non-aggregate columns must be NULL when WHERE filters out all rows
# from a CTE in a single-row aggregate query.
@cross-check-integrity
test cte-aggregate-empty-result-non-agg-columns {
    CREATE TABLE t(x INTEGER, y TEXT);
    INSERT INTO t VALUES (1, 'a'), (2, 'b');
    WITH cte AS (SELECT x, y FROM t)
    SELECT CAST(TOTAL(y) AS INTEGER), x, x FROM cte WHERE x > 999;
}
expect {
    0||
}

# Same behavior expected with FROM-clause subquery
@cross-check-integrity
test subquery-aggregate-empty-result-non-agg-columns {
    CREATE TABLE t(x INTEGER, y TEXT);
    INSERT INTO t VALUES (1, 'a'), (2, 'b');
    SELECT CAST(TOTAL(y) AS INTEGER), x, x FROM (SELECT x, y FROM t) sub WHERE x > 999;
}
expect {
    0||
}

# =============================================================================
# Scalar subquery referencing CTE by original name after alias (#5225)
# =============================================================================

# Scalar subquery using original CTE name when CTE is aliased should error
test cte-alias-scalar-subquery-original-name {
    WITH c AS (SELECT 1 x) SELECT (SELECT c.x) FROM c t;
}
expect error {
}

# Scalar subquery uses alias name (should work)
test cte-alias-scalar-subquery-alias-name {
    WITH c AS (SELECT 1 x) SELECT (SELECT t.x) FROM c t;
}
expect {
    1
}

# Without alias, original CTE name works in scalar subquery
test cte-no-alias-scalar-subquery {
    WITH c AS (SELECT 1 x) SELECT (SELECT c.x) FROM c;
}
expect {
    1
}

# Multiple columns referenced by alias in scalar subquery
test cte-alias-scalar-subquery-multiple-columns {
    WITH c AS (SELECT 1 x, 2 y) SELECT (SELECT t.x), (SELECT t.y) FROM c t;
}
expect {
    1|2
}

# Multiple CTEs, each aliased, scalar subqueries reference alias names
test cte-alias-scalar-subquery-multiple-ctes {
    WITH a AS (SELECT 1 x), b AS (SELECT 2 y) SELECT (SELECT t1.x), (SELECT t2.y) FROM a t1, b t2;
}
expect {
    1|2
}

# =============================================================================
# Regression tests for issue #4637 — previously failing CTE cases
# =============================================================================

# CTE referenced in WHERE IN subquery with real table data
@cross-check-integrity
test cte-where-in-subquery {
    CREATE TABLE orders(id INT, amount INT);
    INSERT INTO orders VALUES(1,100),(2,200),(3,150);
    WITH high_orders AS (SELECT * FROM orders WHERE amount > 100)
    SELECT * FROM orders WHERE id IN (SELECT id FROM high_orders) ORDER BY id;
}
expect {
    2|200
    3|150
}

# Multiple CTEs cross-referenced via scalar subquery
test cte-cross-ref-scalar-subquery {
    WITH t1 AS (SELECT 1 as x), t2 AS (SELECT 2 as x)
    SELECT * FROM t1 WHERE x < (SELECT x FROM t2);
}
expect {
    1
}

# CTE self-join via explicit JOIN ON
test cte-self-join {
    WITH t AS (SELECT 1 as x UNION SELECT 2)
    SELECT * FROM t JOIN t as t2 ON t.x = t2.x ORDER BY 1;
}
expect {
    1|1
    2|2
}

# CTE used twice via comma-join with alias
test cte-comma-join-alias {
    WITH t AS (SELECT 1 as x) SELECT * FROM t, t as t2;
}
expect {
    1|1
}

# CTE in scalar subquery alongside FROM reference
test cte-scalar-and-from-ref {
    WITH t AS (SELECT 1 as x) SELECT t.x, (SELECT MAX(x) FROM t) as mx FROM t;
}
expect {
    1|1
}

# CTE in WHERE with DISTINCT and IN subquery
@cross-check-integrity
test cte-where-distinct-in {
    CREATE TABLE items(id INT, cat TEXT);
    INSERT INTO items VALUES(1,'a'),(2,'b'),(3,'a');
    WITH cats AS (SELECT DISTINCT cat FROM items WHERE cat = 'a')
    SELECT * FROM items WHERE cat IN (SELECT cat FROM cats) ORDER BY id;
}
expect {
    1|a
    3|a
}

# CTE referenced three times in cross-join
test cte-triple-ref {
    WITH t AS (SELECT 1 as x UNION SELECT 2 UNION SELECT 3)
    SELECT a.x, b.x, c.x FROM t a, t b, t c WHERE a.x = 1 AND b.x = 2 AND c.x = 3;
}
expect {
    1|2|3
}

# CTE with LEFT JOIN on self
test cte-left-join-self {
    WITH t AS (SELECT 1 as id, 'root' as name UNION SELECT 2, 'child')
    SELECT a.name, b.name FROM t a LEFT JOIN t b ON a.id <> b.id ORDER BY 1, 2;
}
expect {
    child|root
    root|child
}

# CTE in EXISTS subquery
test cte-exists-self-ref {
    WITH t AS (SELECT 1 as x) SELECT * FROM t WHERE EXISTS (SELECT 1 FROM t WHERE x = 1);
}
expect {
    1
}

# CTE in NOT EXISTS subquery
test cte-not-exists-self-ref {
    WITH t AS (SELECT 1 as x UNION SELECT 2)
    SELECT * FROM t WHERE NOT EXISTS (SELECT 1 FROM t WHERE x = 3) ORDER BY 1;
}
expect {
    1
    2
}
