@database :memory:

test group_by_no_sorting_required_reordered_columns {
    create table t0 (a INT, b INT, c INT);
    create index a_b_idx on t0 (a, b);
    insert into t0 values
    (1,1,1),
    (1,1,2),
    (2,1,3),
    (2,2,3),
    (2,2,5);
    select c, b, a from t0 group by a, b;
}
expect {
    1|1|1
    3|1|2
    3|2|2
}

test having_or {
    CREATE TABLE users (first_name TEXT, age INTEGER);
    INSERT INTO users VALUES
    ('Michael', 25), ('Michael', 50),
    ('David', 50),
    ('Sarah', 65);
    select first_name, count(*) as cnt, avg(age) as avg_age
    from users
    group by first_name
    having cnt = 2 or avg_age = 65
    order by cnt desc
}
expect {
    Michael|2|37.5
    Sarah|1|65.0
}
expect @js {
    Michael|2|37.5
    Sarah|1|65
}

# In GROUP BY clauses, column aliases take precedence when resolving identifiers to columns.
test group_by_alias_precedence {
    CREATE TABLE t(x,y);
    INSERT INTO t VALUES (1,200),(2,100);
    INSERT INTO t VALUES (1,200),(2,100);
    SELECT x AS y, SUM(y) as x FROM t GROUP BY y ORDER BY x;
}
expect {
    2|200
    1|400
}

test having_without_group_by_basic {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3), (4), (5);
    SELECT sum(a) as s FROM t HAVING s = 15;
}
expect {
    15
}

test having_without_group_by_no_match {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3), (4), (5);
    SELECT sum(a) as s FROM t HAVING s = 14;
}
expect {
}

test having_without_group_by_multiple_aggregates {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3), (4), (5);
    SELECT sum(a) as s, count(*) as c FROM t HAVING c = 5;
}
expect {
    15|5
}

test having_without_group_by_expression {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (10), (20), (30);
    SELECT sum(a) as total FROM t HAVING total > 50;
}
expect {
    60
}

test having_without_group_by_complex_condition {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3), (4), (5);
    SELECT sum(a) as s, avg(a) as av FROM t HAVING s = 15 AND av = 3;
}
expect {
    15|3.0
}
expect @js {
    15|3
}

test having_without_group_by_count {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3);
    SELECT count(*) as cnt FROM t HAVING cnt > 2;
}
expect {
    3
}

test having_without_group_by_max_min {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (5), (10), (15), (20);
    SELECT max(a) as mx, min(a) as mn FROM t HAVING mx = 20 AND mn = 5;
}
expect {
    20|5
}

test having_without_group_by_non_aggregate_error {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3);
    SELECT a FROM t HAVING a = 1;
}
expect error {
}

# Regression test: GROUP BY with constant false WHERE clause (e.g., WHERE 0)
# should return empty result set, not panic due to unopened sorter cursor.
test group_by_where_false {
    CREATE TABLE t0 (c0 INT);
    INSERT INTO t0 VALUES (1);
    SELECT c0, COUNT(*) FROM t0 WHERE 0 GROUP BY c0;
}
expect {
}

# Regression test for issue #2923: ORDER BY aggregate not in SELECT
# The ORDER BY expression uses an aggregate (max(email)) that is not mentioned
# in the SELECT clause. This requires correct expression matching between
# the ORDER BY aggregate and the computed aggregate value.
test groupby_orderby_agg_not_in_select {
    CREATE TABLE t2923 (name TEXT, value INT, email TEXT);
    INSERT INTO t2923 VALUES ('Alice', 10, 'z@example.com');
    INSERT INTO t2923 VALUES ('Alice', 20, 'a@example.com');
    INSERT INTO t2923 VALUES ('Bob', 30, 'y@example.com');
    INSERT INTO t2923 VALUES ('Bob', 40, 'b@example.com');
    SELECT name, sum(value) FROM t2923 GROUP BY name ORDER BY max(email) DESC;
}
expect {
    Alice|30
    Bob|70
}

# Regression test for issue #2923: Multiple GROUP BY and ORDER BY keys
# Tests that sort directions are copied position-by-position when GROUP BY
# and ORDER BY have the same number of expressions.
test groupby_orderby_multiple_keys {
    CREATE TABLE t2923b (a TEXT, b TEXT, value INT, email TEXT);
    INSERT INTO t2923b VALUES
        ('X', 'P', 10, 'z@test.com'),
        ('X', 'P', 20, 'a@test.com'),
        ('X', 'Q', 30, 'y@test.com'),
        ('Y', 'P', 40, 'x@test.com'),
        ('Y', 'Q', 50, 'w@test.com');
    SELECT a, b, sum(value) FROM t2923b GROUP BY a, b ORDER BY max(email) DESC, min(email) ASC;
}
expect {
    X|P|30
    X|Q|30
    Y|P|40
    Y|Q|50
}

# Regression test for issue #2923: Different number of GROUP BY vs ORDER BY keys
# When GROUP BY has more expressions than ORDER BY, the remaining keys
# should default to ascending order.
test groupby_orderby_different_key_counts {
    CREATE TABLE t2923c (a TEXT, b TEXT, value INT);
    INSERT INTO t2923c VALUES
        ('X', 'P', 10),
        ('X', 'Q', 20),
        ('Y', 'P', 30),
        ('Y', 'Q', 40);
    SELECT a, b, sum(value) FROM t2923c GROUP BY a, b ORDER BY a DESC;
}
expect {
    Y|P|30
    Y|Q|40
    X|P|10
    X|Q|20
}

# Regression test for issue #2923: Multiple keys with LIMIT
# Ensures correct results when LIMIT is applied with multiple GROUP BY
# and ORDER BY keys.
test groupby_orderby_multiple_keys_limit {
    CREATE TABLE t2923d (a TEXT, b TEXT, value INT, email TEXT);
    INSERT INTO t2923d VALUES
        ('X', 'P', 10, 'z@test.com'),
        ('X', 'P', 20, 'a@test.com'),
        ('X', 'Q', 30, 'y@test.com'),
        ('Y', 'P', 40, 'x@test.com'),
        ('Y', 'Q', 50, 'w@test.com');
    SELECT a, b, sum(value) FROM t2923d GROUP BY a, b ORDER BY max(email) DESC, min(email) ASC LIMIT 2;
}
expect {
    X|P|30
    X|Q|30
}

# Regression test for issue #2923: ORDER BY has more expressions than GROUP BY
# When counts differ, falls through to expression-matching logic.
test groupby_orderby_more_orderby_keys {
    CREATE TABLE t2923e (a TEXT, value INT, email TEXT);
    INSERT INTO t2923e VALUES
        ('X', 10, 'z@test.com'),
        ('X', 20, 'a@test.com'),
        ('Y', 30, 'y@test.com'),
        ('Y', 40, 'b@test.com');
    SELECT a, sum(value) FROM t2923e GROUP BY a ORDER BY max(email) DESC, min(email) ASC;
}
expect {
    X|30
    Y|70
}

# Regression test for issue #2923: Same column in both GROUP BY and ORDER BY
# Tests position-by-position copying when GROUP BY column also appears in ORDER BY.
test groupby_orderby_same_column_in_both {
    CREATE TABLE t2923f (a TEXT, value INT, email TEXT);
    INSERT INTO t2923f VALUES
        ('X', 10, 'z@test.com'),
        ('X', 20, 'a@test.com'),
        ('Y', 30, 'y@test.com'),
        ('Y', 40, 'b@test.com');
    SELECT a, sum(value) FROM t2923f GROUP BY a ORDER BY a DESC, max(email) DESC;
}
expect {
    Y|70
    X|30
}

# Regression: GROUP BY with more columns than ORDER BY DESC + LIMIT/OFFSET
# When the optimizer reorders GROUP BY exprs to put ORDER BY columns first,
# the sort_order for remaining GROUP BY columns (not in ORDER BY) must
# default to ASC. Previously they kept stale values from the pre-reorder
# sort_order, causing incorrect tie-breaking within equal ORDER BY groups.
test groupby_desc_tiebreak_extra_columns {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t VALUES (1, 'x'), (2, 'x'), (3, 'x'), (4, 'y'), (5, 'z');
    SELECT a, GROUP_CONCAT(a) FROM t GROUP BY a, b ORDER BY b DESC;
}
expect {
    5|5
    4|4
    1|1
    2|2
    3|3
}

test groupby_desc_tiebreak_extra_columns_limit_offset {
    CREATE TABLE t(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t VALUES (1, 'x'), (2, 'x'), (3, 'x'), (4, 'y'), (5, 'z');
    SELECT a, GROUP_CONCAT(a) FROM t GROUP BY a, b ORDER BY b DESC LIMIT 4 OFFSET 1;
}
expect {
    4|4
    1|1
    2|2
    3|3
}
