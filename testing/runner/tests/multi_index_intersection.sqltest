@database :memory:

setup multi_index_schema {
    CREATE TABLE t(id INTEGER PRIMARY KEY, a INTEGER, b INTEGER, c INTEGER, d INTEGER);
    CREATE INDEX idx_a ON t(a);
    CREATE INDEX idx_b ON t(b);
    CREATE INDEX idx_c ON t(c);
    CREATE INDEX idx_d ON t(d);
    INSERT INTO t VALUES (1, 10, 100, 1000, 10000);
    INSERT INTO t VALUES (2, 20, 200, 2000, 20000);
    INSERT INTO t VALUES (3, 10, 100, 3000, 30000);
}

# 2-way multi-index intersection (AND with 2 indexed columns)
@setup multi_index_schema
test multi-index-and-2-way {
    SELECT * FROM t WHERE a = 10 AND b = 100;
}
expect {
    1|10|100|1000|10000
    3|10|100|3000|30000
}

# 3-way multi-index intersection (AND with 3 indexed columns)
# Regression test for #5285: panic on 3+ way MULTI-INDEX AND
@setup multi_index_schema
test multi-index-and-3-way {
    SELECT * FROM t WHERE a = 10 AND b = 100 AND c = 1000;
}
expect {
    1|10|100|1000|10000
}

# 4-way multi-index intersection (AND with 4 indexed columns)
@setup multi_index_schema
test multi-index-and-4-way {
    SELECT * FROM t WHERE a = 10 AND b = 100 AND c = 1000 AND d = 10000;
}
expect {
    1|10|100|1000|10000
}

# 3-way multi-index intersection with no matching rows
@setup multi_index_schema
test multi-index-and-3-way-no-match {
    SELECT * FROM t WHERE a = 10 AND b = 200 AND c = 1000;
}
expect {
}

# Correlated subquery tests for multi-index AND
# Regression tests for #5284: MULTI-INDEX AND in correlated subqueries
# returned empty results due to stale RowSet state between outer loop iterations

setup correlated_schema {
    CREATE TABLE t(id INTEGER PRIMARY KEY, val INTEGER, grp TEXT);
    CREATE INDEX idx_val ON t(val);
    CREATE INDEX idx_grp ON t(grp);
    INSERT INTO t VALUES (1, 10, 'A'), (2, 20, 'A'), (3, 30, 'B'),
                         (4, 40, 'B'), (5, 50, 'C'), (6, 60, 'C');
}

# EXISTS with MULTI-INDEX AND in correlated subquery
@setup correlated_schema
test multi-index-and-correlated-exists {
    SELECT COUNT(*) FROM t a
    WHERE EXISTS (SELECT 1 FROM t b WHERE b.grp = a.grp AND b.val = 30);
}
expect {
    2
}

# NOT EXISTS with MULTI-INDEX AND in correlated subquery
@setup correlated_schema
test multi-index-and-correlated-not-exists {
    SELECT COUNT(*) FROM t a
    WHERE NOT EXISTS (SELECT 1 FROM t b WHERE b.grp = a.grp AND b.val = 30);
}
expect {
    4
}

# EXISTS returning matching rows
@setup correlated_schema
test multi-index-and-correlated-exists-rows {
    SELECT a.id, a.grp FROM t a
    WHERE EXISTS (SELECT 1 FROM t b WHERE b.grp = a.grp AND b.val = 30)
    ORDER BY a.id;
}
expect {
    3|B
    4|B
}

# Scalar correlated subquery with MULTI-INDEX AND
@setup correlated_schema
test multi-index-and-correlated-scalar {
    SELECT a.id, (SELECT b.val FROM t b WHERE b.grp = a.grp AND b.val = 30) FROM t a
    ORDER BY a.id;
}
expect {
    1|
    2|
    3|30
    4|30
    5|
    6|
}
