@database :memory:

# =============================================================================
# ON CONFLICT clause tests for INSERT and UPDATE statements
# Tests all five resolve types: ABORT, ROLLBACK, FAIL, IGNORE, REPLACE
# =============================================================================

# =============================================================================
# INSERT OR ABORT tests (default behavior)
# =============================================================================

# ABORT is the default - rolls back the statement on constraint violation

@cross-check-integrity
test insert-or-abort-notnull {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b NOT NULL);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR ABORT INTO t1 VALUES (2, NULL);
}
expect error {
}

@cross-check-integrity
test insert-or-abort-notnull-verify-rollback {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b NOT NULL);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR ABORT INTO t1 VALUES (2, NULL);
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

@cross-check-integrity
test insert-or-abort-unique {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR ABORT INTO t1 VALUES (2, 'one');
}
expect error {
}

@cross-check-integrity
test insert-or-abort-pk {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR ABORT INTO t1 VALUES (1, 'duplicate');
}
expect error {
}

# =============================================================================
# INSERT OR IGNORE tests
# =============================================================================

# IGNORE skips the row that would cause a constraint violation

@cross-check-integrity
test insert-or-ignore-notnull {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b NOT NULL);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR IGNORE INTO t1 VALUES (2, NULL);
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
}

@cross-check-integrity
test insert-or-ignore-unique {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR IGNORE INTO t1 VALUES (2, 'one');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
}

@cross-check-integrity
test insert-or-ignore-pk {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR IGNORE INTO t1 VALUES (1, 'duplicate');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
}

@cross-check-integrity
test insert-or-ignore-continue-after-skip {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR IGNORE INTO t1 VALUES (2, 'one'), (3, 'three'), (4, 'one');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    3|three
}

@cross-check-integrity
test insert-or-ignore-no-conflict {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT NOT NULL);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR IGNORE INTO t1 VALUES (2, 'two');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|two
}

# =============================================================================
# INSERT OR REPLACE tests
# =============================================================================

# REPLACE deletes conflicting rows before inserting the new row

@cross-check-integrity
test insert-or-replace-unique {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR REPLACE INTO t1 VALUES (2, 'one');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    2|one
}

@cross-check-integrity
test insert-or-replace-pk {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR REPLACE INTO t1 VALUES (1, 'replaced');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|replaced
}

@cross-check-integrity
test insert-or-replace-notnull-with-default {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT NOT NULL DEFAULT 'default_val');
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR REPLACE INTO t1(a) VALUES (2);
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|default_val
}

@cross-check-integrity
test insert-or-replace-notnull-no-default {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT NOT NULL);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR REPLACE INTO t1(a) VALUES (2);
}
expect error {
}

@cross-check-integrity
test insert-or-replace-multiple-conflicts {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE, c TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'b1', 'c1');
    INSERT INTO t1 VALUES (2, 'b2', 'c2');
    INSERT OR REPLACE INTO t1 VALUES (3, 'b1', 'c2');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    3|b1|c2
}

@cross-check-integrity
test insert-or-replace-no-conflict {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR REPLACE INTO t1 VALUES (2, 'two');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|two
}

# INSERT OR REPLACE should preserve user values for multiple NOT NULL DEFAULT columns

@cross-check-integrity
test insert-or-replace-multi-notnull-default {
    CREATE TABLE t1(
        id INTEGER PRIMARY KEY,
        val INTEGER NOT NULL DEFAULT 42,
        name TEXT NOT NULL DEFAULT 'unnamed'
    );
    INSERT OR REPLACE INTO t1 VALUES (1, 100, 'hello');
    SELECT * FROM t1;
}
expect {
    1|100|hello
}

@cross-check-integrity
test insert-or-replace-multi-notnull-default-many-cols {
    CREATE TABLE t1(id INTEGER PRIMARY KEY,
        a TEXT NOT NULL DEFAULT 'da',
        b TEXT NOT NULL DEFAULT 'db',
        c TEXT NOT NULL DEFAULT 'dc');
    INSERT OR REPLACE INTO t1 VALUES (1, 'one', 'two', 'three');
    SELECT * FROM t1;
}
expect {
    1|one|two|three
}

# INSERT OR REPLACE must not bypass CHECK constraints via default substitution

@cross-check-integrity
test insert-or-replace-notnull-default-respects-check {
    CREATE TABLE t1(
        id INTEGER PRIMARY KEY,
        a INTEGER NOT NULL DEFAULT 999 CHECK(a < 100),
        b INTEGER NOT NULL DEFAULT 999 CHECK(b < 100)
    );
    INSERT OR REPLACE INTO t1 VALUES (1, 10, 20);
    SELECT * FROM t1;
}
expect {
    1|10|20
}

# INSERT OR REPLACE must keep index and table data consistent for NOT NULL DEFAULT UNIQUE columns

@cross-check-integrity
test insert-or-replace-notnull-default-unique-index-consistent {
    CREATE TABLE t1(
        id INTEGER PRIMARY KEY,
        a INTEGER NOT NULL DEFAULT 42,
        b INTEGER NOT NULL DEFAULT 42 UNIQUE
    );
    INSERT INTO t1 VALUES (1, 10, 42);
    INSERT OR REPLACE INTO t1 VALUES (2, 20, 99);
    SELECT * FROM t1 WHERE b = 99;
}
expect {
    2|20|99
}

# INSERT OR REPLACE ... SELECT should also preserve user values for NOT NULL DEFAULT columns

@cross-check-integrity
test insert-or-replace-select-multi-notnull-default {
    CREATE TABLE src(id INTEGER PRIMARY KEY, val INTEGER, name TEXT);
    INSERT INTO src VALUES (1, 100, 'hello');
    CREATE TABLE dst(
        id INTEGER PRIMARY KEY,
        val INTEGER NOT NULL DEFAULT 42,
        name TEXT NOT NULL DEFAULT 'unnamed'
    );
    INSERT OR REPLACE INTO dst SELECT * FROM src;
    SELECT * FROM dst;
}
expect {
    1|100|hello
}

# =============================================================================
# INSERT OR ROLLBACK tests
# =============================================================================

# ROLLBACK rolls back the entire transaction, not just the statement

@cross-check-integrity
test insert-or-rollback-autocommit {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR ROLLBACK INTO t1 VALUES (2, 'one');
}
expect error {
}

@cross-check-integrity
test insert-or-rollback-autocommit-no-partial {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR ROLLBACK INTO t1 VALUES (2, 'one');
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

@cross-check-integrity
test insert-or-rollback-in-transaction {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    BEGIN;
    INSERT INTO t1 VALUES (2, 'two');
    INSERT OR ROLLBACK INTO t1 VALUES (3, 'one');
}
expect error {
}

@cross-check-integrity
test insert-or-rollback-rolls-back-entire-tx {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    BEGIN;
    INSERT INTO t1 VALUES (2, 'two');
    INSERT OR ROLLBACK INTO t1 VALUES (3, 'one');
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

# After ROLLBACK error, should only see original data
@cross-check-integrity
test insert-or-rollback-verify-state-after-error {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
}

# =============================================================================
# INSERT OR FAIL tests
# =============================================================================

# FAIL aborts current statement but doesn't rollback changes already made

@cross-check-integrity
test insert-or-fail-autocommit {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR FAIL INTO t1 VALUES (2, 'one');
}
expect error {
}

@cross-check-integrity
test insert-or-fail-keeps-prior-changes {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR FAIL INTO t1 VALUES (2, 'two'), (3, 'one'), (4, 'four');
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

# FAIL in multi-row insert keeps rows before the failure
@cross-check-integrity
test insert-or-fail-partial-insert {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT OR FAIL INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'one'), (4, 'four');
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

@cross-check-integrity
test insert-or-fail-in-transaction {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    BEGIN;
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR FAIL INTO t1 VALUES (2, 'one');
}
expect error {
}

# FAIL in transaction - earlier changes persist, transaction still active
@cross-check-integrity
test insert-or-fail-tx-still-active {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    BEGIN;
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR FAIL INTO t1 VALUES (2, 'one');
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

# =============================================================================
# UPDATE OR IGNORE tests
# =============================================================================

# UPDATE OR IGNORE with NOT NULL violation should skip the row

@cross-check-integrity
test update-or-ignore-notnull {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b NOT NULL);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR IGNORE t1 SET b = NULL WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|two
    3|three
}

# UPDATE OR IGNORE with UNIQUE violation should skip the row

@cross-check-integrity
test update-or-ignore-unique {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR IGNORE t1 SET b = 'one' WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|two
    3|three
}

# UPDATE OR IGNORE with PRIMARY KEY violation (rowid update) should skip

@cross-check-integrity
test update-or-ignore-pk {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR IGNORE t1 SET a = 1 WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|two
    3|three
}

# UPDATE OR IGNORE with no conflict should proceed normally

@cross-check-integrity
test update-or-ignore-no-conflict {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT NOT NULL);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR IGNORE t1 SET b = 'updated' WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|updated
    3|three
}

# UPDATE OR IGNORE should continue processing other rows after skipping

@cross-check-integrity
test update-or-ignore-continue {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR IGNORE t1 SET b = 'one' WHERE a IN (2, 3);
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|two
    3|three
}

# UPDATE OR IGNORE - multiple rows, some skip, some succeed

@cross-check-integrity
test update-or-ignore-partial-update {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three'), (4, 'four');
    UPDATE OR IGNORE t1 SET b = 'one' WHERE a >= 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|two
    3|three
    4|four
}

# =============================================================================
# UPDATE OR ABORT tests (default behavior)
# =============================================================================

@cross-check-integrity
test update-or-abort-notnull {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b NOT NULL);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two');
    UPDATE OR ABORT t1 SET b = NULL WHERE a = 1;
}
expect error {
}

# UPDATE OR ABORT with UNIQUE violation should fail

@cross-check-integrity
test update-or-abort-unique {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two');
    UPDATE OR ABORT t1 SET b = 'one' WHERE a = 2;
}
expect error {
}

@cross-check-integrity
test update-or-abort-pk {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two');
    UPDATE OR ABORT t1 SET a = 1 WHERE a = 2;
}
expect error {
}

# UPDATE OR ABORT should rollback statement changes when conflict occurs

@cross-check-integrity
test update-or-abort-rollback-statement {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b INTEGER UNIQUE);
    INSERT INTO t1 VALUES (1, 10), (2, 20), (3, 30);
    UPDATE OR ABORT t1 SET b = 10 WHERE a > 1;
}
expect error {
}

# =============================================================================
# UPDATE OR REPLACE tests
# =============================================================================

# UPDATE OR REPLACE with UNIQUE violation should delete the conflicting row

@cross-check-integrity
test update-or-replace-unique {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR REPLACE t1 SET b = 'one' WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    2|one
    3|three
}

# UPDATE OR REPLACE with NOT NULL violation and default value should use default

@cross-check-integrity
test update-or-replace-notnull-default {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT NOT NULL DEFAULT 'default_val');
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two');
    UPDATE OR REPLACE t1 SET b = NULL WHERE a = 1;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|default_val
    2|two
}

# UPDATE OR REPLACE with NOT NULL violation and no default should fail

@cross-check-integrity
test update-or-replace-notnull-no-default {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT NOT NULL);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two');
    UPDATE OR REPLACE t1 SET b = NULL WHERE a = 1;
}
expect error {
}

# UPDATE OR REPLACE with PRIMARY KEY conflict should delete conflicting row

@cross-check-integrity
test update-or-replace-pk {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR REPLACE t1 SET a = 1 WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|two
    3|three
}

# UPDATE OR REPLACE with no conflict should proceed normally

@cross-check-integrity
test update-or-replace-no-conflict {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR REPLACE t1 SET b = 'new_value' WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    2|new_value
    3|three
}

# UPDATE OR REPLACE - multiple conflicts resolved by deletion

@cross-check-integrity
test update-or-replace-multiple-conflicts {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE, c TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'b1', 'c1');
    INSERT INTO t1 VALUES (2, 'b2', 'c2');
    INSERT INTO t1 VALUES (3, 'b3', 'c3');
    UPDATE OR REPLACE t1 SET b = 'b1', c = 'c2' WHERE a = 3;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    3|b1|c2
}

# =============================================================================
# UPDATE OR ROLLBACK tests
# =============================================================================

@cross-check-integrity
test update-or-rollback-autocommit {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two');
    UPDATE OR ROLLBACK t1 SET b = 'one' WHERE a = 2;
}
expect error {
}

@cross-check-integrity
test update-or-rollback-in-transaction {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    BEGIN;
    INSERT INTO t1 VALUES (2, 'two');
    UPDATE OR ROLLBACK t1 SET b = 'one' WHERE a = 2;
}
expect error {
}

# ROLLBACK rolls back entire transaction
@cross-check-integrity
test update-or-rollback-entire-tx-rolled-back {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    BEGIN;
    INSERT INTO t1 VALUES (2, 'two');
    UPDATE OR ROLLBACK t1 SET b = 'one' WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

# After ROLLBACK error in tx, only original data visible
@cross-check-integrity
test update-or-rollback-verify-state {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
}

# =============================================================================
# UPDATE OR FAIL tests
# =============================================================================

@cross-check-integrity
test update-or-fail-autocommit {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two');
    UPDATE OR FAIL t1 SET b = 'one' WHERE a = 2;
}
expect error {
}

@cross-check-integrity
test update-or-fail-in-transaction {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    BEGIN;
    INSERT INTO t1 VALUES (2, 'two');
    UPDATE OR FAIL t1 SET b = 'one' WHERE a = 2;
}
expect error {
}

# FAIL keeps prior changes in the statement
@cross-check-integrity
test update-or-fail-partial-update {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b INTEGER UNIQUE);
    INSERT INTO t1 VALUES (1, 10), (2, 20), (3, 30), (4, 40);
    UPDATE OR FAIL t1 SET b = 10 WHERE a >= 2;
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

# FAIL in transaction - tx stays open with prior changes
@cross-check-integrity
test update-or-fail-tx-stays-active {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    BEGIN;
    INSERT INTO t1 VALUES (2, 'two');
    UPDATE OR FAIL t1 SET b = 'one' WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect error {
}

# =============================================================================
# Foreign key constraints are NOT affected by ON CONFLICT
# =============================================================================

# FK errors always behave like ABORT, regardless of ON CONFLICT clause

@cross-check-integrity
test insert-or-ignore-fk-still-fails {
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id INTEGER REFERENCES parent(id));
    INSERT INTO parent VALUES (1);
    PRAGMA foreign_keys = ON;
    INSERT OR IGNORE INTO child VALUES (1, 999);
}
expect error {
}

@cross-check-integrity
test insert-or-replace-fk-still-fails {
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id INTEGER REFERENCES parent(id));
    INSERT INTO parent VALUES (1);
    PRAGMA foreign_keys = ON;
    INSERT OR REPLACE INTO child VALUES (1, 999);
}
expect error {
}

@cross-check-integrity
test update-or-ignore-fk-still-fails {
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id INTEGER REFERENCES parent(id));
    INSERT INTO parent VALUES (1);
    INSERT INTO child VALUES (1, 1);
    PRAGMA foreign_keys = ON;
    UPDATE OR IGNORE child SET parent_id = 999 WHERE id = 1;
}
expect error {
}

@cross-check-integrity
test update-or-replace-fk-still-fails {
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id INTEGER REFERENCES parent(id));
    INSERT INTO parent VALUES (1);
    INSERT INTO child VALUES (1, 1);
    PRAGMA foreign_keys = ON;
    UPDATE OR REPLACE child SET parent_id = 999 WHERE id = 1;
}
expect error {
}

@cross-check-integrity
test insert-or-fail-fk-still-fails {
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id INTEGER REFERENCES parent(id));
    INSERT INTO parent VALUES (1);
    PRAGMA foreign_keys = ON;
    INSERT OR FAIL INTO child VALUES (1, 999);
}
expect error {
}

@cross-check-integrity
test insert-or-rollback-fk-still-fails {
    CREATE TABLE parent(id INTEGER PRIMARY KEY);
    CREATE TABLE child(id INTEGER PRIMARY KEY, parent_id INTEGER REFERENCES parent(id));
    INSERT INTO parent VALUES (1);
    PRAGMA foreign_keys = ON;
    INSERT OR ROLLBACK INTO child VALUES (1, 999);
}
expect error {
}

# =============================================================================
# Edge cases and complex scenarios
# =============================================================================

# Multiple constraint violations in single row - first encountered wins

@cross-check-integrity
test multiple-constraints-first-wins {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b NOT NULL, c UNIQUE);
    INSERT INTO t1 VALUES (1, 'one', 'c1');
    INSERT OR IGNORE INTO t1 VALUES (2, NULL, 'c1');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one|c1
}

# UPDATE affecting multiple rows with constraint violation

@cross-check-integrity
test update-multiple-rows-one-fails {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b INTEGER UNIQUE);
    INSERT INTO t1 VALUES (1, 10), (2, 20), (3, 30);
    UPDATE OR ABORT t1 SET b = 10 WHERE a > 1;
}
expect error {
}

# INSERT with SELECT and ON CONFLICT

@cross-check-integrity
test insert-select-or-ignore {
    CREATE TABLE src(a INTEGER, b TEXT);
    CREATE TABLE dst(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO src VALUES (1, 'one'), (2, 'one'), (3, 'three');
    INSERT INTO dst VALUES (10, 'existing');
    INSERT OR IGNORE INTO dst SELECT * FROM src;
    SELECT * FROM dst ORDER BY a;
}
expect {
    1|one
    3|three
    10|existing
}

@cross-check-integrity
test insert-select-or-replace {
    CREATE TABLE src(a INTEGER, b TEXT);
    CREATE TABLE dst(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO src VALUES (1, 'one'), (2, 'one'), (3, 'three');
    INSERT INTO dst VALUES (10, 'one');
    INSERT OR REPLACE INTO dst SELECT * FROM src;
    SELECT * FROM dst ORDER BY a;
}
expect {
    2|one
    3|three
}

# Empty result - no violations

@cross-check-integrity
test insert-or-ignore-empty {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT OR IGNORE INTO t1 SELECT * FROM t1;
    SELECT * FROM t1;
}
expect {
}

# Self-referential update with constraint

@cross-check-integrity
test self-ref-update-or-ignore {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b INTEGER UNIQUE);
    INSERT INTO t1 VALUES (1, 10), (2, 20);
    UPDATE OR IGNORE t1 SET b = a * 10 WHERE a = 2;
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|10
    2|20
}

# RETURNING with ON CONFLICT

@cross-check-integrity
test insert-or-ignore-returning {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR IGNORE INTO t1 VALUES (2, 'one'), (3, 'three') RETURNING a, b;
}
expect {
    3|three
}

@cross-check-integrity
test insert-or-replace-returning {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one');
    INSERT OR REPLACE INTO t1 VALUES (2, 'one') RETURNING a, b;
}
expect {
    2|one
}

@cross-check-integrity
test update-or-ignore-returning {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR IGNORE t1 SET b = 'one' WHERE a >= 2 RETURNING a, b;
}
expect {
}

@cross-check-integrity
test update-or-replace-returning {
    CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT UNIQUE);
    INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
    UPDATE OR REPLACE t1 SET b = 'one' WHERE a = 2 RETURNING a, b;
}
expect {
    2|one
}

# =============================================================================
# Autoincrement with ON CONFLICT
# =============================================================================

@cross-check-integrity
test insert-or-ignore-autoincrement {
    CREATE TABLE t1(a INTEGER PRIMARY KEY AUTOINCREMENT, b TEXT UNIQUE);
    INSERT INTO t1(b) VALUES ('one');
    INSERT OR IGNORE INTO t1(b) VALUES ('one');
    INSERT INTO t1(b) VALUES ('three');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    1|one
    3|three
}

@cross-check-integrity
test insert-or-replace-autoincrement {
    CREATE TABLE t1(a INTEGER PRIMARY KEY AUTOINCREMENT, b TEXT UNIQUE);
    INSERT INTO t1(b) VALUES ('one');
    INSERT OR REPLACE INTO t1(b) VALUES ('one');
    SELECT * FROM t1 ORDER BY a;
}
expect {
    2|one
}
