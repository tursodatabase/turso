@database :default:
@database :default-no-rowidalias:

test json5-ecma-script-1 {
    select json('{a:5,b:6}') ;
}
expect {
    {"a":5,"b":6}
}

test json5-ecma-script-2 {
    select json('{a:5,a:3}') ;
}
expect {
    {"a":5,"a":3}
}

test json5-ecma-script-3 {
    SELECT json('{ MNO_123$xyz : 789 }');
}
expect {
    {"MNO_123$xyz":789}
}

test json5-with-single-trailing-comma-valid {
    select json('{"a":5, "b":6, }');
}
expect {
    {"a":5,"b":6}
}

test json5-single-quoted {
    SELECT json('{"a": ''abcd''}');
}
expect {
    {"a":"abcd"}
}

test json5-hexadecimal-1 {
    SELECT json('{a: 0x0}')
}
expect {
    {"a":0}
}

test json5-hexadecimal-2 {
    SELECT json('{a: 0xabcdef}')
}
expect {
    {"a":11259375}
}

test json5-hexadecimal-2-2 {
    SELECT json('{a: -0xabcdef}')
}
expect {
    {"a":-11259375}
}

test json5-number-1 {
    SELECT json('{x: 4.}')
}
expect {
    {"x":4.0}
}

test json5-number-2 {
    SELECT json('{x: +4.}')
}
expect {
    {"x":4.0}
}

test json5-number-3 {
    SELECT json('{x: -4.}')
}
expect {
    {"x":-4.0}
}

test json5-number-5 {
    SELECT json('{x: Infinity}')
}
expect {
    {"x":9e999}
}

test json5-number-6 {
    SELECT json('{x: -Infinity}')
}
expect {
    {"x":-9e999}
}

test json5-multi-comment {
    SELECT json(' /* abc */ { /*def*/ aaa /* xyz */ : // to the end of line
    123 /* xyz */ , /* 123 */ }')
}
expect {
    {"aaa":123}
}

test json5-ecma-script-1-pretty {
    select json_pretty('{a:5,b:6}') ;
}
expect raw {
\{
    "a": 5,
    "b": 6
\}
}

test json5-ecma-script-2-pretty {
    select json_pretty('{a:5,a:3}') ;
}
expect raw {
\{
    "a": 5,
    "a": 3
\}
}

test json5-ecma-script-3-pretty {
    SELECT json_pretty('{ MNO_123$xyz : 789 }');
}
expect raw {
\{
    "MNO_123$xyz": 789
\}
}

test json5-with-single-trailing-comma-valid-pretty {
    select json_pretty('{"a":5, "b":6, }');
}
expect raw {
\{
    "a": 5,
    "b": 6
\}
}

test json5-single-quoted-pretty {
    SELECT json_pretty('{"a": ''abcd''}');
}
expect raw {
\{
    "a": "abcd"
\}
}

test json5-hexadecimal-1-pretty {
    SELECT json_pretty('{a: 0x0}');
}
expect raw {
\{
    "a": 0
\}
}

test json5-hexadecimal-2-pretty {
    SELECT json_pretty('{a: 0xabcdef}');
}
expect raw {
\{
    "a": 11259375
\}
}

test json5-hexadecimal-2-pretty-2 {
    SELECT json_pretty('{a: -0xabcdef}');
}
expect raw {
\{
    "a": -11259375
\}
}

test json5-number-1-pretty {
    SELECT json_pretty('{x: 4.}');
}
expect raw {
\{
    "x": 4.0
\}
}

test json5-number-2-pretty {
    SELECT json_pretty('{x: +4.}');
}
expect raw {
\{
    "x": 4.0
\}
}

test json5-number-3-pretty {
    SELECT json_pretty('{x: -4.}');
}
expect raw {
\{
    "x": -4.0
\}
}

test json5-number-5-pretty {
    SELECT json_pretty('{x: Infinity}');
}
expect raw {
\{
    "x": 9e999
\}
}

test json5-number-6-pretty {
    SELECT json_pretty('{x: -Infinity}');
}
expect raw {
\{
    "x": -9e999
\}
}

test json5-multi-comment-pretty {
    SELECT json_pretty(' /* abc */ { /*def*/ aaa /* xyz */ : // to the end of line
    123 /* xyz */ , /* 123 */ }');
}
expect raw {
\{
    "aaa": 123
\}
}

test json-pretty-ident-1 {
    SELECT json_pretty('{x: 1}', '');
}
expect raw {
\{
"x": 1
\}
}

test json-pretty-ident-2 {
    SELECT json_pretty('{x: 1}', '11');
}
expect raw {
\{
11"x": 1
\}
}

test json-pretty-ident-null {
    SELECT json_pretty('{x: 1}', NULL);
}
expect raw {
\{
    "x": 1
\}
}

test json-pretty-ident-blob-1 {
    SELECT json_pretty('{x: 1}', x'33');
}
expect raw {
\{
3"x": 1
\}
}

# TODO
# Currently conversion from blob to string is not exactly the same as in sqlite.
# The blob below should evaluate to two whitespaces TEXT value
# do_execsql_test json-pretty-ident-blob-2 {
#    SELECT json_pretty('{x: 1}', x'1111');
# } {{{
#   "x": 1
# }}}
test json_array_str {
    SELECT json_array('a')
}
expect {
    ["a"]
}

test json_array_numbers {
    SELECT json_array(1, 1.5)
}
expect {
    [1,1.5]
}

test json_array_numbers_2 {
    SELECT json_array(1., +2., -2.)
}
expect {
    [1.0,2.0,-2.0]
}

test json_array_null {
    SELECT json_array(null)
}
expect {
    [null]
}

test json_array_not_json {
    SELECT json_array('{"a":1}')
}
expect {
    ["{\"a\":1}"]
}

test json_array_json {
    SELECT json_array(json('{"a":1}'))
}
expect {
    [{"a":1}]
}

test json_array_nested {
    SELECT json_array(json_array(1,2,3), json('[1,2,3]'), '[1,2,3]')
}
expect {
    [[1,2,3],[1,2,3],"[1,2,3]"]
}

test json_array_infinity {
    SELECT json_array(1e309);
}
expect {
    [9.0e+999]
}

test json_array_negative_infinity {
    SELECT json_array(-1e309);
}
expect {
    [-9.0e+999]
}

test json_bare_infinity {
    SELECT json(1e309);
}
expect {
    9e999
}

test json_bare_negative_infinity {
    SELECT json(-1e309);
}
expect {
    -9e999
}

test json_extract_malformed_json_1 {
		SELECT json_extract(X'256162', '$');
}
expect error {
    .*malformed JSON.*
}

test json_extract_malformed_json_2 {
		SELECT json_extract(X'45312e652b', '$');
}
expect error {
    .*malformed JSON.*
}

test json_extract_malformed_json_3 {
		SELECT json_extract(X'35312e2e31', '$');
}
expect error {
    .*malformed JSON.*
}

test json_extract_malformed_json_4 {
		SELECT json_extract(X'266162', '$');
}
expect error {
    .*malformed JSON.*
}

test json_extract_null {
    SELECT json_extract(null, '$')
}
expect {
}

test json_extract_json_null_type {
    SELECT typeof(json_extract('null', '$'))
}
expect {
    null
}

test json_arrow_json_null_type {
    SELECT typeof('null' -> '$')
}
expect {
    text
}

test json_arrow_shift_json_null_type {
    SELECT typeof('null' ->> '$')
}
expect {
    null
}

test json_extract_empty {
    SELECT json_extract()
}
expect {
}

test json_extract_single_param {
    SELECT json_extract(1)
}
expect {
}

test json_extract_null_invalid_path {
    SELECT json_extract(null, 1)
}
expect {
}

test json_extract_null_invalid_path_2 {
    SELECT json_extract(null, CAST(1 AS BLOB))
}
expect {
}

test json_extract_multiple_nulls {
    SELECT json_extract(null, CAST(1 AS BLOB), null, 1, 2, 3)
}
expect {
}

test json_extract_number {
    SELECT json_extract(1, '$')
}
expect {
    1
}

test json_extract_number_type {
    SELECT typeof(json_extract(1, '$'))
}
expect {
    integer
}

test json_arrow_number {
    SELECT 1 -> '$'
}
expect {
    1
}

test json_arrow_number_type {
    SELECT typeof(1 -> '$')
}
expect {
    text
}

test json_arrow_shift_number {
    SELECT 1 -> '$'
}
expect {
    1
}

test json_arrow_shift_number_type {
    SELECT typeof(1 ->> '$')
}
expect {
    integer
}

test json_extract_object_1 {
    SELECT json_extract('{"a": [1,2,3]}', '$.a')
}
expect {
    [1,2,3]
}

test json_arrow_object {
    SELECT '{"a": [1,2,3]}' -> '$.a'
}
expect {
    [1,2,3]
}

test json_arrow_blob_object {
    SELECT cast('{"age":30,"name":"John"}' as blob) -> '$.age'
}
expect {
    30
}

# Tests against valid jsonb [b'{',.., b'}'] vs json text '{..}'
# b'{' = ElementType::Array, PayloadSize of 7.
# b'}' = last element in array ends in '}'
# x'7B0707070707177D' = jsonb(["", "", "", "", "", "}"])
test json_arrow_blob_array {
    SELECT x'7B0707070707177D' -> '$[5]'
}
expect {
    "\}"
}

# Tests against valid jsonb [b'[',.., b']'] vs json text '[..]'
# b'[' = ElementType::Array, PayloadSize of 5.
# b']' = last element in array ends in ']'
# x'5B070707175D' = jsonb(["", "", "", "}"])
test json_arrow_blob_array_2 {
    SELECT x'5B070707175D' -> '$[3]'
}
expect {
    "]"
}

test json_arrow_blob_number {
    SELECT cast('4' as blob) -> '$'
}
expect {
    4
}

test json_arrow_blob_number_2 {
    SELECT cast(33 as blob) -> '$'
}
expect {
    33
}

# jsonb(333)
test json_arrow_blob_number_3 {
    SELECT x'33333333' -> '$'
}
expect {
    333
}

test json_arrow_blob_negative_number {
    SELECT cast('-4' as blob) -> '$'
}
expect {
    -4
}

test json_arrow_shift_blob {
    SELECT cast('{"age":30,"name":"John"}' as blob) ->> '$.age'
}
expect {
    30
}

test json_extract_object_2 {
    SELECT json_extract('{"a": [1,2,3]}', '$.a', '$.a[0]', '$.a[1]', '$.a[3]')
}
expect {
    [[1,2,3],1,2,null]
}

test json_extract_object_3 {
    SELECT json_extract('{"a": [1,2,3]}', '$.a', '$.a[0]', '$.a[1]', null, '$.a[3]')
}
expect {
}

#       \x61 is the ASCII code for 'a'
test json_extract_with_escaping {
    SELECT json_extract('{"\x61": 1}', '$.a')
}
expect {
    1
}

test json_extract_with_escaping_2 {
    SELECT json_extract('{"a": 1}', '$."\x61"')
}
expect {
    1
}

test json_extract_null_path {
    SELECT json_extract(1, null)
}
expect {
}

test json_arrow_null_path {
    SELECT 1 -> null
}
expect {
}

test json_arrow_shift_null_path {
    SELECT 1 ->> null
}
expect {
}

test json_extract_float {
    SELECT typeof(json_extract(1.0, '$'))
}
expect {
    real
}

test json_arrow_float {
    SELECT typeof(1.0 -> '$')
}
expect {
    text
}

test json_arrow_shift_float {
    SELECT typeof(1.0 ->> '$')
}
expect {
    real
}

test json_extract_true {
    SELECT json_extract('true', '$')
}
expect {
    1
}

test json_extract_true_type {
    SELECT typeof(json_extract('true', '$'))
}
expect {
    integer
}

test json_arrow_true {
    SELECT 'true' -> '$'
}
expect {
    true
}

test json_arrow_true_type {
    SELECT typeof('true' -> '$')
}
expect {
    text
}

test json_arrow_shift_true {
    SELECT 'true' ->> '$'
}
expect {
    1
}

test json_arrow_shift_true_type {
    SELECT typeof('true' ->> '$')
}
expect {
    integer
}

test json_extract_false {
    SELECT json_extract('false', '$')
}
expect {
    0
}

test json_extract_false_type {
    SELECT typeof(json_extract('false', '$'))
}
expect {
    integer
}

test json_arrow_false {
    SELECT 'false' -> '$'
}
expect {
    false
}

test json_arrow_false_type {
    SELECT typeof('false' -> '$')
}
expect {
    text
}

test json_arrow_shift_false {
    SELECT 'false' ->> '$'
}
expect {
    0
}

test json_arrow_shift_false_type {
    SELECT typeof('false' ->> '$')
}
expect {
    integer
}

test json_extract_string {
    SELECT json_extract('"string"', '$')
}
expect {
    string
}

test json_extract_string_type {
    SELECT typeof(json_extract('"string"', '$'))
}
expect {
    text
}

test json_arrow_string {
    SELECT '"string"' -> '$'
}
expect {
    "string"
}

test json_arrow_string_type {
    SELECT typeof('"string"' -> '$')
}
expect {
    text
}

test json_arrow_shift_string {
    SELECT '"string"' ->> '$'
}
expect {
    string
}

test json_arrow_shift_string_type {
    SELECT typeof('"string"' ->> '$')
}
expect {
    text
}

test json_arrow_implicit_root_path {
    SELECT '{"a":1}' -> 'a';
}
expect {
    1
}

test json_arrow_shift_implicit_root_path {
    SELECT '{"a":1}' ->> 'a';
}
expect {
    1
}

test json_arrow_implicit_root_path_undefined_key {
    SELECT '{"a":1}' -> 'x';
}
expect {
}

test json_arrow_shift_implicit_root_path_undefined_key {
    SELECT '{"a":1}' ->> 'x';
}
expect {
}

test json_arrow_implicit_root_path_array {
    SELECT '[1,2,3]' -> 1;
}
expect {
    2
}

test json_arrow_shift_implicit_root_path_array {
    SELECT '[1,2,3]' ->> 1;
}
expect {
    2
}

test json_arrow_implicit_root_path_array_negative_idx {
    SELECT '[1,2,3]' -> -1;
}
expect {
    3
}

test json_arrow_shift_implicit_root_path_array_negative_idx {
    SELECT '[1,2,3]' ->> -1;
}
expect {
    3
}

test json_arrow_implicit_real_cast {
    SELECT '{"1.5":"abc"}' -> 1.5;
}
expect {
    "abc"
}

test json_arrow_shift_implicit_real_cast {
    SELECT '{"1.5":"abc"}' -> 1.5;
}
expect {
    "abc"
}

test json_arrow_implicit_true_cast {
    SELECT '[1,2,3]' -> true
}
expect {
    2
}

test json_arrow_shift_implicit_true_cast {
    SELECT '[1,2,3]' ->> true
}
expect {
    2
}

test json_arrow_implicit_false_cast {
    SELECT '[1,2,3]' -> false
}
expect {
    1
}

test json_arrow_shift_implicit_false_cast {
    SELECT '[1,2,3]' ->> false
}
expect {
    1
}

test json_arrow_chained {
    select '{"a":2,"c":[4,5,{"f":7}]}' -> 'c' -> 2 ->> 'f'
}
expect {
    7
}

test json_extract_multiple_null_paths {
    SELECT json_extract(1, null, null, null)
}
expect {
}

test json_extract_array {
    SELECT json_extract('[1,2,3]', '$')
}
expect {
    [1,2,3]
}

test json_arrow_array {
    SELECT '[1,2,3]' -> '$'
}
expect {
    [1,2,3]
}

test json_arrow_shift_array {
    SELECT '[1,2,3]' ->> '$'
}
expect {
    [1,2,3]
}

test json_extract_quote {
    SELECT json_extract('{"\"":1 }', '$."\""')
}
expect {
    1
}

# Overflows 2**32 is equivalent to 0
test json_extract_overflow_int32_1 {
    SELECT json_extract('[1,2,3]', '$[4294967296]')
}
expect {
    1
}

# Overflows 2**32 + 1 is equivalent to 1
test json_extract_overflow_int32_2 {
    SELECT json_extract('[1,2,3]', '$[4294967297]')
}
expect {
    2
}

# Overflows -2**32 - 1 is equivalent to -1
test json_extract_overflow_int32_3 {
    SELECT json_extract('[1,2,3]', '$[#-4294967297]')
}
expect {
    3
}

# Overflows -2**32 - 2 is equivalent to -2
test json_extract_overflow_int32_3-2 {
    SELECT json_extract('[1,2,3]', '$[#-4294967298]')
}
expect {
    2
}

# pow(2,63) + 1 == 9223372036854775808
test json_extract_overflow_int64 {
    SELECT json_extract('[1,2,3]', '$[9223372036854775808]');
}
expect {
    1
}

# TODO: fix me - this passes on SQLite and needs to be fixed in Limbo.
# pow(2, 127) + 1 == 170141183460469231731687303715884105729
#do_execsql_test json_extract_overflow_int128 {
#  SELECT json_extract('[1, 2, 3]', '$[170141183460469231731687303715884105729]');
#} {{2}}
test json_extract_blob {
    select json_extract(CAST('[1,2,3]' as BLOB), '$[1]')
}
expect {
    2
}

test json_array_length {
    SELECT json_array_length('[1,2,3,4]');
}
expect {
    4
}

test json_array_length_empty {
    SELECT json_array_length('[]');
}
expect {
    0
}

test json_array_length_root {
    SELECT json_array_length('[1,2,3,4]', '$');
}
expect {
    4
}

test json_array_length_not_array {
    SELECT json_array_length('{"one":[1,2,3]}');
}
expect {
    0
}

test json_array_length_via_prop {
    SELECT json_array_length('{"one":[1,2,3]}', '$.one');
}
expect {
    3
}

test json_array_length_via_index {
    SELECT json_array_length('[[1,2,3,4]]', '$[0]');
}
expect {
    4
}

test json_array_length_via_index_not_array {
    SELECT json_array_length('[1,2,3,4]', '$[2]');
}
expect {
    0
}

test json_array_length_via_bad_prop {
    SELECT json_array_length('{"one":[1,2,3]}', '$.two');
}
expect {
}

test json_array_length_nested {
    SELECT json_array_length('{"one":[[1,2,3],2,3]}', '$.one[0]');
}
expect {
    3
}

test json_type_no_path {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}')
}
expect {
    object
}

test json_type_root_path {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$')
}
expect {
    object
}

test json_type_array {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a')
}
expect {
    array
}

test json_type_integer {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[0]')
}
expect {
    integer
}

test json_type_real {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[1]')
}
expect {
    real
}

test json_type_true {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[2]')
}
expect {
    true
}

test json_type_false {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[3]')
}
expect {
    false
}

test json_type_null {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[4]')
}
expect {
    null
}

test json_type_text {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[5]')
}
expect {
    text
}

test json_type_NULL {
    select json_type('{"a":[2,3.5,true,false,null,"x"]}','$.a[6]')
}
expect {
}

test json_type_cast {
    select json_type(1)
}
expect {
    integer
}

test json_type_null_arg {
    select json_type(null)
}
expect {
}

test json_type_blob_with_trailing_bytes {
    select json_type(x'7B2261223A317D00FF')
}
expect {
    object
}

test json_error_position_valid {
    SELECT json_error_position('{"a":55,"b":72,}');
}
expect {
    0
}

test json_error_position_valid_ws {
    SELECT json_error_position('{"a":55,"b":72 , }');
}
expect {
    0
}

test json_error_position_object {
    SELECT json_error_position('{"a":55,"b":72,,}');
}
expect {
    16
}

test json_error_position_array_valid {
    SELECT json_error_position('["a",55,"b",72,]');
}
expect {
    0
}

test json_error_position_array_valid_ws {
    SELECT json_error_position('["a",55,"b",72 , ]');
}
expect {
    0
}

test json_error_position_array {
    SELECT json_error_position('["a",55,"b",72,,]');
}
expect {
    16
}

test json_error_position_null {
    SELECT json_error_position(NULL);
}
expect {
}

test json_error_position_complex {
    SELECT json_error_position('{a:null,{"h":[1,[1,2,3]],"j":"abc"}:true}');
}
expect {
    9
}

test json_object_simple {
    SELECT json_object('key', 'value');
}
expect {
    {"key":"value"}
}

test json_object_f64 {
    SELECT json_object('key', 40.7128);
}
expect {
    {"key":40.7128}
}

test json_object_nested {
    SELECT json_object('grandparent',json_object('parent', json_object('child', 'value')));
}
expect {
    {"grandparent":{"parent":{"child":"value"}}}
}

test json_object_quoted_json {
    SELECT json_object('parent', '{"child":"value"}');
}
expect {
    {"parent":"{\"child\":\"value\"}"}
}

test json_object_unquoted_json {
    SELECT json_object('parent', json('{"child":"value"}'));
}
expect {
    {"parent":{"child":"value"}}
}

test json_object_multiple_values {
    SELECT json_object('text', 'value', 'json', json_object('key', 'value'), 'int', 1, 'float', 1.5, 'null', null);
}
expect {
    {"text":"value","json":{"key":"value"},"int":1,"float":1.5,"null":null}
}

test json_object_empty {
    SELECT json_object();
}
expect {
    {}
}

test json_object_json_array {
    SELECT json_object('ex',json('[52,3]'));
}
expect {
    {"ex":[52,3]}
}

test json_from_json_object {
    SELECT json(json_object('key','value'));
}
expect {
    {"key":"value"}
}

test json_object_infinity {
    SELECT json_object('a', 2e370, 'b', -3e380);
}
expect {
    {"a":9.0e+999,"b":-9.0e+999}
}

test json_object_single_infinity {
    SELECT json_object('x', 1e309);
}
expect {
    {"x":9.0e+999}
}

# FIXME: this behaviour differs from sqlite. Although, sqlite docs states
# that this could change in a "future enhancement" (https://www.sqlite.org/json1.html#jobj)
test json_object_duplicated_keys {
    SELECT json_object('key', 'value', 'key', 'value2');
}
expect {
    {"key":"value","key":"value2"}
}

test json_valid_1 {
    SELECT json_valid('{"a":55,"b":72}');
}
expect {
    1
}

test json_valid_2 {
    SELECT json_valid('["a",55,"b",72]');
}
expect {
    1
}

test json_valid_3 {
    SELECT json_valid( CAST('{"a":"1}' AS BLOB) );
}
expect {
    0
}

test json_valid_4 {
    SELECT json_valid(123);
}
expect {
    1
}

test json_valid_5 {
    SELECT json_valid(12.3);
}
expect {
    1
}

test json_valid_6 {
    SELECT json_valid('not a valid json');
}
expect {
    0
}

test json_valid_7 {
    SELECT json_valid('{"a":"55,"b":72}');
}
expect {
    0
}

test json_valid_8 {
    SELECT json_valid('{"a":55 "b":72}');
}
expect {
    0
}

test json_valid_9 {
    SELECT json_valid(NULL);
}
expect {
}

test json_valid_blob_embedded_null {
    SELECT json_valid(x'7B226100223A317D');
}
expect {
    0
}

test json_valid_no_args {
    SELECT json_valid();
}
expect error {
}

test json-patch-basic-1 {
    select json_patch('{"a":1}', '{"b":2}');
}
expect {
    {"a":1,"b":2}
}

test json-patch-basic-2 {
    select json_patch('{"x":100,"y":200}', '{"z":300}');
}
expect {
    {"x":100,"y":200,"z":300}
}

test json-patch-preserve-duplicates-1 {
    select json_patch('{"x":100,"x":200}', '{"z":300}');
}
expect {
    {"x":100,"x":200,"z":300}
}

test json-patch-preserve-duplicates-2 {
    select json_patch('{"x":100,"x":200}', '{"x":900}');
}
expect {
    {"x":900,"x":200}
}

test json-patch-last-update-wins {
    select json_patch('{"x":100,"c":200}', '{"x":900, "x":null}');
}
expect {
    {"c":200}
}

test json-patch-override-1 {
    select json_patch('{"a":1,"b":2}', '{"b":3}');
}
expect {
    {"a":1,"b":3}
}

test json-patch-override-2 {
    select json_patch('{"name":"john","age":25}', '{"age":26,"city":"NYC"}');
}
expect {
    {"name":"john","age":26,"city":"NYC"}
}

test json-patch-nested-1 {
    select json_patch('{"user":{"name":"john"}}', '{"user":{"age":30}}');
}
expect {
    {"user":{"name":"john","age":30}}
}

test json-patch-nested-2 {
    select json_patch('{"settings":{"theme":"dark"}}', '{"settings":{"theme":"light","font":"arial"}}');
}
expect {
    {"settings":{"theme":"light","font":"arial"}}
}

test json-patch-array-1 {
    select json_patch('{"arr":[1,2,3]}', '{"arr":[4,5,6]}');
}
expect {
    {"arr":[4,5,6]}
}

test json-patch-array-2 {
    select json_patch('{"list":["a","b"]}', '{"list":["c"]}');
}
expect {
    {"list":["c"]}
}

test json-patch-empty-1 {
    select json_patch('{}', '{"a":1}');
}
expect {
    {"a":1}
}

test json-patch-empty-2 {
    select json_patch('{"a":1}', '{}');
}
expect {
    {"a":1}
}

test json-patch-deep-nested-1 {
    select json_patch(
    '{"level1":{"level2":{"value":100}}}',
    '{"level1":{"level2":{"newValue":200}}}'
    );
}
expect {
    {"level1":{"level2":{"value":100,"newValue":200}}}
}

test json-patch-mixed-types-1 {
    select json_patch(
    '{"str":"hello","num":42,"bool":true}',
    '{"arr":[1,2,3],"obj":{"x":1}}'
    );
}
expect {
    {"str":"hello","num":42,"bool":true,"arr":[1,2,3],"obj":{"x":1}}
}

test json-patch-add-all-dup-keys-from-patch {
    select json_patch(
    '{"x":100,"x":200}',
    '{"z":{}, "z":5, "z":100}'
    );
}
expect {
    {"x":100,"x":200,"z":100}
}

test json-patch-first-occurrence-patch {
    select json_patch('{"x":100,"x":200}','{"x":{}, "x":5, "x":100}');
}
expect {
    {"x":100,"x":200}
}

test json-patch-complex-nested-dup-keys {
    select json_patch(
    '{"a":{"x":1,"x":2},"a":{"y":3},"b":[{"z":4,"z":5}]}',
    '{"a":{"w":6},"b":[{"z":7,"z":8}],"b":{"z":9}}'
    );
}
expect {
    {"a":{"x":1,"x":2,"w":6},"a":{"y":3},"b":{"z":9}}
}

test json-patch-unicode-dup-keys {
    select json_patch(
    '{"ðŸ”‘":1,"ðŸ”‘":2}',
    '{"ðŸ—ï¸":3,"ðŸ—ï¸":4}'
    );
}
expect {
    {"ðŸ”‘":1,"ðŸ”‘":2,"ðŸ—ï¸":4}
}

test json-patch-empty-string-dup-keys {
    select json_patch(
    '{"":1,"":2}',
    '{"":3,"":4}'
    );
}
expect {
    {"":4,"":2}
}

test json-patch-multiple-types-dup-keys {
    select json_patch(
    '{"x":100,"x":"str","x":true,"x":null}',
    '{"y":1,"y":{},"y":[],"y":false}'
    );
}
expect {
    {"x":100,"x":"str","x":true,"x":null,"y":false}
}

test json-patch-deep-nested-dup-keys {
    select json_patch(
    '{"a":{"b":{"c":1}},"a":{"b":{"c":2}},"a":{"b":{"d":3}}}',
    '{"x":{"y":{"z":4}},"x":{"y":{"z":5}}}'
    );
}
expect {
    {"a":{"b":{"c":1}},"a":{"b":{"c":2}},"a":{"b":{"d":3}},"x":{"y":{"z":5}}}
}

test json-patch-abomination {
    select json_patch(
    '{"a":{"b":{"x":1,"x":2,"y":{"z":3,"z":{"w":4}}},"b":[{"c":5,"c":6},{"d":{"e":7,"e":null}}],"f":{"g":[1,2,3],"g":{"h":8,"h":[4,5,6]}},"i":{"j":true,"j":{"k":false,"k":{"l":null,"l":"string"}}},"m":{"n":{"o":{"p":9,"p":{"q":10}},"o":{"r":11}}},"m":[{"s":{"t":12}},{"s":{"t":13,"t":{"u":14}}}]},"a":{"v":{"w":{"x":{"y":{"z":15}}}},"v":{"w":{"x":16,"x":{"y":17}}},"aa":[{"bb":{"cc":18,"cc":{"dd":19}}},{"bb":{"cc":{"dd":20},"cc":21}}]}}',
    '{"a":{"b":{"x":{"new":"value"},"y":null},"b":{"c":{"updated":true},"d":{"e":{"replaced":100}}},"f":{"g":{"h":{"nested":"deep"}}},"i":{"j":{"k":{"l":{"modified":false}}}},"m":{"n":{"o":{"p":{"q":{"extra":"level"}}}},"s":null},"aa":[{"bb":{"cc":{"dd":{"ee":"new"}}}},{"bb":{"cc":{"dd":{"ff":"value"}}}}],"v":{"w":{"x":{"y":{"z":{"final":"update"}}}}}},"newTop":{"level":{"key":{"with":{"deep":{"nesting":true}}},"key":[{"array":{"in":{"deep":{"structure":null}}}}]}}}'
    );
}
expect {
    {"a":{"b":{"x":{"new":"value"},"x":2,"c":{"updated":true},"d":{"e":{"replaced":100}}},"b":[{"c":5,"c":6},{"d":{"e":7,"e":null}}],"f":{"g":{"h":{"nested":"deep"}},"g":{"h":8,"h":[4,5,6]}},"i":{"j":{"k":{"l":{"modified":false}}},"j":{"k":false,"k":{"l":null,"l":"string"}}},"m":{"n":{"o":{"p":{"q":{"extra":"level"}},"p":{"q":10}},"o":{"r":11}}},"m":[{"s":{"t":12}},{"s":{"t":13,"t":{"u":14}}}],"aa":[{"bb":{"cc":{"dd":{"ee":"new"}}}},{"bb":{"cc":{"dd":{"ff":"value"}}}}],"v":{"w":{"x":{"y":{"z":{"final":"update"}}}}}},"a":{"v":{"w":{"x":{"y":{"z":15}}}},"v":{"w":{"x":16,"x":{"y":17}}},"aa":[{"bb":{"cc":18,"cc":{"dd":19}}},{"bb":{"cc":{"dd":20},"cc":21}}]},"newTop":{"level":{"key":[{"array":{"in":{"deep":{"structure":null}}}}]}}}
}

test json-remove-1 {
    select json_remove('{"a": 5, "a": [5,4,3,2,1]}','$.a', '$.a[4]', '$.a[5]', '$.a');
}
expect {
    {}
}

test json-remove-2 {
    SELECT json_remove('{"a": {"b": {"c": 1, "c": 2}, "b": [1,2,3]}}', '$.a.b.c', '$.a.b[1]');
}
expect {
    {"a":{"b":{"c":2},"b":[1,2,3]}}
}

test json-remove-3 {
    SELECT json_remove('[1,2,3,4,5]', '$[0]', '$[4]', '$[5]');
}
expect {
    [2,3,4,5]
}

test json-remove-4 {
    SELECT json_remove('{"arr": [1,2,3,4,5]}', '$.arr[#-1]', '$.arr[#-3]', '$.arr[#-1]');
}
expect {
    {"arr":[1,3]}
}

test json-remove-5 {
    SELECT json_remove('{}', '$.a');
}
expect {
    {}
}

test json-remove-6 {
    SELECT json_remove('{"a": [[1,2], [3,4]]}', '$.a[0][1]', '$.a[1]');
}
expect {
    {"a":[[1]]}
}

test json-remove-7 {
    SELECT json_remove('{"a": 1, "b": [1,2], "c": {"d": 3}}', '$.a', '$.b[0]', '$.c.d');
}
expect {
    {"b":[2],"c":{}}
}

test json-remove-8 {
    SELECT json_remove(cast('{"age":30,"name":"John"}' as blob), '$.age');
}
expect {
    {"name":"John"}
}

test json-remove-9 {
    SELECT json_remove(cast('{"user":{"id":123,"profile":{"name":"Alice","age":25}}}' as blob), '$.user.id');
}
expect {
    {"user":{"profile":{"name":"Alice","age":25}}}
}

test json_set_notation {
		SELECT json_set(X'45312e652b', '$.x', 3);
}
expect {
		1.e+
}

test json_set_blob_value {
    SELECT json_set(3906369340027029955, '$.' || char(8) || '' || CAST(zeroblob(27) AS TEXT) || '5!""!!!$.' || char(6) || '62=!""%!!!!!!QQQQQQQQQQ' || char(13) || CAST(zeroblob(3) AS TEXT), x'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00');
}
expect error {
    .*JSON cannot hold BLOB values.*
}

test json_set_field_empty_object {
    SELECT json_set('{}', '$.field', 'value');
}
expect {
    {"field":"value"}
}

test json_set_replace_field {
    SELECT json_set('{"field":"old_value"}', '$.field', 'new_value');
}
expect {
    {"field":"new_value"}
}

test json_set_replace_field_2 {
    SELECT json_set(cast('{"age":30,"name":"John"}' as blob), '$.age', 40);
}
expect {
    {"age":40,"name":"John"}
}

test json_set_set_deeply_nested_key {
    SELECT json_set('{}', '$.object.doesnt.exist', 'value');
}
expect {
    {"object":{"doesnt":{"exist":"value"}}}
}

test json_set_add_value_to_empty_array {
    SELECT json_set('[]', '$[0]', 'value');
}
expect {
    ["value"]
}

test json_set_add_value_to_nonexistent_array {
    SELECT json_set('{}', '$.some_array[0]', 123);
}
expect {
    {"some_array":[123]}
}

test json_set_add_value_to_array {
    SELECT json_set('[123]', '$[1]', 456);
}
expect {
    [123,456]
}

test json_set_add_value_to_array_out_of_bounds {
    SELECT json_set('[123]', '$[200]', 456);
}
expect {
    [123]
}

test json_set_replace_value_in_array {
    SELECT json_set('[123]', '$[0]', 456);
}
expect {
    [456]
}

test json_set_null_path {
    SELECT json_set('{}', NULL, 456);
}
expect {
    {}
}

test json_set_multiple_keys {
    SELECT json_set('[123]', '$[0]', 456, '$[1]', 789);
}
expect {
    [456,789]
}

test json_set_add_array_in_nested_object {
    SELECT json_set('{}', '$.object[0].field', 123);
}
expect {
    {"object":[{"field":123}]}
}

test json_set_add_array_in_array_in_nested_object {
    SELECT json_set('{}', '$.object[0][0]', 123);
}
expect {
    {"object":[[123]]}
}

test json_set_add_array_in_array_in_nested_object_out_of_bounds {
    SELECT json_set('{}', '$.object[123].another', 'value', '$.field', 'value');
}
expect {
    {"field":"value"}
}

# Tests for json_insert() function
test json_insert_notation {
		SELECT json_insert(X'45312e652b', '$.a', 1);
}
expect {
		1.e+
}

test json_insert_new_key_in_nested_object {
    SELECT json_insert('{"a": {"b": {"c": 5}}}', '$.a.b.d', 10);
}
expect {
    {"a":{"b":{"c":5,"d":10}}}
}

test json_insert_existing_key_not_replaced {
    SELECT json_insert('{"a": 1}', '$.a', 2);
}
expect {
    {"a":1}
}

test json_insert_new_key_simple {
    SELECT json_insert('{"a": 1}', '$.b', 2);
}
expect {
    {"a":1,"b":2}
}

test json_insert_deeply_nested_new_key {
    SELECT json_insert('{"level1": {"level2": {"level3": {"value": 100}}}}', '$.level1.level2.level3.new_value', 200);
}
expect {
    {"level1":{"level2":{"level3":{"value":100,"new_value":200}}}}
}

test json_insert_array_append {
    SELECT json_insert('[1, 2, 3]', '$[3]', 4);
}
expect {
    [1,2,3,4]
}

test json_insert_array_existing_not_replaced {
    SELECT json_insert('[1, 2, 3]', '$[1]', 99);
}
expect {
    [1,2,3]
}

test json_insert_multiple_paths {
    SELECT json_insert('{"a": 1}', '$.b', 2, '$.c', 3);
}
expect {
    {"a":1,"b":2,"c":3}
}

# The json_quote() function transforms an SQL value into a JSON value.
# String values are quoted and interior quotes are escaped.  NULL values
# are rendered as the unquoted string "null".
#
test json_quote_string_literal {
    SELECT json_quote('abc"xyz');
}
expect {
    "abc\"xyz"
}

test json_quote_float {
    SELECT json_quote(3.14159);
}
expect {
    3.14159
}

test json_quote_integer {
    SELECT json_quote(12345);
}
expect {
    12345
}

test json_quote_null {
    SELECT json_quote(null);
}
expect {
    null
}

test json_quote_null_caps {
    SELECT json_quote(NULL);
}
expect {
    null
}

test json_quote_json_value {
    SELECT json_quote(json('{a:1, b: "test"}'));
}
expect {
    {"a":1,"b":"test"}
}

test json_basics {
    SELECT json(jsonb('{"name":"John", "age":30, "city":"New York"}'));
}
expect {
    {"name":"John","age":30,"city":"New York"}
}

test json_complex_nested {
    SELECT json(jsonb('{"complex": {"nested": ["array", "of", "values"], "numbers": [1, 2, 3]}}'));
}
expect {
    {"complex":{"nested":["array","of","values"],"numbers":[1,2,3]}}
}

test json_array_of_objects {
    SELECT json(jsonb('[{"id": 1, "data": "value1"}, {"id": 2, "data": "value2"}]'));
}
expect {
    [{"id":1,"data":"value1"},{"id":2,"data":"value2"}]
}

test json_special_chars {
    SELECT json(jsonb('{"special_chars": "!@#$%^&*()_+", "quotes": "\"quoted text\""}'));
}
expect {
    {"special_chars":"!@#$%^&*()_+","quotes":"\"quoted text\""}
}

test json_unicode_emoji {
    SELECT json(jsonb('{"unicode": "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ", "emoji": "ðŸš€ðŸ”¥ðŸ’¯"}'));
}
expect {
    {"unicode":"ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ","emoji":"ðŸš€ðŸ”¥ðŸ’¯"}
}

test json_value_types {
    SELECT json(jsonb('{"boolean": true, "null_value": null, "number": 42.5}'));
}
expect {
    {"boolean":true,"null_value":null,"number":42.5}
}

test json_deeply_nested {
    SELECT json(jsonb('{"deeply": {"nested": {"structure": {"with": "values"}}}}'));
}
expect {
    {"deeply":{"nested":{"structure":{"with":"values"}}}}
}

test json_mixed_array {
    SELECT json(jsonb('{"array_mixed": [1, "text", true, null, {"obj": "inside array"}]}'));
}
expect {
    {"array_mixed":[1,"text",true,null,{"obj":"inside array"}]}
}

test json_single_line_comments {
    SELECT json(jsonb('{"name": "John", // This is a comment
    "age": 30}'));
}
expect {
    {"name":"John","age":30}
}

test json_multi_line_comments {
    SELECT json(jsonb('{"data": "value", /* This is a
    multi-line comment that spans
    several lines */ "more": "data"}'));
}
expect {
    {"data":"value","more":"data"}
}

test json_trailing_commas {
    SELECT json(jsonb('{"items": ["one", "two", "three",], "status": "complete",}'));
}
expect {
    {"items":["one","two","three"],"status":"complete"}
}

test json_unquoted_keys {
    SELECT json(jsonb('{name: "Alice", age: 25}'));
}
expect {
    {"name":"Alice","age":25}
}

test json_newlines {
    SELECT json(jsonb('{"description": "Text with \nnew lines\nand more\nformatting"}'));
}
expect {
    {"description":"Text with \nnew lines\nand more\nformatting"}
}

test json_hex_values {
    SELECT json(jsonb('{"hex_value": "\x68\x65\x6c\x6c\x6f"}'));
}
expect {
    {"hex_value":"\u0068\u0065\u006c\u006c\u006f"}
}

test json_unicode_escape {
    SELECT json(jsonb('{"unicode": "\u0068\u0065\u006c\u006c\u006f"}'));
}
expect {
    {"unicode":"\u0068\u0065\u006c\u006c\u006f"}
}

test json_tabs_whitespace {
    SELECT json(jsonb('{"formatted": "Text with \ttabs and \tspacing"}'));
}
expect {
    {"formatted":"Text with \ttabs and \tspacing"}
}

test json_mixed_escaping {
    SELECT json(jsonb('{"mixed": "Newlines: \n Tabs: \t Quotes: \" Backslash: \\\\ Hex: \x40"}'));
}
expect {
    {"mixed":"Newlines: \n Tabs: \t Quotes: \" Backslash: \\\\ Hex: \u0040"}
}

test json_control_chars {
    SELECT json(jsonb('{"control": "Bell: \u0007 Backspace: \u0008 Form feed: \u000C"}'));
}
expect {
    {"control":"Bell: \u0007 Backspace: \u0008 Form feed: \u000C"}
}

# Tests for json_replace() function
# Basic replacement tests
test json_replace_basic_1 {
    SELECT json_replace('{"a": 1, "b": 2}', '$.a', 42)
}
expect {
    {"a":42,"b":2}
}

test json_replace_basic_2 {
    SELECT json_replace('{"a": 1, "b": 2}', '$.c', 3)
}
expect {
    {"a":1,"b":2}
}

test json_replace_multiple_paths {
    SELECT json_replace('{"a": 1, "b": 2, "c": 3}', '$.a', 10, '$.c', 30)
}
expect {
    {"a":10,"b":2,"c":30}
}

# Testing different JSON types
test json_replace_string {
    SELECT json_replace('{"name": "Alice"}', '$.name', 'Bob')
}
expect {
    {"name":"Bob"}
}

test json_replace_number_with_string {
    SELECT json_replace('{"age": 25}', '$.age', 'unknown')
}
expect {
    {"age":"unknown"}
}

test json_replace_with_null {
    SELECT json_replace('{"a": 1, "b": 2}', '$.a', NULL)
}
expect {
    {"a":null,"b":2}
}

test json_replace_with_json_object {
    SELECT json_replace('{"user": {"name": "Alice"}}', '$.user', '{"name": "Bob", "age": 30}')
}
expect {
    {"user":"{\"name\": \"Bob\", \"age\": 30}"}
}

# Array tests
test json_replace_array_element {
    SELECT json_replace('[1, 2, 3, 4]', '$[1]', 99)
}
expect {
    [1,99,3,4]
}

test json_replace_array_negative_index {
    SELECT json_replace('[1, 2, 3, 4]', '$[#-1]', 99)
}
expect {
    [1,2,3,99]
}

test json_replace_array_out_of_bounds {
    SELECT json_replace('[1, 2, 3]', '$[5]', 99)
}
expect {
    [1,2,3]
}

test json_replace_entire_array {
    SELECT json_replace('[1, 2, 3]', '$', '{"replaced": true}')
}
expect {
    "{\"replaced\": true}"
}

# Nested structures
test json_replace_nested_object {
    SELECT json_replace('{"user": {"name": "Alice", "age": 30}}', '$.user.age', 31)
}
expect {
    {"user":{"name":"Alice","age":31}}
}

test json_replace_nested_array {
    SELECT json_replace('{"data": [10, 20, 30]}', '$.data[1]', 99)
}
expect {
    {"data":[10,99,30]}
}

test json_replace_deep_nesting {
    SELECT json_replace(
    '{"level1": {"level2": {"level3": {"value": 0}}}}',
    '$.level1.level2.level3.value',
    42
    )
}
expect {
    {"level1":{"level2":{"level3":{"value":42}}}}
}

# Edge cases
test json_replace_empty_object {
    SELECT json_replace('{}', '$.anything', 42)
}
expect {
    {}
}

test json_replace_empty_array {
    SELECT json_replace('[]', '$[0]', 42)
}
expect {
    []
}

test json_replace_quoted_key {
    SELECT json_replace('{"key.with.dots": 1}', '$."key.with.dots"', 42)
}
expect {
    {"key.with.dots":42}
}

test json_replace_root {
    SELECT json_replace('{"old": "value"}', '$', '{"new": "object"}')
}
expect {
    "{\"new\": \"object\"}"
}

test json_replace_types_boolean {
    SELECT typeof(json_extract(json_replace('{"flag": null}', '$.flag', 1=1), '$.flag'))
}
expect {
    integer
}

test json_replace_types_integer {
    SELECT typeof(json_extract(json_replace('{"num": "text"}', '$.num', 42), '$.num'))
}
expect {
    integer
}

test json_replace_types_real {
    SELECT typeof(json_extract(json_replace('{"num": 1}', '$.num', 3.14), '$.num'))
}
expect {
    real
}

test json_replace_types_text {
    SELECT typeof(json_extract(json_replace('{"val": 1}', '$.val', 'text'), '$.val'))
}
expect {
    text
}

# Tests for json_remove() function
# Basic removal tests
test json_remove_basic_1 {
    SELECT json_remove('{"a": 1, "b": 2, "c": 3}', '$.b')
}
expect {
    {"a":1,"c":3}
}

test json_remove_basic_2 {
    SELECT json_remove('{"a": 1, "b": 2}', '$.c')
}
expect {
    {"a":1,"b":2}
}

test json_remove_multiple_paths {
    SELECT json_remove('{"a": 1, "b": 2, "c": 3, "d": 4}', '$.a', '$.c')
}
expect {
    {"b":2,"d":4}
}

# Array tests
test json_remove_array_element {
    SELECT json_remove('[1, 2, 3, 4]', '$[1]')
}
expect {
    [1,3,4]
}

test json_remove_array_negative_index {
    SELECT json_remove('[1, 2, 3, 4]', '$[#-1]')
}
expect {
    [1,2,3]
}

test json_remove_array_multiple_elements {
    SELECT json_remove('[0, 1, 2, 3, 4, 5]', '$[1]', '$[3]')
}
expect {
    [0,2,3,5]
}

test json_remove_array_out_of_bounds {
    SELECT json_remove('[1, 2, 3]', '$[5]')
}
expect {
    [1,2,3]
}

# Nested structures
test json_remove_nested_object {
    SELECT json_remove('{"user": {"name": "Alice", "age": 30, "email": "alice@example.com"}}', '$.user.email')
}
expect {
    {"user":{"name":"Alice","age":30}}
}

test json_remove_nested_array {
    SELECT json_remove('{"data": [10, 20, 30, 40]}', '$.data[2]')
}
expect {
    {"data":[10,20,40]}
}

test json_remove_deep_nesting {
    SELECT json_remove(
    '{"level1": {"level2": {"level3": {"a": 1, "b": 2, "c": 3}}}}',
    '$.level1.level2.level3.b'
    )
}
expect {
    {"level1":{"level2":{"level3":{"a":1,"c":3}}}}
}

# Edge cases
test json_remove_empty_object {
    SELECT json_remove('{}', '$.anything')
}
expect {
    {}
}

test json_remove_empty_array {
    SELECT json_remove('[]', '$[0]')
}
expect {
    []
}

test json_remove_quoted_key {
    SELECT json_remove('{"key.with.dots": 1, "normal": 2}', '$."key.with.dots"')
}
expect {
    {"normal":2}
}

test json_remove_all_properties {
    SELECT json_remove('{"a": 1, "b": 2}', '$.a', '$.b')
}
expect {
    {}
}

test json_remove_all_array_elements {
    SELECT json_remove('[1, 2, 3]', '$[0]', '$[0]', '$[0]')
}
expect {
    []
}

test json_remove_root {
    SELECT json_remove('{"a": 1}', '$')
}
expect {
}

test jsonb_remove_root {
    SELECT jsonb_remove('{"a": 1}', '$');
}
expect {
}

# Complex example tests
test json_remove_complex_1 {
    SELECT json_remove(
    '{"store": {"book": [
    {"category": "fiction", "author": "Herman Melville", "title": "Moby Dick", "price": 8.99},
    {"category": "fiction", "author": "J. R. R. Tolkien", "title": "The Lord of the Rings", "price": 22.99}
    ], "bicycle": {"color": "red", "price": 19.95}}}',
    '$.store.book[0].price',
    '$.store.bicycle'
    )
}
expect {
    {"store":{"book":[{"category":"fiction","author":"Herman Melville","title":"Moby Dick"},{"category":"fiction","author":"J. R. R. Tolkien","title":"The Lord of the Rings","price":22.99}]}}
}

test json_replace_complex_1 {
    SELECT json_replace(
    '{"store": {"book": [
    {"category": "fiction", "author": "Herman Melville", "title": "Moby Dick", "price": 8.99},
    {"category": "fiction", "author": "J. R. R. Tolkien", "title": "The Lord of the Rings", "price": 22.99}
    ], "bicycle": {"color": "red", "price": 19.95}}}',
    '$.store.book[0].price', 10.99,
    '$.store.bicycle.color', 'blue',
    '$.store.book[1].title', 'The Hobbit'
    )
}
expect {
    {"store":{"book":[{"category":"fiction","author":"Herman Melville","title":"Moby Dick","price":10.99},{"category":"fiction","author":"J. R. R. Tolkien","title":"The Hobbit","price":22.99}],"bicycle":{"color":"blue","price":19.95}}}
}

# Combination of replace and remove
test json_replace_after_remove {
    SELECT json_replace(json_remove('{"a": 1, "b": 2, "c": 3}', '$.a'), '$.b', 42)
}
expect {
    {"b":42,"c":3}
}

test json_remove_after_replace {
    SELECT json_remove(json_replace('{"a": 1, "b": 2, "c": 3}', '$.b', 42), '$.c')
}
expect {
    {"a":1,"b":42}
}

# Tests for idempotence
test json_replace_idempotence {
    SELECT json_replace('{"a": 1}', '$.a', 1)
}
expect {
    {"a":1}
}

test json_remove_idempotence {
    SELECT json_remove(json_remove('{"a": 1, "b": 2}', '$.a'), '$.a')
}
expect {
    {"b":2}
}

# Compare with extracted values
test json_remove_with_extract {
    SELECT json_extract(json_remove('{"a": 1, "b": 2, "c": {"d": 3}}', '$.b'), '$.c.d')
}
expect {
    3
}

test json_replace_with_extract {
    SELECT json_extract(json_replace('{"a": 1, "b": 2}', '$.a', 42), '$.a')
}
expect {
    42
}

# Check for consistency between -> operator and json_extract after mutations
test json_replace_with_arrow {
    SELECT json_replace('{"a": 1, "b": 2}', '$.a', 42) -> '$.a'
}
expect {
    42
}

test json_remove_with_arrow {
    SELECT json_remove('{"a": 1, "b": {"c": 3}}', '$.a') -> '$.b.c'
}
expect {
    3
}

# Escape character tests in sqlite source depend on json_valid and in some syntax that is not implemented
# yet in limbo.
# See https://github.com/sqlite/sqlite/blob/255548562b125e6c148bb27d49aaa01b2fe61dba/test/json102.test#L690
# So for now not all control characters escaped are tested
# do_execsql_test json102-1501 {
#   WITH RECURSIVE c(x) AS (VALUES(1) UNION ALL SELECT x+1 FROM c WHERE x<0x1f)
#   SELECT sum(json_valid(json_quote('a'||char(x)||'z'))) FROM c ORDER BY x;
# } {31}
test json_each_arrays_heterogeneous_primitives {
    SELECT key, atom, type, fullkey, path, typeof(key) AS ktype
    FROM json_each('[1, 2.5, "x", true, false, null]')
    ORDER BY key;
}
expect {
    0|1|integer|$[0]|$|integer
    1|2.5|real|$[1]|$|integer
    2|x|text|$[2]|$|integer
    3|1|true|$[3]|$|integer
    4|0|false|$[4]|$|integer
    5||null|$[5]|$|integer
}

test json_each_arrays_parent_is_always_null {
    SELECT COUNT(*) FROM json_each('[0,1,2]') WHERE parent IS NOT NULL;
}
expect {
    0
}

test json_each_arrays_id_uniqueness {
    SELECT COUNT(*), COUNT(DISTINCT id)
    FROM json_each('[10,20,30,40]');
}
expect {
    4|4
}

test json_each_arrays_empty_container_yields_zero_rows {
    SELECT COUNT(*) FROM json_each('[]');
}
expect {
    0
}

test json_each_objects_simple_integer_values {
    SELECT key, atom, type, fullkey, path, typeof(key) AS ktype
    FROM json_each('{"a":1,"b":2}')
    ORDER BY key;
}
expect {
    a|1|integer|$.a|$|text
    b|2|integer|$.b|$|text
}

test json_each_objects_nested_containers_value_is_valid_json {
    SELECT key, type, json_valid(value) AS is_json, fullkey, path
    FROM json_each('{"o":{"x":5},"a":[7,8]}')
    ORDER BY key;
}
expect {
    a|array|1|$.a|$
    o|object|1|$.o|$
}

test json_each_objects_empty_container_yields_zero_rows {
    SELECT COUNT(*) FROM json_each('{}');
}
expect {
    0
}

test json_each_objects_keys_require_quoting_in_json_path {
    SELECT key, fullkey
    FROM json_each('{"a space":1,"a.b":2,"\"q\"":3, "_c": 4}')
    ORDER BY key DESC;
}
expect {
    a.b|$."a.b"
    a space|$."a space"
    _c|$."_c"
    "q"|$."\"q\""
}

test json_each_top_level_integer_single_row_key_null {
    SELECT (key IS NULL), fullkey, path, atom, type
    FROM json_each('42');
}
expect {
    1|$|$|42|integer
}

test json_each_top_level_true_single_row_key_null {
    SELECT (key IS NULL), fullkey, path, atom, type
    FROM json_each('true');
}
expect {
    1|$|$|1|true
}

test json_each_top_level_null_single_row_key_null {
    SELECT (key IS NULL), fullkey, path, (atom IS NULL), type
    FROM json_each('null');
}
expect {
    1|$|$|1|null
}

test json_each_atom_equals_value_for_primitives_containers_are_json_text {
    WITH t AS (
    SELECT * FROM json_each('[1,"x",{"y":2},[3]]')
    )
    SELECT
    SUM(type IN ('object','array') AND json_valid(value)=1),
    SUM(type NOT IN ('object','array') AND value=atom)
    FROM t;
}
expect {
    2|2
}

test json_each_typeof_key_array_indices_integer {
    SELECT GROUP_CONCAT(ktype,'|') FROM (
    SELECT typeof(key) AS ktype FROM json_each('[0,1]') ORDER BY key
    );
}
expect {
    integer|integer
}

test json_each_typeof_key_object_keys_text {
    SELECT GROUP_CONCAT(ktype,'|') FROM (
    SELECT typeof(key) AS ktype FROM json_each('{"0":0,"1":1}') ORDER BY key
    );
}
expect {
    text|text
}

test json_each_parent_column_always_null {
    SELECT COUNT(*) FROM json_each('{"a":[1,2,3],"b":{}}') WHERE parent IS NOT NULL;
}
expect {
    0
}

test json_each_malformed_json_raises_error {
    SELECT * FROM json_each('{not json}');
}
expect error {
    (.*malformed JSON.*)
}

test json_each_object_member_order_preserved {
    SELECT key FROM json_each('{"z":0,"a":1,"m":2}');
}
expect {
    z
    a
    m
}

test json_each_json_extract_on_value {
    SELECT key, json_extract(value, '$.x')
    FROM json_each('{"k1":{"x":11},"k2":{"x":22},"k3":{"x":[3]}}')
    WHERE type!='array'
    ORDER BY key;
}
expect {
    k1|11
    k2|22
    k3|[3]
}

test json-each-2arg-array-basic {
    SELECT key, value, type, path, fullkey FROM json_each('{"a":[1,2,3]}', '$.a') ORDER BY key;
}
expect {
    0|1|integer|$.a|$.a[0]
    1|2|integer|$.a|$.a[1]
    2|3|integer|$.a|$.a[2]
}

test json-each-2arg-object-basic {
    SELECT key, value, type, path, fullkey
    FROM json_each('{"obj":{"a":[1,2],"n":10,"x":"y"}}', '$.obj')
    ORDER BY key;
}
expect {
    a|[1,2]|array|$.obj|$.obj.a
    n|10|integer|$.obj|$.obj.n
    x|y|text|$.obj|$.obj.x
}

test json-each-2arg-root-dollar-array {
    SELECT key, value, type
    FROM json_each('[4,5]', '$')
    ORDER BY key;
}
expect {
    0|4|integer
    1|5|integer
}

test json-each-2arg-start-at-primitive {
    SELECT value, type, path, fullkey FROM json_each('{"a":[1,2,3]}', '$.a[1]');
}
expect {
    2|integer|$.a[1]|$.a[1]
}

test json-each-2arg-start-at-object-inside-array {
    SELECT key, value, type, path, fullkey
    FROM json_each('{"arr":[{"x":1},{"y":2}]}', '$.arr[1]');
}
expect {
    y|2|integer|$.arr[1]|$.arr[1].y
}

test json-each-2arg-nonexistent-path-returns-no-rows {
    SELECT count(*) FROM json_each('{"a":1}', '$.missing');
}
expect {
    0
}

test json-each-2arg-empty-array {
    SELECT count(*) FROM json_each('{"a":[]}', '$.a');
}
expect {
    0
}

test json-each-2arg-empty-object {
    SELECT count(*) FROM json_each('{"o":{}}', '$.o');
}
expect {
    0
}

test json-each-2arg-bools-and-null {
    SELECT typeof(value), type
    FROM json_each('{"a":[null,true,false]}', '$.a')
    ORDER BY key;
}
expect {
    null|null
    integer|true
    integer|false
}

test json-each-2arg-primitive-key-null {
    SELECT typeof(key), value, type, path, fullkey
    FROM json_each('{"s":"hi"}', '$.s');
}
expect {
    null|hi|text|$.s|$.s
}

test json-each-2arg-negative-index-root {
    SELECT key, value, type
    FROM json_each('[{"a":1},{"b":2},{"c":3}]', '$[#-1]');
}
expect {
    c|3|integer
}

test json-each-no-arguments {
    SELECT * FROM json_each();
}
expect {
}

test json_each_3_arguments {
    SELECT * FROM json_each(1, 2, 3);
}
expect error {
    .*(t|T)oo many arguments (for|on) json_each.*
}

test json-tree-1arg-root-object-and-children-preorder {
    SELECT key, type, fullkey, path
    FROM json_tree('{"a":1,"b":{"c":2},"d":[3,4]}')
    ORDER BY id;
}
expect {
    |object|$|$
    a|integer|$.a|$
    b|object|$.b|$
    c|integer|$.b.c|$.b
    d|array|$.d|$
    0|integer|$.d[0]|$.d
    1|integer|$.d[1]|$.d
}

test json-tree-1arg-root-array-and-children-preorder {
    SELECT key, type, fullkey, path
    FROM json_tree('[null,1,"two",{"three":4.5}]')
    ORDER BY id;
}
expect {
    |array|$|$
    0|null|$[0]|$
    1|integer|$[1]|$
    2|text|$[2]|$
    3|object|$[3]|$
    three|real|$[3].three|$[3]
}

test json-tree-1arg-primitive-root-null-single-row {
    SELECT typeof(key), typeof(value), type, fullkey, path
    FROM json_tree('null');
}
expect {
    null|null|null|$|$
}

test json-tree-1arg-primitive-root-true-single-row {
    SELECT typeof(key), value, type, atom, fullkey, path
    FROM json_tree('true');
}
expect {
    null|1|true|1|$|$
}

test json-tree-1arg-primitive-root-false-single-row {
    SELECT typeof(key), value, type, atom, fullkey, path
    FROM json_tree('false');
}
expect {
    null|0|false|0|$|$
}

test json-tree-1arg-primitive-root-integer-single-row {
    SELECT typeof(key), value, type, atom, fullkey, path
    FROM json_tree('42');
}
expect {
    null|42|integer|42|$|$
}

test json-tree-1arg-primitive-root-real-single-row {
    SELECT typeof(key), value, type, atom, fullkey, path
    FROM json_tree('3.14');
}
expect {
    null|3.14|real|3.14|$|$
}

test json-tree-1arg-primitive-root-text-single-row {
    SELECT typeof(key), value, type, atom, fullkey, path
    FROM json_tree('"hi"');
}
expect {
    null|hi|text|hi|$|$
}

test json-tree-atom-null-for-containers {
    SELECT type, typeof(atom)
    FROM json_tree('{"x":[1,2]}')
    WHERE type IN ('object','array')
    ORDER BY fullkey;
}
expect {
    object|null
    array|null
}

test json-tree-value-minified-for-containers {
    SELECT fullkey, value
    FROM json_tree('{"o":{"x":1,"y":2},"a":[1,2]}')
    WHERE type IN ('object','array')
    ORDER BY fullkey;
}
expect {
    $|{"o":{"x":1,"y":2},"a":[1,2]}
    $.a|[1,2]
    $.o|{"x":1,"y":2}
}

test json-tree-key-types-by-parent-kind {
    SELECT fullkey, typeof(key)
    FROM json_tree('{"o":{"x":1},"a":[10]}')
    WHERE fullkey IN ('$.o','$.o.x','$.a','$.a[0]')
    ORDER BY fullkey;
}
expect {
    $.a|text
    $.a[0]|integer
    $.o|text
    $.o.x|text
}

# TODO When {} is fixed, this can be reverted to a simpler 
# and more reliable version:
# WITH t AS (SELECT * FROM json_tree('{"a":[1]}'))
# SELECT c.fullkey, p.fullkey
# FROM t AS c JOIN t AS p
# ON c.parent = p.id
# WHERE c.fullkey IN ('$.a','$.a[0]')
# ORDER BY c.fullkey;
test json-tree-parent-links-self-join {
    WITH c AS (SELECT * FROM json_tree('{"a":[1]}')),
    p AS (SELECT * FROM json_tree('{"a":[1]}'))
    SELECT c.fullkey, p.fullkey
    FROM c JOIN p
    ON c.parent = p.id
    WHERE c.fullkey IN ('$.a','$.a[0]')
    ORDER BY c.fullkey;
}
expect {
    $.a|$
    $.a[0]|$.a
}

test json-tree-parent-null-at-top {
    SELECT typeof(parent), fullkey
    FROM json_tree('{"k":1}')
    WHERE fullkey='$';
}
expect {
    null|$
}

test json-tree-2arg-start-at-object {
    SELECT key, type, path, fullkey
    FROM json_tree('{"obj":{"x":1,"y":2}}', '$.obj')
    ORDER BY id;
}
expect {
    obj|object|$|$.obj
    x|integer|$.obj|$.obj.x
    y|integer|$.obj|$.obj.y
}

test json-tree-2arg-start-at-array {
    SELECT key, type, path, fullkey
    FROM json_tree('{"arr":[10,20]}', '$.arr')
    ORDER BY id;
}
expect {
    arr|array|$|$.arr
    0|integer|$.arr|$.arr[0]
    1|integer|$.arr|$.arr[1]
}

test json-tree-2arg-start-at-primitive-yields-single-row-and-path-to-self {
    SELECT typeof(key), value, type, path, fullkey
    FROM json_tree('{"a":5}', '$.a');
}
expect {
    text|5|integer|$|$.a
}

test json-tree-2arg-nonexistent-path-returns-no-rows {
    SELECT count(*) FROM json_tree('{"a":1}', '$.missing');
}
expect {
    0
}

test json-tree-2arg-empty-array {
    SELECT count(*) FROM json_tree('{"a":[]}', '$.a');
}
expect {
    1
}

test json-tree-2arg-empty-object {
    SELECT count(*) FROM json_tree('{"o":{}}', '$.o');
}
expect {
    1
}

test json-tree-2arg-bools-and-null-under-array {
    SELECT typeof(value), type
    FROM json_tree('{"a":[null,true,false]}', '$.a')
    WHERE fullkey != '$.a'
    ORDER BY key;
}
expect {
    null|null
    integer|true
    integer|false
}

test json-tree-fullkey-remains-absolute-under-subpath {
    SELECT DISTINCT substr(fullkey,1,4) FROM json_tree('{"x":{"y":1}}', '$.x');
}
expect {
    $.x
    $.x.
}

test json-tree-path-points-to-container {
    SELECT fullkey, path
    FROM json_tree('{"x":[{"y":1}]}')
    WHERE fullkey IN ('$.x','$.x[0]','$.x[0].y')
    ORDER BY id;
}
expect {
    $.x|$
    $.x[0]|$.x
    $.x[0].y|$.x[0]
}

test json-tree-count-includes-containers-and-leaves {
    SELECT count(*) FROM json_tree('{"a":[1,2,3],"b":{"c":4}}');
}
expect {
    7
}

test json-tree-escapes-in-fullkey {
    SELECT fullkey, value
    FROM json_tree('{"a.b":{"c d":1, "e_f": 2, "g\"h": 3}}')
}
expect {
    $|{"a.b":{"c d":1,"e_f":2,"g\"h":3}}
    $."a.b"|{"c d":1,"e_f":2,"g\"h":3}
    $."a.b"."c d"|1
    $."a.b"."e_f"|2
    $."a.b"."g\"h"|3
}

test json-tree-deeply-nested-mixed-types {
    SELECT type
    FROM json_tree('{"o":{"a":[1,{"b":[null,2.5]}]}}')
    ORDER BY id;
}
expect {
    object
    object
    array
    integer
    object
    array
    null
    real
}

test json-tree-ordering-by-fullkey-stable-hierarchy {
    SELECT fullkey
    FROM json_tree('{"z":0,"a":{"b":1,"a":2}}')
    ORDER BY fullkey;
}
expect {
    $
    $.a
    $.a.a
    $.a.b
    $.z
}

test json-tree-type-spectrum {
    SELECT type
    FROM json_tree('{"n":null,"t":true,"f":false,"i":1,"r":1.25,"s":"x","a":[],"o":{}}')
    WHERE fullkey != '$'
    ORDER BY fullkey;
}
expect {
    array
    false
    integer
    null
    object
    real
    text
    true
}

test json-tree-key-null-at-root {
    SELECT typeof(key), fullkey
    FROM json_tree('{"a":1}');
}
expect {
    null|$
    text|$.a
}

test json-tree-key-integer-for-array-elements {
    SELECT typeof(key)
    FROM json_tree('[10,20]')
    WHERE fullkey IN ('$[0]','$[1]')
    ORDER BY key;
}
expect {
    integer
    integer
}

test json-tree-key-text-for-object-entries {
    SELECT typeof(key)
    FROM json_tree('{"x":1,"y":2}')
    WHERE fullkey IN ('$.x','$.y')
    ORDER BY key;
}
expect {
    text
    text
}

test json-tree-id-uniqueness {
    SELECT count(DISTINCT id)=count(*)
    FROM json_tree('{"a":[1,2],"b":3}');
}
expect {
    1
}

test json-tree-no-arguments {
    SELECT * FROM json_tree();
}
expect {
}

test json_tree_3_arguments {
    SELECT * FROM json_tree(1, 2, 3);
}
expect error {
    .*(t|T)oo many arguments (for|on) json_tree.*
}

# TODO these tests are disabled because negative indices 
# are buggy with json_tree in SQLite. Uncomment them and 
# implement the correct behaviour when 
# https://www.sqlite.org/forum/forumpost/48f5763d8c is addressed.
# do_execsql_test json-tree-2arg-negative-index-root-array-element {
#   SELECT key, value, type, fullkey, path
#   FROM json_tree('[{"a":1},{"b":2},{"c":3}]', '$[#-1]')
#   ORDER BY id;
# } {
# {0|{"c":3}|object|$[#-1]|$}
# {c|3|integer|$[#-1].c|$[#-1]}
# }
# do_execsql_test json-tree-2arg-negative-index-inside {
#   SELECT key, value, type, fullkey
#   FROM json_tree('{"arr":[0,1,2]}', '$.arr[#-2]');
# } {
# {arr[#-2]|1|integer|$.arr[#-2]}
# }
# TODO add key and path columns back when 
# https://www.sqlite.org/forum/forumpost/48f5763d8c is addressed.
test json-tree-nested-object {
    select fullkey, j.value from generate_series(0,2) s
    join json_tree('{"a": [1,2,3]}', '$.a[' || s.value || ']') j;
}
expect {
    $.a[0]|1
    $.a[1]|2
    $.a[2]|3
}

# NaN should be converted to null (JSON5 extension, SQLite behavior)
test json-nan-to-null-upper {
    SELECT json('NaN');
}
expect {
    null
}

test json-nan-to-null-lower {
    SELECT json('nan');
}
expect {
    null
}

test json-nan-to-null-mixed {
    SELECT json('nAn');
}
expect {
    null
}

# Regression: json_valid() must return 0 for UTF-8 BLOB data that is not valid JSON syntax.
test json_valid_blob_utf8_non_json_word {
    SELECT json_valid(x'696e76616c6964');
}
expect {
    0
}

test json_valid_blob_utf8_non_json_word_with_whitespace {
    SELECT json_valid(x'2020696e76616c69642020');
}
expect {
    0
}

# Regression: x'7C31323334353637' starts with '|' (0x7C), which can overlap
# with JSONB inline header byte patterns, but this is scalar non-JSON bytes.
test json_valid_blob_header_overlap_scalar_bytes {
    SELECT json_valid(x'7C31323334353637');
}
expect {
    0
}
