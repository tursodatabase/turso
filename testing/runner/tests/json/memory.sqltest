@database :memory:

test non-string-path {
    SELECT * FROM json_each('{}', 123);
}
expect error {
}

test invalid-path {
    SELECT * FROM json_each('{}', '$$$');
}
expect error {
}

test json-tree-non-string-path {
    SELECT * FROM json_tree('{}', 123);
}
expect error {
}

test json-tree-invalid-path {
    SELECT * FROM json_tree('{}', '$$$');
}
expect error {
}

# Malformed JSON edge cases - must error like SQLite
test json-malformed-empty-string {
    SELECT json('');
}
expect error {
}

test json-malformed-plus-only {
    SELECT json('+');
}
expect error {
}

test json-malformed-minus-only {
    SELECT json('-');
}
expect error {
}

test json-malformed-double-minus {
    SELECT json('--1');
}
expect error {
}

test json-malformed-double-plus {
    SELECT json('++1');
}
expect error {
}

test json-malformed-incomplete-exponent {
    SELECT json('1e');
}
expect error {
}

test json-malformed-incomplete-exponent-plus {
    SELECT json('1e+');
}
expect error {
}

test json-malformed-incomplete-exponent-minus {
    SELECT json('1e-');
}
expect error {
}

test json-malformed-hex-no-digits {
    SELECT json('0x');
}
expect error {
}

test json-malformed-leading-zeros {
    SELECT json('00');
}
expect error {
}

test json-malformed-leading-zero-digit {
    SELECT json('01');
}
expect error {
}

# Regression: invalid JSON BLOB must not bypass CHECK(json_valid(...)).
test json_valid_blob_check_constraint_rejects_invalid_blob {
    CREATE TABLE json_valid_guard_1(data BLOB CHECK(json_valid(data)));
    INSERT INTO json_valid_guard_1 VALUES (x'696e76616c6964');
}
expect error {
    CHECK constraint failed
}

test json_valid_blob_check_constraint_ignore_does_not_insert {
    CREATE TABLE json_valid_guard_2(data BLOB CHECK(json_valid(data)));
    INSERT OR IGNORE INTO json_valid_guard_2 VALUES (x'696e76616c6964');
    SELECT count(*) FROM json_valid_guard_2;
}
expect {
    0
}
