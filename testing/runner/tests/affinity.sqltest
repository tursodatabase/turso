@database :memory:

test affinity {
    CREATE TABLE t1 (c INTEGER);
    INSERT INTO t1 VALUES ('1');
    INSERT INTO t1 VALUES ('1a');
    SELECT c, typeof(c) FROM t1;
}
expect {
    1|integer
    1a|text
}

test affinity-nan-inf-integer {
    CREATE TABLE t1 (c INTEGER);
    INSERT INTO t1 VALUES ('nan'), ('inf');
    SELECT typeof(c), quote(c) FROM t1 ORDER BY rowid;
}
expect {
    text|'nan'
    text|'inf'
}

test affinity-rowid {
    create table t(a integer);
    insert into t(rowid, a) values (1, 1);
    select * from t where rowid = '1';
    select * from t where a = '1';
}
expect {
    1
    1
}

# ============================================
# TEXT affinity: numeric values should be converted to text on INSERT
# ============================================
test affinity-insert-text-from-real {
    CREATE TABLE t1 (c1 TEXT);
    INSERT INTO t1 VALUES (1025.1655084065987);
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    1025.1655084066|text
}

test affinity-insert-text-from-integer {
    CREATE TABLE t1 (c1 TEXT);
    INSERT INTO t1 VALUES (42);
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    42|text
}

# ============================================
# TEXT affinity with index: both table and index should use converted value
# ============================================
test affinity-insert-text-with-index {
    CREATE TABLE t1 (c1 TEXT);
    CREATE INDEX i1 ON t1 (c1);
    INSERT INTO t1 VALUES (123.456);
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    123.456|text
}

# ============================================
# UPDATE with TEXT affinity: numeric values should be converted
# ============================================
test affinity-update-text-from-real {
    CREATE TABLE t1 (c1 TEXT);
    INSERT INTO t1 VALUES ('initial');
    UPDATE t1 SET c1 = 999.888;
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    999.888|text
}

test affinity-update-text-with-index {
    CREATE TABLE t1 (c1 TEXT);
    CREATE INDEX i1 ON t1 (c1);
    INSERT INTO t1 VALUES ('initial');
    UPDATE t1 SET c1 = 123.456;
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    123.456|text
}

# ============================================
# UPSERT with TEXT affinity
# ============================================
test affinity-upsert-text {
    CREATE TABLE t1 (id INTEGER PRIMARY KEY, c1 TEXT);
    INSERT INTO t1 VALUES (1, 'initial');
    INSERT INTO t1 VALUES (1, 555.666) ON CONFLICT(id) DO UPDATE SET c1 = excluded.c1;
    SELECT id, c1, typeof(c1) FROM t1;
}
expect {
    1|555.666|text
}

# ============================================
# IN clause with TEXT column: should apply TEXT affinity to comparison
# ============================================
test affinity-in-text-column {
    CREATE TABLE t1 (name TEXT);
    INSERT INTO t1 VALUES ('1'), ('2'), ('3'), ('abc');
    SELECT name FROM t1 WHERE name IN (1, 2, 3) ORDER BY name;
}
expect {
    1
    2
    3
}

test affinity-in-text-column-with-index {
    CREATE TABLE t1 (name TEXT);
    INSERT INTO t1 VALUES ('1'), ('2'), ('3'), ('abc');
    CREATE INDEX i1 ON t1 (name);
    SELECT name FROM t1 WHERE name IN (1, 2, 3) ORDER BY name;
}
expect {
    1
    2
    3
}

# ============================================
# IN clause with INTEGER column: should apply INTEGER affinity
# ============================================
test affinity-in-integer-column {
    CREATE TABLE t1 (id INTEGER);
    INSERT INTO t1 VALUES (1), (2), (3), (100);
    SELECT id FROM t1 WHERE id IN ('1', '2', '3') ORDER BY id;
}
expect {
    1
    2
    3
}

test affinity-in-subquery-cast-text {
    CREATE TABLE t1 (id INTEGER PRIMARY KEY, v REAL);
    INSERT INTO t1 VALUES (893900, 835162.5053372835);
    SELECT id FROM t1 WHERE id IN (SELECT CAST(id AS TEXT) FROM t1);
}
expect {
    893900
}

test affinity-in-subquery-group-concat {
    CREATE TABLE t1 (id INTEGER PRIMARY KEY, v REAL);
    INSERT INTO t1 VALUES (1, 1.0), (2, 2.0), (3, 3.0);
    SELECT id FROM t1 WHERE id IN (
        SELECT GROUP_CONCAT(id) FROM t1 GROUP BY v ORDER BY v DESC LIMIT 1
    );
}
expect {
    3
}

test affinity-in-subquery-text-lhs-integer-rhs {
    CREATE TABLE t_text (a TEXT);
    CREATE TABLE t_int (i INTEGER);
    INSERT INTO t_text VALUES ('1'), ('01'), ('1.0'), ('abc');
    INSERT INTO t_int VALUES (1);
    SELECT a FROM t_text WHERE a IN (SELECT i FROM t_int) ORDER BY a;
}
expect {
    01
    1
    1.0
}

# ============================================
# Multiple columns with different affinities
# ============================================
test affinity-mixed-columns-insert {
    CREATE TABLE t1 (a TEXT, b INTEGER, c REAL);
    INSERT INTO t1 VALUES (100, '200', '300.5');
    SELECT a, typeof(a), b, typeof(b), c, typeof(c) FROM t1;
}
expect {
    100|text|200|integer|300.5|real
}

test affinity-mixed-columns-update {
    CREATE TABLE t1 (a TEXT, b INTEGER, c REAL);
    INSERT INTO t1 VALUES ('x', 0, 0.0);
    UPDATE t1 SET a = 999, b = '888', c = '777.5';
    SELECT a, typeof(a), b, typeof(b), c, typeof(c) FROM t1;
}
expect {
    999|text|888|integer|777.5|real
}

# ============================================
# Original test case from issue https://github.com/tursodatabase/turso/issues/4154
# ============================================
test affinity-original-issue {
    CREATE TABLE t1 (c1 TEXT COLLATE RTRIM);
    INSERT INTO t1 VALUES (' ');
    CREATE INDEX i1 ON t1 (c1 COLLATE RTRIM DESC);
    INSERT INTO t1 VALUES (1025.1655084065987);
    SELECT typeof(c1), c1 FROM t1 ORDER BY c1 COLLATE BINARY DESC, rowid ASC;
}
expect raw {
text|1025.1655084066
text| 
}

# ============================================
# TEXT affinity: numeric values should be converted to text on INSERT
# ============================================
test affinity-insert-text-from-real-2 {
    CREATE TABLE t1 (c1 TEXT);
    INSERT INTO t1 VALUES (1025.1655084065987);
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    1025.1655084066|text
}

test affinity-insert-text-from-integer-2 {
    CREATE TABLE t1 (c1 TEXT);
    INSERT INTO t1 VALUES (42);
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    42|text
}

# ============================================
# TEXT affinity with index: both table and index should use converted value
# ============================================
test affinity-insert-text-with-index-2 {
    CREATE TABLE t1 (c1 TEXT);
    CREATE INDEX i1 ON t1 (c1);
    INSERT INTO t1 VALUES (123.456);
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    123.456|text
}

# ============================================
# UPDATE with TEXT affinity: numeric values should be converted
# ============================================
test affinity-update-text-from-real-2 {
    CREATE TABLE t1 (c1 TEXT);
    INSERT INTO t1 VALUES ('initial');
    UPDATE t1 SET c1 = 999.888;
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    999.888|text
}

test affinity-update-text-with-index-2 {
    CREATE TABLE t1 (c1 TEXT);
    CREATE INDEX i1 ON t1 (c1);
    INSERT INTO t1 VALUES ('initial');
    UPDATE t1 SET c1 = 123.456;
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    123.456|text
}

# ============================================
# UPSERT with TEXT affinity
# ============================================
test affinity-upsert-text-2 {
    CREATE TABLE t1 (id INTEGER PRIMARY KEY, c1 TEXT);
    INSERT INTO t1 VALUES (1, 'initial');
    INSERT INTO t1 VALUES (1, 555.666) ON CONFLICT(id) DO UPDATE SET c1 = excluded.c1;
    SELECT id, c1, typeof(c1) FROM t1;
}
expect {
    1|555.666|text
}

# ============================================
# IN clause with TEXT column: should apply TEXT affinity to comparison
# ============================================
test affinity-in-text-column-2 {
    CREATE TABLE t1 (name TEXT);
    INSERT INTO t1 VALUES ('1'), ('2'), ('3'), ('abc');
    SELECT name FROM t1 WHERE name IN (1, 2, 3) ORDER BY name;
}
expect {
    1
    2
    3
}

test affinity-in-text-column-with-index-2 {
    CREATE TABLE t1 (name TEXT);
    INSERT INTO t1 VALUES ('1'), ('2'), ('3'), ('abc');
    CREATE INDEX i1 ON t1 (name);
    SELECT name FROM t1 WHERE name IN (1, 2, 3) ORDER BY name;
}
expect {
    1
    2
    3
}

# ============================================
# IN clause with INTEGER column: should apply INTEGER affinity
# ============================================
test affinity-in-integer-column-2 {
    CREATE TABLE t1 (id INTEGER);
    INSERT INTO t1 VALUES (1), (2), (3), (100);
    SELECT id FROM t1 WHERE id IN ('1', '2', '3') ORDER BY id;
}
expect {
    1
    2
    3
}

# ============================================
# Multiple columns with different affinities
# ============================================
test affinity-mixed-columns-insert-2 {
    CREATE TABLE t1 (a TEXT, b INTEGER, c REAL);
    INSERT INTO t1 VALUES (100, '200', '300.5');
    SELECT a, typeof(a), b, typeof(b), c, typeof(c) FROM t1;
}
expect {
    100|text|200|integer|300.5|real
}

test affinity-mixed-columns-update-2 {
    CREATE TABLE t1 (a TEXT, b INTEGER, c REAL);
    INSERT INTO t1 VALUES ('x', 0, 0.0);
    UPDATE t1 SET a = 999, b = '888', c = '777.5';
    SELECT a, typeof(a), b, typeof(b), c, typeof(c) FROM t1;
}
expect {
    999|text|888|integer|777.5|real
}

# ============================================
# Original test case from issue https://github.com/tursodatabase/turso/issues/4154
# ============================================
test affinity-original-issue-2 {
    CREATE TABLE t1 (c1 TEXT COLLATE RTRIM);
    INSERT INTO t1 VALUES (' ');
    CREATE INDEX i1 ON t1 (c1 COLLATE RTRIM DESC);
    INSERT INTO t1 VALUES (1025.1655084065987);
    SELECT typeof(c1), c1 FROM t1 ORDER BY c1 COLLATE BINARY DESC, rowid ASC;
}
expect raw {
text|1025.1655084066
text| 
}

test affinity-ascii-whitespace-1_1 {
    CREATE TABLE nb1(i INTEGER);
    INSERT INTO nb1 VALUES ('12' || CHAR(160));
    SELECT TYPEOF(i), LENGTH(i) FROM nb1;
}
expect {
    text|3
}


# ============================================
# REAL affinity with leading + sign
# Strings with leading + should be converted to REAL
# ============================================
test affinity-real-leading-plus-sign {
    CREATE TABLE t0 (c0 REAL);
    INSERT INTO t0 VALUES ('+3'), ('+3.14'), ('+1e5');
    SELECT typeof(c0), c0 FROM t0 ORDER BY rowid;
}
expect {
    real|3.0
    real|3.14
    real|100000.0
}
# JS Number omits .0 for whole numbers
expect @js {
    real|3
    real|3.14
    real|100000
}

test affinity-real-mixed-signs {
    CREATE TABLE t0 (c0 REAL);
    INSERT INTO t0 VALUES ('+3'), ('-5'), ('+3.14'), ('-3.14'), ('+1e5'), ('-1e5');
    SELECT typeof(c0), c0 FROM t0 ORDER BY rowid;
}
expect {
    real|3.0
    real|-5.0
    real|3.14
    real|-3.14
    real|100000.0
    real|-100000.0
}
expect @js {
    real|3
    real|-5
    real|3.14
    real|-3.14
    real|100000
    real|-100000
}

# ============================================
# ANY affinity defaults to NUMERIC
# ============================================
test affinity-any-string-integer {
    CREATE TABLE t1 (c1 ANY);
    INSERT INTO t1 VALUES ('42');
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    42|integer
}

test affinity-any-string-real {
    CREATE TABLE t1 (c1 ANY);
    INSERT INTO t1 VALUES ('3.14');
    SELECT c1, typeof(c1) FROM t1;
}
expect {
    3.14|real
}

# ============================================
# ANY affinity (non-STRICT vs STRICT)
# ============================================
test affinity-any-non-strict {
    CREATE TABLE t1 (c1 ANY);
    INSERT INTO t1 VALUES ('1'), ('1.5'), ('1a');
    SELECT c1, typeof(c1) FROM t1 ORDER BY rowid;
}
expect {
    1|integer
    1.5|real
    1a|text
}

@requires strict "uses STRICT tables"
test affinity-any-strict {
    CREATE TABLE t1 (c1 ANY) STRICT;
    INSERT INTO t1 VALUES ('1'), ('1.5'), ('1a');
    SELECT c1, typeof(c1) FROM t1 ORDER BY rowid;
}
expect {
    1|text
    1.5|text
    1a|text
}
