@database :memory:

@skip-file-if mvcc "not supported in MVCC mode"

# Test basic integrity_check on empty database
test integrity-check-empty {
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test basic quick_check on empty database
test quick-check-empty {
    PRAGMA quick_check;
}
expect {
    ok
}

# Test integrity_check with a simple table
test integrity-check-simple-table {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t1 VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with indexes
test integrity-check-with-index {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, name TEXT);
    INSERT INTO t1 VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Charlie');
    CREATE INDEX idx_t1_name ON t1(name);
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with NOT NULL columns (valid data)
test integrity-check-not-null-valid {
    CREATE TABLE t2(id INTEGER PRIMARY KEY, value INTEGER NOT NULL);
    INSERT INTO t2 VALUES (1, 100), (2, 200);
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test quick_check with table and index
test quick-check-with-index {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, name TEXT);
    CREATE INDEX idx_t1_name ON t1(name);
    INSERT INTO t1 VALUES (1, 'test');
    PRAGMA quick_check;
}
expect {
    ok
}

# Test integrity_check with multiple indexes on same table
test integrity-check-multi-index {
    CREATE TABLE t3(a INTEGER PRIMARY KEY, b TEXT, c REAL);
    CREATE INDEX idx_t3_b ON t3(b);
    CREATE INDEX idx_t3_c ON t3(c);
    INSERT INTO t3 VALUES (1, 'x', 1.1), (2, 'y', 2.2), (3, 'z', 3.3);
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with configurable max errors
test integrity-check-max-errors {
    CREATE TABLE t1(id INTEGER PRIMARY KEY);
    PRAGMA integrity_check(10);
}
expect {
    ok
}

# Test quick_check skips index validation (should still return ok)
test quick-check-skips-index {
    CREATE TABLE t1(id INTEGER PRIMARY KEY, name TEXT);
    CREATE INDEX idx_t1_name ON t1(name);
    INSERT INTO t1 VALUES (1, 'a'), (2, 'b');
    PRAGMA quick_check;
}
expect {
    ok
}

# Test integrity_check with INTEGER PRIMARY KEY NOT NULL (rowid alias)
# The INTEGER PRIMARY KEY column is an alias for the rowid and is stored
# separately from the record payload. The NOT NULL check should not report
# a false positive for this column.
test integrity-check-ipk-not-null {
    CREATE TABLE t4(
    col1 INTEGER,
    col2 INTEGER NOT NULL PRIMARY KEY,
    col3 TEXT NOT NULL
    );
    INSERT INTO t4 VALUES (1, 100, 'a'), (2, 200, 'b'), (NULL, 300, 'c');
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with INTEGER PRIMARY KEY NOT NULL and multiple NOT NULL columns
test integrity-check-ipk-not-null-multi {
    CREATE TABLE t5(
    a INTEGER,
    b INTEGER NOT NULL PRIMARY KEY,
    c NUMERIC NOT NULL,
    d TEXT,
    e TEXT NOT NULL
    );
    INSERT INTO t5 VALUES (1, 10, 100, 'x', 'y');
    INSERT INTO t5 VALUES (NULL, 20, 200, NULL, 'z');
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with unique index (rowid-at-end-of-record check)
test integrity-check-unique-index-rowid {
    CREATE TABLE t6(id INTEGER PRIMARY KEY, val TEXT UNIQUE);
    INSERT INTO t6 VALUES (1, 'alpha'), (2, 'beta'), (3, 'gamma');
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with multi-column index (rowid-at-end-of-record check)
test integrity-check-multi-column-index-rowid {
    CREATE TABLE t7(id INTEGER PRIMARY KEY, a TEXT, b INTEGER, c REAL);
    CREATE INDEX idx_t7_ab ON t7(a, b);
    CREATE INDEX idx_t7_bc ON t7(b, c);
    INSERT INTO t7 VALUES (1, 'x', 10, 1.5), (2, 'y', 20, 2.5), (3, 'z', 30, 3.5);
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with expression index (rowid-at-end-of-record check)
test integrity-check-expression-index-rowid {
    CREATE TABLE t8(id INTEGER PRIMARY KEY, name TEXT);
    CREATE INDEX idx_t8_lower ON t8(lower(name));
    INSERT INTO t8 VALUES (1, 'Hello'), (2, 'WORLD'), (3, 'FoO');
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with partial index (rowid-at-end-of-record check)
test integrity-check-partial-index-rowid {
    CREATE TABLE t9(id INTEGER PRIMARY KEY, val INTEGER, active INTEGER);
    CREATE INDEX idx_t9_partial ON t9(val) WHERE active = 1;
    INSERT INTO t9 VALUES (1, 100, 1), (2, 200, 0), (3, 300, 1), (4, 400, 0);
    PRAGMA integrity_check;
}
expect {
    ok
}

# Test integrity_check with NULL values in indexed columns (rowid-at-end-of-record check)
test integrity-check-null-indexed-cols-rowid {
    CREATE TABLE t10(id INTEGER PRIMARY KEY, a TEXT, b INTEGER);
    CREATE INDEX idx_t10_a ON t10(a);
    CREATE UNIQUE INDEX idx_t10_b ON t10(b);
    INSERT INTO t10 VALUES (1, NULL, NULL), (2, 'hello', 42), (3, NULL, NULL);
    PRAGMA integrity_check;
}
expect {
    ok
}

