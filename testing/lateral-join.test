#!/usr/bin/env tclsh

# Tests for LATERAL JOIN functionality
# Based on Master's thesis "Lateral Join for SQLite" by Jonatan Braun (2021)
#
# Note: LATERAL JOIN currently works with subqueries as the left-side table.
# Support for BTree tables as the left-side requires additional changes to
# the cursor emission order and is a future enhancement.

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Basic LATERAL JOIN with simple value binding
# The subquery references the outer value 'x' from q1
do_execsql_test lateral-basic-value-binding {
    SELECT * FROM (SELECT 42 AS x) AS q1 LATERAL JOIN (SELECT x + 1 AS res) AS result;
} {42|43}

# Chained LATERAL JOINs (like thesis example)
# Each subsequent subquery can reference columns from all preceding tables
do_execsql_test lateral-chained {
    SELECT result.res FROM
        (SELECT 42 AS x) AS q1
        LATERAL JOIN (SELECT x AS y_2) AS let1
        LATERAL JOIN (SELECT y_2 + 1 AS res) AS result;
} {43}

# Multiple LATERAL with references to different preceding tables
do_execsql_test lateral-multiple-references {
    SELECT * FROM
        (SELECT 10 AS a) AS t1
        LATERAL JOIN (SELECT a * 2 AS b) AS t2
        LATERAL JOIN (SELECT a + b AS c) AS t3;
} {10|20|30}

# LATERAL JOIN vs regular JOIN - LATERAL can reference outer, regular cannot
# This shows that LATERAL actually makes the reference work
do_execsql_test lateral-versus-regular-join {
    SELECT * FROM (SELECT 5 AS x) AS outer_tbl LATERAL JOIN (SELECT x * x AS square) AS inner_tbl;
} {5|25}

# LATERAL with nested computation
do_execsql_test lateral-nested-computation {
    SELECT result
    FROM (SELECT 100 AS base) AS q1
    LATERAL JOIN (SELECT base / 10 AS tenth) AS q2
    LATERAL JOIN (SELECT tenth + 5 AS result) AS q3;
} {15}

# LATERAL with string values
do_execsql_test lateral-string-values {
    SELECT * FROM (SELECT 'hello' AS greeting) AS q1 LATERAL JOIN (SELECT greeting || ' world' AS message) AS q2;
} {hello|hello\ world}

# LATERAL referencing multiple columns from preceding subquery
do_execsql_test lateral-multiple-columns {
    SELECT sum
    FROM (SELECT 1 AS a, 2 AS b, 3 AS c) AS q1
    LATERAL JOIN (SELECT a + b + c AS sum) AS q2;
} {6}

# Error: LATERAL on non-subquery should fail
do_catchsql_test lateral-error-non-subquery {
    CREATE TABLE IF NOT EXISTS dummy1 (x INTEGER);
    SELECT * FROM dummy1 LATERAL JOIN dummy1;
} {1 {LATERAL can only be applied to subqueries}}

# Cleanup
do_execsql_test lateral-cleanup-error-test {
    DROP TABLE IF EXISTS dummy1;
} {}

# Error: LEFT LATERAL JOIN should fail (not supported)
do_catchsql_test lateral-error-left-lateral {
    SELECT * FROM (SELECT 1 AS x) AS t1 LEFT LATERAL JOIN (SELECT x) AS t2;
} {1 {LEFT/RIGHT LATERAL JOIN is not yet supported}}

# Error: RIGHT LATERAL JOIN should fail (not supported)
do_catchsql_test lateral-error-right-lateral {
    SELECT * FROM (SELECT 1 AS x) AS t1 RIGHT LATERAL JOIN (SELECT x) AS t2;
} {1 {RIGHT JOIN is not supported}}

# Error: LATERAL with base table on left side (not yet supported)
# This is a current limitation - LATERAL only works with subqueries as preceding tables.
# Support for BTree tables requires changes to cursor emission order (future work).
do_catchsql_test lateral-error-btree-left-side {
    CREATE TABLE IF NOT EXISTS base_tbl (x INTEGER);
    SELECT * FROM base_tbl LATERAL JOIN (SELECT x * 10 AS y) AS sub;
} {1 {LATERAL JOIN currently only supports subqueries as preceding tables, not base tables like 'base_tbl'}}

# Cleanup base_tbl
do_execsql_test lateral-cleanup-btree-test {
    DROP TABLE IF EXISTS base_tbl;
} {}

# ============================================================================
# Additional edge case tests (addressing review feedback)
# ============================================================================

# LATERAL with NULL values - ensure NULL propagation works correctly
do_execsql_test lateral-null-handling-basic {
    SELECT * FROM (SELECT NULL AS x) AS q1 LATERAL JOIN (SELECT x IS NULL AS is_null) AS q2;
} {|1}

# LATERAL with NULL in arithmetic - NULL propagation
do_execsql_test lateral-null-arithmetic {
    SELECT * FROM (SELECT NULL AS x) AS q1 LATERAL JOIN (SELECT x + 10 AS result) AS q2;
} {|}

# LATERAL with COALESCE to handle NULL
do_execsql_test lateral-null-coalesce {
    SELECT result FROM (SELECT NULL AS x) AS q1 LATERAL JOIN (SELECT COALESCE(x, 0) + 5 AS result) AS q2;
} {5}

# LATERAL with WHERE clause filtering
do_execsql_test lateral-where-clause-basic {
    SELECT * FROM
        (SELECT 10 AS x) AS q1
        LATERAL JOIN (SELECT x * 2 AS doubled WHERE x > 5) AS q2;
} {10|20}

# LATERAL with WHERE clause that filters out (empty result)
do_execsql_test lateral-where-clause-filter-out {
    SELECT * FROM
        (SELECT 3 AS x) AS q1
        LATERAL JOIN (SELECT x * 2 AS doubled WHERE x > 5) AS q2;
} {}

# Deeply nested LATERAL chains (4 levels)
do_execsql_test lateral-deep-nesting-4-levels {
    SELECT result FROM
        (SELECT 1 AS a) AS t1
        LATERAL JOIN (SELECT a + 1 AS b) AS t2
        LATERAL JOIN (SELECT b + 1 AS c) AS t3
        LATERAL JOIN (SELECT c + 1 AS d) AS t4
        LATERAL JOIN (SELECT a + b + c + d AS result) AS t5;
} {10}

# Deeply nested LATERAL with mixed references (referencing non-adjacent tables)
do_execsql_test lateral-deep-mixed-refs {
    SELECT * FROM
        (SELECT 100 AS base) AS t1
        LATERAL JOIN (SELECT base / 10 AS step1) AS t2
        LATERAL JOIN (SELECT base / 100 AS step2) AS t3
        LATERAL JOIN (SELECT base + step1 + step2 AS total) AS t4;
} {100|10|1|111}

# LATERAL with aggregate function in subquery
do_execsql_test lateral-aggregate-simple {
    SELECT * FROM
        (SELECT 5 AS x) AS q1
        LATERAL JOIN (SELECT MAX(x, 10) AS bigger) AS q2;
} {5|10}

# LATERAL with multiple aggregate-like functions
do_execsql_test lateral-multiple-functions {
    SELECT * FROM
        (SELECT 3 AS x, 7 AS y) AS q1
        LATERAL JOIN (SELECT MIN(x, y) AS smaller, MAX(x, y) AS bigger, ABS(x - y) AS diff) AS q2;
} {3|7|3|7|4}

# LATERAL with CASE expression
do_execsql_test lateral-case-expression {
    SELECT category FROM
        (SELECT 85 AS score) AS q1
        LATERAL JOIN (SELECT CASE WHEN score >= 90 THEN 'A' WHEN score >= 80 THEN 'B' ELSE 'C' END AS category) AS q2;
} {B}

# LATERAL with type coercion (integer to string concatenation)
do_execsql_test lateral-type-coercion {
    SELECT result FROM
        (SELECT 42 AS num) AS q1
        LATERAL JOIN (SELECT 'Value: ' || num AS result) AS q2;
} {Value:\\ 42}

# LATERAL with boolean expressions
do_execsql_test lateral-boolean-expr {
    SELECT * FROM
        (SELECT 10 AS x, 20 AS y) AS q1
        LATERAL JOIN (SELECT x < y AS less_than, x = y AS equal, x > y AS greater_than) AS q2;
} {10|20|1|0|0}

# LATERAL with BETWEEN operator
do_execsql_test lateral-between-operator {
    SELECT in_range FROM
        (SELECT 15 AS val, 10 AS low, 20 AS high) AS q1
        LATERAL JOIN (SELECT val BETWEEN low AND high AS in_range) AS q2;
} {1}

# LATERAL with IN operator (literal list)
do_execsql_test lateral-in-operator {
    SELECT is_vowel FROM
        (SELECT 'a' AS letter) AS q1
        LATERAL JOIN (SELECT letter IN ('a', 'e', 'i', 'o', 'u') AS is_vowel) AS q2;
} {1}

# LATERAL preserving column ordering
do_execsql_test lateral-column-ordering {
    SELECT t1.a, t2.b, t3.c, t4.d FROM
        (SELECT 1 AS a) AS t1
        LATERAL JOIN (SELECT 2 AS b) AS t2
        LATERAL JOIN (SELECT 3 AS c) AS t3
        LATERAL JOIN (SELECT 4 AS d) AS t4;
} {1|2|3|4}

# LATERAL with empty string
do_execsql_test lateral-empty-string {
    SELECT * FROM (SELECT '' AS x) AS q1 LATERAL JOIN (SELECT LENGTH(x) AS len, x || 'suffix' AS concat) AS q2;
} {|0|suffix}

# LATERAL with negative numbers
do_execsql_test lateral-negative-numbers {
    SELECT * FROM
        (SELECT -5 AS x) AS q1
        LATERAL JOIN (SELECT ABS(x) AS absolute, x * -1 AS negated) AS q2;
} {-5|5|5}

# LATERAL with floating point numbers
do_execsql_test lateral-float-numbers {
    SELECT * FROM
        (SELECT 3.14159 AS pi) AS q1
        LATERAL JOIN (SELECT ROUND(pi, 2) AS rounded) AS q2;
} {3.14159|3.14}

# LATERAL with expression in the left-side subquery
do_execsql_test lateral-complex-left-expr {
    SELECT result FROM
        (SELECT (10 + 20) * 2 AS computed) AS q1
        LATERAL JOIN (SELECT computed / 6 AS result) AS q2;
} {10}

# LATERAL with DISTINCT in inner subquery (testing dedup)
do_execsql_test lateral-with-distinct {
    SELECT * FROM
        (SELECT 5 AS x) AS q1
        LATERAL JOIN (SELECT DISTINCT x AS val) AS q2;
} {5|5}

# Test that regular (non-LATERAL) join still cannot reference outer columns
# This verifies LATERAL is actually needed for the cross-reference
do_catchsql_test lateral-verify-regular-join-fails {
    SELECT * FROM (SELECT 5 AS x) AS outer_tbl JOIN (SELECT x * x AS square) AS inner_tbl;
} {1 {no such column: x}}

# ============================================================================
# Additional LATERAL tests
# ============================================================================

# Empty left side - should produce no rows
do_execsql_test lateral-empty-left-side {
    SELECT * FROM
        (SELECT 1 AS x WHERE 0) AS t1
        LATERAL JOIN (SELECT x + 100 AS y) AS t2;
} {}

# LATERAL with filtering in subquery
do_execsql_test lateral-with-filter {
    SELECT * FROM
        (SELECT 10 AS x) AS t1
        LATERAL JOIN (SELECT x * 2 AS y WHERE x > 5) AS t2;
} {10|20}

# LATERAL subquery with WHERE that filters out - empty result
do_execsql_test lateral-filter-empty {
    SELECT * FROM
        (SELECT 3 AS x) AS t1
        LATERAL JOIN (SELECT x * 10 AS y WHERE x > 5) AS t2;
} {}

# ============================================================================
# Mixed join tests - LATERAL combined with regular joins
# ============================================================================

# Regular join followed by LATERAL
do_execsql_test lateral-mixed-regular-then-lateral {
    SELECT * FROM
        (SELECT 1 AS a) AS t1
        JOIN (SELECT 2 AS b) AS t2
        LATERAL JOIN (SELECT a + b AS c) AS t3;
} {1|2|3}

# ============================================================================
# Column shadowing and ambiguity tests
# ============================================================================

# LATERAL subquery can shadow outer column names
do_execsql_test lateral-column-shadowing {
    SELECT t2.x FROM
        (SELECT 10 AS x) AS t1
        LATERAL JOIN (SELECT x + 1 AS x) AS t2;
} {11}

# Both outer and inner columns accessible with qualification
do_execsql_test lateral-qualified-access {
    SELECT t1.x, t2.y, t1.x + t2.y AS sum FROM
        (SELECT 5 AS x) AS t1
        LATERAL JOIN (SELECT x * 2 AS y) AS t2;
} {5|10|15}

# ============================================================================
# True aggregate tests (as opposed to scalar MAX/MIN functions)
# These tests use actual aggregate functions over multiple rows
# ============================================================================

# Setup table for aggregate tests
do_execsql_test lateral-aggregate-setup {
    CREATE TABLE agg_test (id INTEGER PRIMARY KEY, category TEXT, value INTEGER);
    INSERT INTO agg_test VALUES (1, 'A', 10), (2, 'A', 20), (3, 'B', 30), (4, 'B', 40), (5, 'B', 50);
} {}

# LATERAL with COUNT aggregate - count items matching outer reference
do_execsql_test lateral-true-aggregate-count {
    SELECT cat.category, item_count.cnt FROM
        (SELECT DISTINCT category FROM agg_test) AS cat
        LATERAL JOIN (SELECT COUNT(*) AS cnt FROM agg_test WHERE category = cat.category) AS item_count
    ORDER BY cat.category;
} {A|2
B|3}

# LATERAL with SUM aggregate
do_execsql_test lateral-true-aggregate-sum {
    SELECT cat.category, totals.total FROM
        (SELECT DISTINCT category FROM agg_test) AS cat
        LATERAL JOIN (SELECT SUM(value) AS total FROM agg_test WHERE category = cat.category) AS totals
    ORDER BY cat.category;
} {A|30
B|120}

# LATERAL with AVG aggregate
do_execsql_test lateral-true-aggregate-avg {
    SELECT cat.category, avgs.average FROM
        (SELECT DISTINCT category FROM agg_test) AS cat
        LATERAL JOIN (SELECT AVG(value) AS average FROM agg_test WHERE category = cat.category) AS avgs
    ORDER BY cat.category;
} {A|15.0
B|40.0}

# LATERAL with multiple aggregates in same subquery
do_execsql_test lateral-true-aggregate-multiple {
    SELECT cat.category, stats.cnt, stats.total, stats.avg_val FROM
        (SELECT DISTINCT category FROM agg_test) AS cat
        LATERAL JOIN (
            SELECT COUNT(*) AS cnt, SUM(value) AS total, AVG(value) AS avg_val
            FROM agg_test WHERE category = cat.category
        ) AS stats
    ORDER BY cat.category;
} {A|2|30|15.0
B|3|120|40.0}

# Cleanup aggregate test table
do_execsql_test lateral-aggregate-cleanup {
    DROP TABLE agg_test;
} {}

# ============================================================================
# ORDER BY and LIMIT tests inside LATERAL subqueries
# ============================================================================

# Setup table for ORDER BY/LIMIT tests
do_execsql_test lateral-orderby-setup {
    CREATE TABLE items (id INTEGER PRIMARY KEY, grp TEXT, val INTEGER);
    INSERT INTO items VALUES (1, 'X', 100), (2, 'X', 200), (3, 'X', 150);
    INSERT INTO items VALUES (4, 'Y', 50), (5, 'Y', 75), (6, 'Y', 25);
} {}

# LATERAL with ORDER BY to get max value per group
do_execsql_test lateral-orderby-desc {
    SELECT g.grp, top.val FROM
        (SELECT DISTINCT grp FROM items) AS g
        LATERAL JOIN (SELECT val FROM items WHERE grp = g.grp ORDER BY val DESC LIMIT 1) AS top
    ORDER BY g.grp;
} {X|200
Y|75}

# LATERAL with ORDER BY ASC to get min value per group
do_execsql_test lateral-orderby-asc {
    SELECT g.grp, bottom.val FROM
        (SELECT DISTINCT grp FROM items) AS g
        LATERAL JOIN (SELECT val FROM items WHERE grp = g.grp ORDER BY val ASC LIMIT 1) AS bottom
    ORDER BY g.grp;
} {X|100
Y|25}

# LATERAL with LIMIT 2 - top N per group
do_execsql_test lateral-limit-top-n {
    SELECT g.grp, top2.val FROM
        (SELECT DISTINCT grp FROM items) AS g
        LATERAL JOIN (SELECT val FROM items WHERE grp = g.grp ORDER BY val DESC LIMIT 2) AS top2
    ORDER BY g.grp, top2.val DESC;
} {X|200
X|150
Y|75
Y|50}

# LATERAL with OFFSET
do_execsql_test lateral-limit-offset {
    SELECT g.grp, second.val FROM
        (SELECT DISTINCT grp FROM items) AS g
        LATERAL JOIN (SELECT val FROM items WHERE grp = g.grp ORDER BY val DESC LIMIT 1 OFFSET 1) AS second
    ORDER BY g.grp;
} {X|150
Y|50}

# Cleanup ORDER BY/LIMIT test table
do_execsql_test lateral-orderby-cleanup {
    DROP TABLE items;
} {}

# ============================================================================
# CTE (Common Table Expression) with LATERAL tests
# ============================================================================

# CTE with LATERAL referencing CTE column in computation
do_execsql_test lateral-cte-computation {
    WITH base AS (SELECT 5 AS x)
    SELECT x, computed.result FROM base
    LATERAL JOIN (SELECT x * x + x AS result) AS computed;
} {5|30}

# Multiple CTEs with LATERAL
do_execsql_test lateral-cte-multiple {
    WITH
        a AS (SELECT 2 AS val),
        b AS (SELECT 3 AS multiplier)
    SELECT a.val, b.multiplier, product.p FROM
        a JOIN b ON 1=1
        LATERAL JOIN (SELECT a.val * b.multiplier AS p) AS product;
} {2|3|6}

# CTE with chained LATERAL joins
do_execsql_test lateral-cte-chained {
    WITH source AS (SELECT 100 AS base_val)
    SELECT s.base_val, step1.half, step2.quarter FROM source AS s
    LATERAL JOIN (SELECT base_val / 2 AS half) AS step1
    LATERAL JOIN (SELECT half / 2 AS quarter) AS step2;
} {100|50|25}

# ============================================================================
# Depth limit tests
# ============================================================================

# Test that deeply nested LATERAL joins are rejected when exceeding the limit.
# The maximum subquery depth is 100, so 101+ nested levels should fail.
# We build the query dynamically using TCL to avoid writing 101 joins manually.
set depth_limit_query "SELECT * FROM (SELECT 1 AS x0) AS t0"
for {set i 1} {$i <= 101} {incr i} {
    set prev [expr {$i - 1}]
    append depth_limit_query " LATERAL JOIN (SELECT x$prev AS x$i) AS t$i"
}
do_catchsql_test lateral-depth-limit-exceeded $depth_limit_query {1 {subquery nesting depth exceeds maximum of 100}}

# Verify that 100 levels of nesting (just at the limit) succeeds
set depth_at_limit_query "SELECT t99.x99 FROM (SELECT 1 AS x0) AS t0"
for {set i 1} {$i < 100} {incr i} {
    set prev [expr {$i - 1}]
    append depth_at_limit_query " LATERAL JOIN (SELECT x$prev + 1 AS x$i) AS t$i"
}
do_execsql_test lateral-depth-at-limit $depth_at_limit_query {100}

# ============================================================================
# Forward reference rejection tests
# ============================================================================

# LATERAL should not be able to reference tables that come AFTER it in the FROM clause.
# This tests that the scoping is correct - only preceding tables are visible.
# For qualified column references (table.column), the error is "no such table"
# because the table lookup fails before column lookup.
do_catchsql_test lateral-forward-reference-rejected {
    SELECT * FROM
        (SELECT 1 AS x) AS t1
        LATERAL JOIN (SELECT later.y AS val) AS t2
        JOIN (SELECT 2 AS y) AS later;
} {1 {no such table: later}}

# Forward reference with unqualified column name should also fail
do_catchsql_test lateral-forward-reference-unqualified {
    SELECT * FROM
        (SELECT 1 AS a) AS first_tbl
        LATERAL JOIN (SELECT future_col * 2 AS result) AS middle
        JOIN (SELECT 99 AS future_col) AS last_tbl;
} {1 {no such column: future_col}}

finish_test
