## path=../../.github/workflows/go-publish.yml
name: Build & Publish Go Driver

on:
  workflow_dispatch:
  push:
    branches: ["main"]
    tags:
      - "v*"
  pull_request:
    branches: ["main"]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

env:
  # Token with repo access to tursodatabase/turso-go-platform-libs
  GH_TOKEN: ${{ secrets.TURSO_GO_PLATFORM_LIBS_TOKEN }}
  CARGO_INCREMENTAL: "0"
  CARGO_NET_RETRY: 10

jobs:
  test:
    name: Build Rust and run Go tests
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    strategy:
      matrix:
        os:
          - blacksmith-4vcpu-ubuntu-2404
          - macos-latest
          - windows-latest
    env:
      CARGO_TERM_COLOR: always
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Setup mold linker
        if: runner.os == 'Linux'
        uses: rui314/setup-mold@v1
      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: "v1-rust"
          cache-on-failure: true
      - uses: "./.github/shared/setup-sccache"

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.24.10"
          cache: true
          cache-dependency-path: bindings/go/go.sum

      - name: Build Rust (debug)
        run: cargo build --verbose --locked

      # Linux: use LD_LIBRARY_PATH to point to Rust target dir
      - name: Run Go tests (Linux)
        if: runner.os == 'Linux'
        working-directory: bindings/go
        env:
          LOCAL_SYNC_SERVER: ../../target/debug/tursodb
          LD_LIBRARY_PATH: ${{ github.workspace }}/target/debug
        run: go test ./... -v

      # macOS: use DYLD_LIBRARY_PATH to point to Rust target dir
      - name: Run Go tests (macOS)
        if: runner.os == 'macOS'
        working-directory: bindings/go
        env:
          LOCAL_SYNC_SERVER: ../../target/debug/tursodb
          DYLD_LIBRARY_PATH: ${{ github.workspace }}/target/debug
        run: go test ./... -v

      # Windows: prepend Rust target dir to PATH so .dll can be found
      - name: Run Go tests (Windows)
        if: runner.os == 'Windows'
        working-directory: bindings/go
        shell: pwsh
        run: |
          $env:PATH = "${{ github.workspace }}\target\debug;$env:PATH"
          $env:LOCAL_SYNC_SERVER = "..\..\target\debug\tursodb.exe"
          go test ./... -v

  publish:
    name: Publish Go driver
    needs: test
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure tooling (jq, coreutils)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq coreutils

      - name: Compute publish variables
        id: vars
        shell: bash
        run: |
          set -euo pipefail

          EVENT="${{ github.event_name }}"
          REF="${{ github.ref }}"

          # Determine whether to publish for real:
          # - Manual dispatch: publish
          # - Tag push (refs/tags/v*): publish
          # - Everything else (including PR): dry-run
          if [[ "$EVENT" == "workflow_dispatch" ]]; then
            DO_PUBLISH="true"
          elif [[ "$REF" == refs/tags/v* ]]; then
            DO_PUBLISH="true"
          else
            DO_PUBLISH="false"
          fi

          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            # For tag events, github.ref_name is correct
            TURSO_REF="${GITHUB_REF_NAME}"
          elif [[ -n "${GITHUB_HEAD_REF}" ]]; then
            # For PRs, github.head_ref contains the real source branch
            TURSO_REF="${GITHUB_HEAD_REF}"
          else
            # For push events to branches
            TURSO_REF="${GITHUB_REF_NAME}"
          fi

          # Branch to push into this repository
          if [[ "$EVENT" == "workflow_dispatch" ]]; then
            TARGET_TAG=""
            TARGET_BRANCH="go-release-${TURSO_REF}"
          elif [[ "$REF" == refs/tags/* ]]; then
            TARGET_TAG="${TURSO_REF}"
            TARGET_BRANCH="go-release-${TURSO_REF}"
          else
            TARGET_TAG=""
            TARGET_BRANCH="go-release-${TURSO_REF}"
          fi

          # Generate a unique nonce
          NONCE="$(uuidgen 2>/dev/null || true)"
          if [[ -z "$NONCE" ]]; then
            NONCE="$(date +%s)-$RANDOM-$RANDOM"
          fi

          echo "do_publish=$DO_PUBLISH" >> "$GITHUB_OUTPUT"
          echo "turso_ref=$TURSO_REF" >> "$GITHUB_OUTPUT"
          echo "target_branch=$TARGET_BRANCH" >> "$GITHUB_OUTPUT"
          echo "target_tag=$TARGET_TAG" >> "$GITHUB_OUTPUT"
          echo "nonce=$NONCE" >> "$GITHUB_OUTPUT"

          echo "Event: $EVENT"
          echo "Ref: $REF"
          echo "DO_PUBLISH=$DO_PUBLISH"
          echo "TURSO_REF=$TURSO_REF"
          echo "TARGET_BRANCH=$TARGET_BRANCH"
          echo "TARGET_TAG=$TARGET_TAG"
          echo "NONCE=$NONCE"

      - name: Dry-run (PRs and non-tag non-manual runs)
        if: steps.vars.outputs.do_publish != 'true'
        run: |
          echo "Dry run: not triggering turso-go-platform-libs and not pushing any commits."
          echo "Would have used:"
          echo " - turso_ref=${{ steps.vars.outputs.turso_ref }}"
          echo " - target_branch=${{ steps.vars.outputs.target_branch }}"
          echo " - nonce=${{ steps.vars.outputs.nonce }}"
          echo "Exiting."

      - name: Check token available for external repo
        if: steps.vars.outputs.do_publish == 'true'
        shell: bash
        run: |
          if [[ -z "${GH_TOKEN:-}" ]]; then
            echo "TURSO_GO_PLATFORM_LIBS_TOKEN is not set; cannot publish."
            exit 1
          fi

      # Trigger turso-go-platform-libs build+publish workflow
      - name: Trigger external prebuilt-libs workflow
        if: steps.vars.outputs.do_publish == 'true'
        shell: bash
        env:
          TURSO_REF: ${{ steps.vars.outputs.turso_ref }}
          NONCE: ${{ steps.vars.outputs.nonce }}
        run: |
          set -euo pipefail
          echo "Triggering tursodatabase/turso-go-platform-libs build.yml with:"
          echo " - turso_ref=$TURSO_REF"
          echo " - push_changes=true"
          echo " - nonce=$NONCE"

          # Use gh to dispatch workflow
          gh workflow run build.yml \
            -R tursodatabase/turso-go-platform-libs \
            -f turso_ref="$TURSO_REF" \
            -f push_changes=true \
            -f nonce="$NONCE"

      # Wait for the external workflow to complete by locating the run that has our nonce in job names
      - name: Wait for external workflow completion
        if: steps.vars.outputs.do_publish == 'true'
        id: wait_external
        shell: bash
        env:
          NONCE: ${{ steps.vars.outputs.nonce }}
        run: |
          set -euo pipefail

          REPO="tursodatabase/turso-go-platform-libs"
          WORKFLOW_FILE="build.yml"

          echo "Searching for workflow run in $REPO matching nonce=$NONCE"

          # Try to find the run that includes the nonce in job names.
          FOUND_RUN_ID=""
          ATTEMPTS=0
          MAX_ATTEMPTS=60   # ~15 minutes (with 15s sleep)
          while [[ -z "$FOUND_RUN_ID" && $ATTEMPTS -lt $MAX_ATTEMPTS ]]; do
            ATTEMPTS=$((ATTEMPTS+1))
            # Fetch recent runs of the workflow
            RUN_IDS=$(gh api -H "Accept: application/vnd.github+json" \
              repos/$REPO/actions/workflows/$WORKFLOW_FILE/runs \
              -q '.workflow_runs[0:30][] | .id' || true)

            for RID in $RUN_IDS; do
              # List jobs and search for nonce in any job name
              if gh api -H "Accept: application/vnd.github+json" repos/$REPO/actions/runs/$RID/jobs -q '.jobs[].name' | grep -q "nonce=${NONCE}"; then
                FOUND_RUN_ID="$RID"
                break
              fi
            done

            if [[ -z "$FOUND_RUN_ID" ]]; then
              echo "Nonce not found yet (attempt $ATTEMPTS/$MAX_ATTEMPTS). Sleeping 15s..."
              sleep 15
            fi
          done

          if [[ -z "$FOUND_RUN_ID" ]]; then
            echo "Failed to locate external workflow run with nonce=$NONCE"
            exit 1
          fi

          echo "Found external run id: $FOUND_RUN_ID"
          echo "run_id=$FOUND_RUN_ID" >> "$GITHUB_OUTPUT"

          echo "Waiting for external run to complete..."
          while true; do
            STATUS=$(gh api repos/$REPO/actions/runs/$FOUND_RUN_ID -q '.status')
            CONCLUSION=$(gh api repos/$REPO/actions/runs/$FOUND_RUN_ID -q '.conclusion')
            echo "Status: $STATUS, Conclusion: $CONCLUSION"
            if [[ "$STATUS" == "completed" ]]; then
              if [[ "$CONCLUSION" != "success" ]]; then
                echo "External workflow did not succeed. Conclusion: $CONCLUSION"
                exit 1
              fi
              break
            fi
            sleep 15
          done

      - name: Determine libs branch name from turso_ref
        if: steps.vars.outputs.do_publish == 'true'
        id: libs_branch
        shell: bash
        env:
          TURSO_REF: ${{ steps.vars.outputs.turso_ref }}
        run: |
          set -euo pipefail
          BRANCH="turso-branch-$TURSO_REF"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"
          echo "Resolved libs branch: $BRANCH"

      - name: Setup Go (for dependency update)
        if: steps.vars.outputs.do_publish == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: "1.24.10"

      - name: Create branch
        if: steps.vars.outputs.do_publish == 'true'
        shell: bash
        working-directory: bindings/go
        env:
          TARGET_TAG: ${{ steps.vars.outputs.target_tag }}
          TARGET_BRANCH: ${{ steps.vars.outputs.target_branch }}
          NONCE: ${{ steps.vars.outputs.nonce }}
          RESOLVED_VERSION: ${{ steps.update_dep.outputs.resolved_version }}
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create/update branch
          # If branch exists locally/remote, check it out; otherwise create
          if git ls-remote --exit-code --heads origin "$TARGET_BRANCH" >/dev/null 2>&1; then
            echo "Branch $TARGET_BRANCH exists on remote â€” checking it out."
            git fetch origin "$TARGET_BRANCH":"$TARGET_BRANCH"
            git checkout "$TARGET_BRANCH"
          else
            echo "Creating new branch $TARGET_BRANCH"
            git checkout -b "$TARGET_BRANCH"
          fi

      - name: Update dependency to freshly built libs
        if: steps.vars.outputs.do_publish == 'true'
        id: update_dep
        working-directory: bindings/go
        shell: bash
        env:
          LIBS_BRANCH: ${{ steps.libs_branch.outputs.branch }}
        run: |
          set -euo pipefail
          echo "Updating github.com/tursodatabase/turso-go-platform-libs to branch: $LIBS_BRANCH"

          # Update dependency and tidy
          go get "github.com/tursodatabase/turso-go-platform-libs@${LIBS_BRANCH}"
          go mod tidy

          # Determine the resolved pseudo-version
          RESOLVED_VERSION="$(go list -m -json github.com/tursodatabase/turso-go-platform-libs | jq -r .Version)"
          echo "resolved_version=$RESOLVED_VERSION" >> "$GITHUB_OUTPUT"
          echo "Resolved version: $RESOLVED_VERSION"

          echo "Changed files:"
          git status --porcelain

      - name: Push branch and tag with updated go.mod
        if: steps.vars.outputs.do_publish == 'true'
        shell: bash
        working-directory: bindings/go
        env:
          TARGET_TAG: ${{ steps.vars.outputs.target_tag }}
          TARGET_BRANCH: ${{ steps.vars.outputs.target_branch }}
          NONCE: ${{ steps.vars.outputs.nonce }}
          RESOLVED_VERSION: ${{ steps.update_dep.outputs.resolved_version }}
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Stage changes if any
          git add go.mod go.sum || true

          if git diff --cached --quiet; then
            echo "No changes in go.mod/go.sum to commit; skipping push."
            exit 0
          fi

          COMMIT_MSG="go: update turso-go-platform-libs to ${RESOLVED_VERSION} (nonce: ${NONCE})"
          git commit -m "$COMMIT_MSG"

          # Push branch
          git push --set-upstream origin "$TARGET_BRANCH" --force-with-lease || git push --set-upstream origin "$TARGET_BRANCH"

          echo "Pushed branch: $TARGET_BRANCH"

          if [[ "$TARGET_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+([\-+][0-9A-Za-z\.-]+)?$ ]]; then
            # module is in the subdirectory - prepend path to the version tag
            git tag "bindings/go/$TARGET_TAG"
            git push origin tag "bindings/go/$TARGET_TAG"
          fi
