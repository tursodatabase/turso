@database :memory:

@skip-if mvcc "cdc not supported in MVCC mode"
test basic-txn-id {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT);

    BEGIN;
    INSERT INTO t VALUES (1);
    INSERT INTO t VALUES (2);
    COMMIT;

    BEGIN;
    INSERT INTO t VALUES (3);
    COMMIT;

    -- Check transaction IDs - all changes in same transaction should have same txn_id
    -- CREATE TABLE uses txn_id 1, first transaction uses 3, COMMIT advances counter, second uses 6
    SELECT change_type, table_name, change_txn_id
    FROM turso_cdc
    WHERE table_name != 'sqlite_schema'
    ORDER BY change_id;
}
expect {
    1|t|3
    1|t|3
    1|t|6
}

@skip-if mvcc "cdc not supported in MVCC mode"
test auto-commit-txn-id {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT);

    -- Single statements in auto-commit mode
    INSERT INTO t VALUES (1);
    INSERT INTO t VALUES (2);
    INSERT INTO t VALUES (3);

    -- Each should get unique txn_id (CREATE TABLE = 1, INSERTs = 3, 5, 7)
    SELECT change_type, table_name, change_txn_id
    FROM turso_cdc
    WHERE table_name != 'sqlite_schema'
    ORDER BY change_id;
}
expect {
    1|t|3
    1|t|5
    1|t|7
}

@skip-if mvcc "cdc not supported in MVCC mode"
test rollback-no-cdc-records {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT);

    BEGIN;
    INSERT INTO t VALUES (1);
    ROLLBACK;

    BEGIN;
    INSERT INTO t VALUES (2);
    COMMIT;

    -- Only committed transaction should appear in CDC (CREATE TABLE = 1, second INSERT = 3)
    SELECT change_type, table_name, change_txn_id
    FROM turso_cdc
    WHERE table_name != 'sqlite_schema'
    ORDER BY change_id;
}
expect {
    1|t|3
}

@skip-if mvcc "cdc not supported in MVCC mode"
test empty-transaction-no-cdc {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT);

    BEGIN;
    COMMIT;

    INSERT INTO t VALUES (1);

    -- Empty transaction should not generate any CDC records for table_name=t
    -- CREATE TABLE = 1, INSERT = 4 (empty BEGIN/COMMIT doesn't get CDC records)
    SELECT change_type, table_name, change_txn_id
    FROM turso_cdc
    WHERE table_name != 'sqlite_schema'
    ORDER BY change_id;
}
expect {
    1|t|4
}

@skip-if mvcc "cdc not supported in MVCC mode"
test mixed-dml-same-txn-id {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT PRIMARY KEY, y INT);

    BEGIN;
    INSERT INTO t VALUES (1, 100);
    UPDATE t SET y = 200 WHERE x = 1;
    DELETE FROM t WHERE x = 1;
    COMMIT;

    -- All changes in same transaction should have same txn_id
    -- CREATE TABLE = 1, transaction = 3
    SELECT change_type, change_txn_id
    FROM turso_cdc
    WHERE table_name != 'sqlite_schema'
    ORDER BY change_id;
}
expect {
    1|3
    0|3
    -1|3
}

@skip-if mvcc "cdc not supported in MVCC mode"
test explicit-commit-record {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT);

    BEGIN;
    INSERT INTO t VALUES (1);
    INSERT INTO t VALUES (2);
    COMMIT;

    -- Check for COMMIT record (change_type=2) at end of transaction
    -- CREATE TABLE emits COMMIT (txn_id 1), then transaction emits COMMIT (txn_id 3)
    SELECT change_type, table_name, change_txn_id
    FROM turso_cdc
    WHERE table_name != 'sqlite_schema' OR table_name IS NULL
    ORDER BY change_id;
}
expect {
    2||1
    1|t|3
    1|t|3
    2||3
}

@skip-if mvcc "cdc not supported in MVCC mode"
test autocommit-commit-records {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT);

    -- Each statement in auto-commit mode should get a COMMIT record
    INSERT INTO t VALUES (1);
    INSERT INTO t VALUES (2);

    -- Check that each statement has a COMMIT record with matching txn_id
    -- CREATE TABLE gets COMMIT at txn_id 1, first INSERT at 3, second at 5
    SELECT change_type, table_name, change_txn_id
    FROM turso_cdc
    WHERE table_name != 'sqlite_schema' OR table_name IS NULL
    ORDER BY change_id;
}
expect {
    2||1
    1|t|3
    2||3
    1|t|5
    2||5
}

@skip-if mvcc "cdc not supported in MVCC mode"
test commit-record-fields-null {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT PRIMARY KEY);

    BEGIN;
    INSERT INTO t VALUES (1);
    COMMIT;

    -- Verify COMMIT record has NULLs for table_name, id, before, after, updates
    -- CREATE TABLE emits one, explicit COMMIT emits another
    SELECT change_type, table_name, id, before, after, updates
    FROM turso_cdc
    WHERE change_type = 2;
}
expect {
    2|||||
    2|||||
}

@skip-if mvcc "cdc not supported in MVCC mode"
test prepared-statement-reuse {
    PRAGMA unstable_capture_data_changes_conn='full';
    CREATE TABLE t (x INT);

    -- Execute same statement in autocommit mode
    INSERT INTO t VALUES (1);

    -- Execute same statement within transaction
    BEGIN;
    INSERT INTO t VALUES (2);
    INSERT INTO t VALUES (3);
    COMMIT;

    -- Execute same statement in autocommit mode again
    INSERT INTO t VALUES (4);

    -- Check: autocommit INSERTs should have COMMIT records (change_type=2)
    -- Transaction INSERTs should NOT have individual COMMIT records
    -- Only the explicit COMMIT should have a COMMIT record
    -- CREATE TABLE (change_id 1, txn_id 1) + COMMIT (change_id 2, txn_id 1)
    -- INSERT 1 (change_id 3, txn_id 3) + COMMIT (change_id 4, txn_id 3)
    -- INSERT 2 (change_id 5, txn_id 5) no individual COMMIT
    -- INSERT 3 (change_id 6, txn_id 5) no individual COMMIT
    -- COMMIT (change_id 7, txn_id 5)
    -- INSERT 4 (change_id 8, txn_id 8) + COMMIT (change_id 9, txn_id 8)
    SELECT change_type, table_name, change_txn_id
    FROM turso_cdc
    WHERE table_name != 'sqlite_schema' OR table_name IS NULL
    ORDER BY change_id;
}
expect {
    2||1
    1|t|3
    2||3
    1|t|5
    1|t|5
    2||5
    1|t|8
    2||8
}
