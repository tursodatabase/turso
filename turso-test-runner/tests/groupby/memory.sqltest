@database :memory:

test group_by_no_sorting_required_reordered_columns {
    create table t0 (a INT, b INT, c INT);
    create index a_b_idx on t0 (a, b);
    insert into t0 values
    (1,1,1),
    (1,1,2),
    (2,1,3),
    (2,2,3),
    (2,2,5);
    select c, b, a from t0 group by a, b;
}
expect {
    1|1|1
    3|1|2
    3|2|2
}

test having_or {
    CREATE TABLE users (first_name TEXT, age INTEGER);
    INSERT INTO users VALUES
    ('Michael', 25), ('Michael', 50),
    ('David', 50),
    ('Sarah', 65);
    select first_name, count(*) as cnt, avg(age) as avg_age
    from users
    group by first_name
    having cnt = 2 or avg_age = 65
    order by cnt desc
}
expect {
    Michael|2|37.5
    Sarah|1|65.0
}

# In GROUP BY clauses, column aliases take precedence when resolving identifiers to columns.
test group_by_alias_precedence {
    CREATE TABLE t(x,y);
    INSERT INTO t VALUES (1,200),(2,100);
    INSERT INTO t VALUES (1,200),(2,100);
    SELECT x AS y, SUM(y) as x FROM t GROUP BY y ORDER BY x;
}
expect {
    2|200
    1|400
}

test having_without_group_by_basic {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3), (4), (5);
    SELECT sum(a) as s FROM t HAVING s = 15;
}
expect {
    15
}

test having_without_group_by_no_match {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3), (4), (5);
    SELECT sum(a) as s FROM t HAVING s = 14;
}
expect {
}

test having_without_group_by_multiple_aggregates {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3), (4), (5);
    SELECT sum(a) as s, count(*) as c FROM t HAVING c = 5;
}
expect {
    15|5
}

test having_without_group_by_expression {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (10), (20), (30);
    SELECT sum(a) as total FROM t HAVING total > 50;
}
expect {
    60
}

test having_without_group_by_complex_condition {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3), (4), (5);
    SELECT sum(a) as s, avg(a) as av FROM t HAVING s = 15 AND av = 3;
}
expect {
    15|3.0
}

test having_without_group_by_count {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3);
    SELECT count(*) as cnt FROM t HAVING cnt > 2;
}
expect {
    3
}

test having_without_group_by_max_min {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (5), (10), (15), (20);
    SELECT max(a) as mx, min(a) as mn FROM t HAVING mx = 20 AND mn = 5;
}
expect {
    20|5
}

test having_without_group_by_non_aggregate_error {
    CREATE TABLE t(a INTEGER);
    INSERT INTO t VALUES (1), (2), (3);
    SELECT a FROM t HAVING a = 1;
}
expect error {
}

# Regression test: GROUP BY with constant false WHERE clause (e.g., WHERE 0)
# should return empty result set, not panic due to unopened sorter cursor.
test group_by_where_false {
    CREATE TABLE t0 (c0 INT);
    INSERT INTO t0 VALUES (1);
    SELECT c0, COUNT(*) FROM t0 WHERE 0 GROUP BY c0;
}
expect {
}

