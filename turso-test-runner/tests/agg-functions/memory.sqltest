@database :memory:

test min-null-regression-test {
    CREATE TABLE t (a);
    INSERT INTO t VALUES ('abc'), (NULL);
    SELECT min(a) FROM t;
}
expect {
    abc
}

test max-null-regression-test {
    CREATE TABLE t (a);
    INSERT INTO t VALUES ('abc'), (NULL);
    SELECT max(a) FROM t;
}
expect {
    abc
}

test group-concat-null-values-test {
    CREATE TABLE t (a);
    INSERT INTO t VALUES ('a'), (''), ('b'), (NULL), ('c');
    SELECT group_concat(a) FROM t;
}
expect {
    a,,b,c
}

test select-distinct-aggregate-ungrouped {
    CREATE TABLE t0 (c0 REAL);
  CREATE TABLE t1 (c0 INT);
  INSERT INTO t0 VALUES (1.0), (2.0);
  INSERT INTO t1 VALUES (1), (2);
  SELECT DISTINCT COUNT(t0.c0) FROM t0, t1;
}
expect {
    4
}

# Tests for ungrouped aggregates with non-aggregate columns on empty tables.
# When no rows match, literals should return their values, columns should return NULL,
# and expressions like "col IS NOT NULL" should evaluate correctly.

test ungrouped-agg-empty-table-literal {
    CREATE TABLE t (a INT, b TEXT);
    SELECT 42, COUNT(*), 'hello' FROM t;
}
expect {
    42|0|hello
}

test ungrouped-agg-empty-table-column-is-null {
    CREATE TABLE t (a INT);
    SELECT a IS NULL, COUNT(*) FROM t;
}
expect {
    1|0
}

test ungrouped-agg-empty-table-column-is-not-null {
    CREATE TABLE t (a INT);
    SELECT a IS NOT NULL, COUNT(*) FROM t;
}
expect {
    0|0
}

test ungrouped-agg-filtered-rows-literal {
    CREATE TABLE t (a INT);
    INSERT INTO t VALUES (1), (2), (3);
    SELECT 99, COUNT(*) FROM t WHERE a > 100;
}
expect {
    99|0
}

test ungrouped-agg-filtered-rows-column {
    CREATE TABLE t (a INT);
    INSERT INTO t VALUES (1), (2), (3);
    SELECT a, COUNT(*) FROM t WHERE a > 100;
}
expect {
    |0
}

test ungrouped-agg-multiple-literals {
    CREATE TABLE t (a INT);
    SELECT NULL, 5267713247558720570, NULL, AVG(-1), 28513758867889096 FROM t;
}
expect {
    |5267713247558720570|||28513758867889096
}

# Regression test: columns with DEFAULT values should return NULL (not the default)
# when the table is empty and we're in an aggregate query context.
test ungrouped-agg-empty-table-column-with-default {
    CREATE TABLE t (x BLOB NOT NULL DEFAULT X'00');
    SELECT x IS NULL, typeof(x), hex(x), AVG(1) FROM t;
}
expect {
    1|null||
}

# Tests for aggregates inside CASE expressions.
# When an aggregate appears in an untaken CASE branch, column references in other
# branches should still be evaluated correctly (they must be captured during the
# loop iteration, not after when the cursor is invalid).

test case-with-aggregate-in-untaken-branch-sum {
    CREATE TABLE t (x INTEGER);
    INSERT INTO t VALUES (1);
    SELECT CASE WHEN 0 THEN SUM(x) WHEN x THEN -NULL ELSE 'else' END FROM t;
}
expect {

}

test case-with-aggregate-in-untaken-branch-different-column {
    CREATE TABLE t (x INTEGER, y INTEGER);
    INSERT INTO t VALUES (1, 2);
    SELECT CASE WHEN 0 THEN SUM(x) WHEN y THEN -NULL ELSE 'else' END FROM t;
}
expect {

}

test case-with-aggregate-column-y-outside {
    CREATE TABLE t (y INTEGER);
    INSERT INTO t VALUES (1);
    SELECT CASE WHEN 0 THEN COUNT(*) WHEN y THEN -NULL ELSE 'else' END FROM t;
}
expect {

}

test case-with-aggregate-in-untaken-branch-count {
    CREATE TABLE t (x INTEGER);
    INSERT INTO t VALUES (1);
    SELECT CASE WHEN 0 THEN COUNT(x) WHEN x > 0 THEN 'yes' ELSE 'no' END FROM t;
}
expect {
    yes
}

test case-with-aggregate-in-untaken-branch-group-concat {
    CREATE TABLE t (x INTEGER, y TEXT);
    INSERT INTO t VALUES (1, 'a');
    SELECT CASE WHEN 0 THEN GROUP_CONCAT(y) WHEN length(y) > 0 THEN y ELSE 'empty' END FROM t;
}
expect {
    a
}

test case-with-aggregate-multiple-columns-outside {
    CREATE TABLE t (x INTEGER, y TEXT);
    INSERT INTO t VALUES (1, 'a');
    SELECT CASE WHEN 0 THEN SUM(x) WHEN x > 0 AND y = 'a' THEN 'found' ELSE 'not' END FROM t;
}
expect {
    found
}

test case-with-aggregate-in-taken-branch {
    CREATE TABLE t (x INTEGER);
    INSERT INTO t VALUES (1), (2), (3);
    SELECT CASE WHEN 1 THEN SUM(x) ELSE 'never' END FROM t;
}
expect {
    6
}

test case-with-multiple-aggregates-in-untaken-branches {
    CREATE TABLE t (x INTEGER);
    INSERT INTO t VALUES (1);
    SELECT
        CASE WHEN 0 THEN SUM(x) WHEN x THEN 'a' ELSE 'b' END,
        CASE WHEN 0 THEN COUNT(*) WHEN x = 1 THEN 'first' ELSE 'other' END
    FROM t;
}
expect {
    a|first
}

test case-with-nested-case-and-aggregate {
    CREATE TABLE t (x INTEGER);
    INSERT INTO t VALUES (1);
    SELECT CASE WHEN 0 THEN SUM(x) WHEN CASE WHEN x = 1 THEN 1 ELSE 0 END THEN 'nested' ELSE 'not' END FROM t;
}
expect {
    nested
}

