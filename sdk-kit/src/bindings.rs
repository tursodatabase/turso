/* automatically generated by rust-bindgen 0.71.1 */

#[doc = " SAFETY: slice with non-null ptr must points to the valid memory range [ptr..ptr + len)\n ownership of the slice is not transferred - so its either caller owns the data or turso\n as the owner doesn't change - there is no method to free the slice reference - because:\n 1. if tursodb owns it - it will clean it in appropriate time\n 2. if caller owns it - it must clean it in appropriate time with appropriate method and tursodb doesn't know how to properly free the data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_slice_ref_t {
    pub ptr: *const ::std::os::raw::c_void,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_slice_ref_t"][::std::mem::size_of::<turso_slice_ref_t>() - 16usize];
    ["Alignment of turso_slice_ref_t"][::std::mem::align_of::<turso_slice_ref_t>() - 8usize];
    ["Offset of field: turso_slice_ref_t::ptr"]
        [::std::mem::offset_of!(turso_slice_ref_t, ptr) - 0usize];
    ["Offset of field: turso_slice_ref_t::len"]
        [::std::mem::offset_of!(turso_slice_ref_t, len) - 8usize];
};
impl Default for turso_slice_ref_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_status_code_t {
    TURSO_OK = 0,
    TURSO_DONE = 1,
    TURSO_ROW = 2,
    TURSO_IO = 3,
    TURSO_BUSY = 4,
    TURSO_INTERRUPT = 5,
    TURSO_ERROR = 127,
    TURSO_MISUSE = 128,
    TURSO_CONSTRAINT = 129,
    TURSO_READONLY = 130,
    TURSO_DATABASE_FULL = 131,
    TURSO_NOTADB = 132,
    TURSO_CORRUPT = 133,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_type_t {
    TURSO_TYPE_UNKNOWN = 0,
    TURSO_TYPE_INTEGER = 1,
    TURSO_TYPE_REAL = 2,
    TURSO_TYPE_TEXT = 3,
    TURSO_TYPE_BLOB = 4,
    TURSO_TYPE_NULL = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_tracing_level_t {
    TURSO_TRACING_LEVEL_ERROR = 1,
    TURSO_TRACING_LEVEL_WARN = 2,
    TURSO_TRACING_LEVEL_INFO = 3,
    TURSO_TRACING_LEVEL_DEBUG = 4,
    TURSO_TRACING_LEVEL_TRACE = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_database {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoDatabase instance\n SAFETY: the database must be opened and closed only once but can be used concurrently"]
pub type turso_database_t = turso_database;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_connection {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoConnection instance\n SAFETY: the connection must be used exclusive and can't be accessed concurrently"]
pub type turso_connection_t = turso_connection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_statement {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoStatement instance\n SAFETY: the statement must be used exclusive and can't be accessed concurrently"]
pub type turso_statement_t = turso_statement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_log_t {
    pub message: *const ::std::os::raw::c_char,
    pub target: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub timestamp: u64,
    pub line: usize,
    pub level: turso_tracing_level_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_log_t"][::std::mem::size_of::<turso_log_t>() - 48usize];
    ["Alignment of turso_log_t"][::std::mem::align_of::<turso_log_t>() - 8usize];
    ["Offset of field: turso_log_t::message"]
        [::std::mem::offset_of!(turso_log_t, message) - 0usize];
    ["Offset of field: turso_log_t::target"][::std::mem::offset_of!(turso_log_t, target) - 8usize];
    ["Offset of field: turso_log_t::file"][::std::mem::offset_of!(turso_log_t, file) - 16usize];
    ["Offset of field: turso_log_t::timestamp"]
        [::std::mem::offset_of!(turso_log_t, timestamp) - 24usize];
    ["Offset of field: turso_log_t::line"][::std::mem::offset_of!(turso_log_t, line) - 32usize];
    ["Offset of field: turso_log_t::level"][::std::mem::offset_of!(turso_log_t, level) - 40usize];
};
impl Default for turso_log_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_config_t {
    #[doc = " SAFETY: turso_log_t log argument fields have lifetime scoped to the logger invocation\n caller must ensure that data is properly copied if it wants it to have longer lifetime"]
    pub logger: ::std::option::Option<unsafe extern "C" fn(log: *const turso_log_t)>,
    pub log_level: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_config_t"][::std::mem::size_of::<turso_config_t>() - 16usize];
    ["Alignment of turso_config_t"][::std::mem::align_of::<turso_config_t>() - 8usize];
    ["Offset of field: turso_config_t::logger"]
        [::std::mem::offset_of!(turso_config_t, logger) - 0usize];
    ["Offset of field: turso_config_t::log_level"]
        [::std::mem::offset_of!(turso_config_t, log_level) - 8usize];
};
impl Default for turso_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Database description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_database_config_t {
    #[doc = " Path to the database file or `:memory:`\n zero-terminated C string"]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " Optional comma separated list of experimental features to enable\n zero-terminated C string or null pointer"]
    pub experimental_features: *const ::std::os::raw::c_char,
    #[doc = " Parameter which defines who drives the IO - callee or the caller"]
    pub async_io: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_database_config_t"][::std::mem::size_of::<turso_database_config_t>() - 24usize];
    ["Alignment of turso_database_config_t"]
        [::std::mem::align_of::<turso_database_config_t>() - 8usize];
    ["Offset of field: turso_database_config_t::path"]
        [::std::mem::offset_of!(turso_database_config_t, path) - 0usize];
    ["Offset of field: turso_database_config_t::experimental_features"]
        [::std::mem::offset_of!(turso_database_config_t, experimental_features) - 8usize];
    ["Offset of field: turso_database_config_t::async_io"]
        [::std::mem::offset_of!(turso_database_config_t, async_io) - 16usize];
};
impl Default for turso_database_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn turso_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Setup global database info"]
    pub fn turso_setup(
        config: *const turso_config_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Create database holder but do not open it"]
    pub fn turso_database_new(
        config: *const turso_database_config_t,
        database: *mut *const turso_database_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Open database"]
    pub fn turso_database_open(
        database: *const turso_database_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Connect to the database"]
    pub fn turso_database_connect(
        self_: *const turso_database_t,
        connection: *mut *mut turso_connection_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Get autocommit state of the connection"]
    pub fn turso_connection_get_autocommit(self_: *const turso_connection_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Get last insert rowid for the connection or 0 if no inserts happened before"]
    pub fn turso_connection_last_insert_rowid(self_: *const turso_connection_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Prepare single statement in a connection"]
    pub fn turso_connection_prepare_single(
        self_: *const turso_connection_t,
        sql: *const ::std::os::raw::c_char,
        statement: *mut *mut turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Prepare first statement in a string containing multiple statements in a connection"]
    pub fn turso_connection_prepare_first(
        self_: *const turso_connection_t,
        sql: *const ::std::os::raw::c_char,
        statement: *mut *mut turso_statement_t,
        tail_idx: *mut usize,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " close the connection preventing any further operations executed over it\n caller still need to call deinit method to reclaim memory from the instance holding connection\n SAFETY: caller must guarantee that no ongoing operations are running over connection before calling turso_connection_close(...) method"]
    pub fn turso_connection_close(
        self_: *const turso_connection_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Execute single statement\n execute returns TURSO_DONE if execution completed\n execute returns TURSO_IO if async_io was set and execution needs IO in order to make progress"]
    pub fn turso_statement_execute(
        self_: *const turso_statement_t,
        rows_changes: *mut u64,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Step statement execution once\n Returns TURSO_DONE if execution finished\n Returns TURSO_ROW if execution generated the row (row values can be inspected with corresponding statement methods)\n Returns TURSO_IO if async_io was set and statement needs to execute IO to make progress"]
    pub fn turso_statement_step(
        self_: *const turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Execute one iteration of underlying IO backend after TURSO_IO status code\n This function either return some ERROR status or TURSO_OK"]
    pub fn turso_statement_run_io(
        self_: *const turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Reset a statement\n This method must be called in order to cleanup statement resources and prepare it for re-execution\n Any pending execution will be aborted - be careful and in certain cases ensure that turso_statement_finalize called before turso_statement_reset"]
    pub fn turso_statement_reset(
        self_: *const turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Finalize a statement\n This method must be called in the end of statement execution (either successfull or not)"]
    pub fn turso_statement_finalize(
        self_: *const turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Get column count"]
    pub fn turso_statement_column_count(self_: *const turso_statement_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the column name at the index\n C string allocated by Turso must be freed after the usage with corresponding turso_str_deinit(...) method"]
    pub fn turso_statement_column_name(
        self_: *const turso_statement_t,
        index: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the row value at the the index for a current statement state\n SAFETY: returned pointers will be valid only until next invocation of statement operation (step, finalize, reset, etc)\n Caller must make sure that any non-owning memory is copied appropriated if it will be used for longer lifetime"]
    pub fn turso_statement_row_value_kind(
        self_: *const turso_statement_t,
        index: usize,
    ) -> turso_type_t;
}
unsafe extern "C" {
    pub fn turso_statement_row_value_bytes_count(
        self_: *const turso_statement_t,
        index: usize,
    ) -> i64;
}
unsafe extern "C" {
    pub fn turso_statement_row_value_bytes_ptr(
        self_: *const turso_statement_t,
        index: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn turso_statement_row_value_int(self_: *const turso_statement_t, index: usize) -> i64;
}
unsafe extern "C" {
    pub fn turso_statement_row_value_double(self_: *const turso_statement_t, index: usize) -> f64;
}
unsafe extern "C" {
    #[doc = " Return named argument position in a statement"]
    pub fn turso_statement_named_position(
        self_: *const turso_statement_t,
        name: *const ::std::os::raw::c_char,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Return parameters count for the statement\n -1 if pointer is invalid"]
    pub fn turso_statement_parameters_count(self_: *const turso_statement_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Bind a positional argument to a statement"]
    pub fn turso_statement_bind_positional_null(
        self_: *const turso_statement_t,
        position: usize,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    pub fn turso_statement_bind_positional_int(
        self_: *const turso_statement_t,
        position: usize,
        value: i64,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    pub fn turso_statement_bind_positional_double(
        self_: *const turso_statement_t,
        position: usize,
        value: f64,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    pub fn turso_statement_bind_positional_blob(
        self_: *const turso_statement_t,
        position: usize,
        ptr: *const ::std::os::raw::c_char,
        len: usize,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    pub fn turso_statement_bind_positional_text(
        self_: *const turso_statement_t,
        position: usize,
        ptr: *const ::std::os::raw::c_char,
        len: usize,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Deallocate C string allocated by Turso"]
    pub fn turso_str_deinit(self_: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a database\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited database"]
    pub fn turso_database_deinit(self_: *const turso_database_t);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a connection\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited connection"]
    pub fn turso_connection_deinit(self_: *const turso_connection_t);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a statement\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited statement"]
    pub fn turso_statement_deinit(self_: *const turso_statement_t);
}
