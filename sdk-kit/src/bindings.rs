/* automatically generated by rust-bindgen 0.71.1 */

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_status_code_t {
    TURSO_OK = 0,
    TURSO_DONE = 1,
    TURSO_ROW = 2,
    TURSO_IO = 3,
    TURSO_BUSY = 4,
    TURSO_INTERRUPT = 5,
    TURSO_ERROR = 127,
    TURSO_MISUSE = 128,
    TURSO_CONSTRAINT = 129,
    TURSO_READONLY = 130,
    TURSO_DATABASE_FULL = 131,
    TURSO_NOTADB = 132,
    TURSO_CORRUPT = 133,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_status_t {
    pub code: turso_status_code_t,
    pub error: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_status_t"][::std::mem::size_of::<turso_status_t>() - 16usize];
    ["Alignment of turso_status_t"][::std::mem::align_of::<turso_status_t>() - 8usize];
    ["Offset of field: turso_status_t::code"]
        [::std::mem::offset_of!(turso_status_t, code) - 0usize];
    ["Offset of field: turso_status_t::error"]
        [::std::mem::offset_of!(turso_status_t, error) - 8usize];
};
impl Default for turso_status_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_type_t {
    TURSO_TYPE_INTEGER = 1,
    TURSO_TYPE_REAL = 2,
    TURSO_TYPE_TEXT = 3,
    TURSO_TYPE_BLOB = 4,
    TURSO_TYPE_NULL = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_tracing_level_t {
    TURSO_TRACING_LEVEL_ERROR = 1,
    TURSO_TRACING_LEVEL_WARN = 2,
    TURSO_TRACING_LEVEL_INFO = 3,
    TURSO_TRACING_LEVEL_DEBUG = 4,
    TURSO_TRACING_LEVEL_TRACE = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_log_t {
    pub message: *const ::std::os::raw::c_char,
    pub target: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub timestamp: u64,
    pub line: usize,
    pub level: turso_tracing_level_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_log_t"][::std::mem::size_of::<turso_log_t>() - 48usize];
    ["Alignment of turso_log_t"][::std::mem::align_of::<turso_log_t>() - 8usize];
    ["Offset of field: turso_log_t::message"]
        [::std::mem::offset_of!(turso_log_t, message) - 0usize];
    ["Offset of field: turso_log_t::target"][::std::mem::offset_of!(turso_log_t, target) - 8usize];
    ["Offset of field: turso_log_t::file"][::std::mem::offset_of!(turso_log_t, file) - 16usize];
    ["Offset of field: turso_log_t::timestamp"]
        [::std::mem::offset_of!(turso_log_t, timestamp) - 24usize];
    ["Offset of field: turso_log_t::line"][::std::mem::offset_of!(turso_log_t, line) - 32usize];
    ["Offset of field: turso_log_t::level"][::std::mem::offset_of!(turso_log_t, level) - 40usize];
};
impl Default for turso_log_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " SAFETY: slice with non-null ptr must points to the valid memory range [ptr..ptr + len)\n ownership of the slice is not transferred - so its either caller owns the data or turso\n as the owner doesn't change - there is no method to free the slice reference - because:\n 1. if tursodb owns it - it will clean it in appropriate time\n 2. if caller owns it - it must clean it in appropriate time with appropriate method and tursodb doesn't know how to properly free the data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_slice_ref_t {
    pub ptr: *const ::std::os::raw::c_void,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_slice_ref_t"][::std::mem::size_of::<turso_slice_ref_t>() - 16usize];
    ["Alignment of turso_slice_ref_t"][::std::mem::align_of::<turso_slice_ref_t>() - 8usize];
    ["Offset of field: turso_slice_ref_t::ptr"]
        [::std::mem::offset_of!(turso_slice_ref_t, ptr) - 0usize];
    ["Offset of field: turso_slice_ref_t::len"]
        [::std::mem::offset_of!(turso_slice_ref_t, len) - 8usize];
};
impl Default for turso_slice_ref_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_slice_owned_t {
    pub ptr: *const ::std::os::raw::c_void,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_slice_owned_t"][::std::mem::size_of::<turso_slice_owned_t>() - 16usize];
    ["Alignment of turso_slice_owned_t"][::std::mem::align_of::<turso_slice_owned_t>() - 8usize];
    ["Offset of field: turso_slice_owned_t::ptr"]
        [::std::mem::offset_of!(turso_slice_owned_t, ptr) - 0usize];
    ["Offset of field: turso_slice_owned_t::len"]
        [::std::mem::offset_of!(turso_slice_owned_t, len) - 8usize];
};
impl Default for turso_slice_owned_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " structure holding opaque pointer to the TursoDatabase instance\n SAFETY: the database must be opened and closed only once but can be used concurrently"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_database_t {
    pub inner: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_database_t"][::std::mem::size_of::<turso_database_t>() - 8usize];
    ["Alignment of turso_database_t"][::std::mem::align_of::<turso_database_t>() - 8usize];
    ["Offset of field: turso_database_t::inner"]
        [::std::mem::offset_of!(turso_database_t, inner) - 0usize];
};
impl Default for turso_database_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " structure holding opaque pointer to the TursoConnection instance\n SAFETY: the connection must be used exclusive and can't be accessed concurrently"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_connection_t {
    pub inner: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_connection_t"][::std::mem::size_of::<turso_connection_t>() - 8usize];
    ["Alignment of turso_connection_t"][::std::mem::align_of::<turso_connection_t>() - 8usize];
    ["Offset of field: turso_connection_t::inner"]
        [::std::mem::offset_of!(turso_connection_t, inner) - 0usize];
};
impl Default for turso_connection_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " structure holding opaque pointer to the TursoStatement instance\n SAFETY: the statement must be used exclusive and can't be accessed concurrently"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_statement_t {
    pub inner: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_statement_t"][::std::mem::size_of::<turso_statement_t>() - 8usize];
    ["Alignment of turso_statement_t"][::std::mem::align_of::<turso_statement_t>() - 8usize];
    ["Offset of field: turso_statement_t::inner"]
        [::std::mem::offset_of!(turso_statement_t, inner) - 0usize];
};
impl Default for turso_statement_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union turso_value_union_t {
    pub integer: i64,
    pub real: f64,
    pub text: turso_slice_ref_t,
    pub blob: turso_slice_ref_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_value_union_t"][::std::mem::size_of::<turso_value_union_t>() - 16usize];
    ["Alignment of turso_value_union_t"][::std::mem::align_of::<turso_value_union_t>() - 8usize];
    ["Offset of field: turso_value_union_t::integer"]
        [::std::mem::offset_of!(turso_value_union_t, integer) - 0usize];
    ["Offset of field: turso_value_union_t::real"]
        [::std::mem::offset_of!(turso_value_union_t, real) - 0usize];
    ["Offset of field: turso_value_union_t::text"]
        [::std::mem::offset_of!(turso_value_union_t, text) - 0usize];
    ["Offset of field: turso_value_union_t::blob"]
        [::std::mem::offset_of!(turso_value_union_t, blob) - 0usize];
};
impl Default for turso_value_union_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct turso_value_t {
    pub value: turso_value_union_t,
    pub type_: turso_type_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_value_t"][::std::mem::size_of::<turso_value_t>() - 24usize];
    ["Alignment of turso_value_t"][::std::mem::align_of::<turso_value_t>() - 8usize];
    ["Offset of field: turso_value_t::value"]
        [::std::mem::offset_of!(turso_value_t, value) - 0usize];
    ["Offset of field: turso_value_t::type_"]
        [::std::mem::offset_of!(turso_value_t, type_) - 16usize];
};
impl Default for turso_value_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Database description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_database_config_t {
    #[doc = " Path to the database file or `:memory:`"]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " Optional comma separated list of experimental features to enable"]
    pub experimental_features: *const ::std::os::raw::c_char,
    #[doc = " Parameter which defines who drives the IO - callee or the caller"]
    pub async_io: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_database_config_t"][::std::mem::size_of::<turso_database_config_t>() - 24usize];
    ["Alignment of turso_database_config_t"]
        [::std::mem::align_of::<turso_database_config_t>() - 8usize];
    ["Offset of field: turso_database_config_t::path"]
        [::std::mem::offset_of!(turso_database_config_t, path) - 0usize];
    ["Offset of field: turso_database_config_t::experimental_features"]
        [::std::mem::offset_of!(turso_database_config_t, experimental_features) - 8usize];
    ["Offset of field: turso_database_config_t::async_io"]
        [::std::mem::offset_of!(turso_database_config_t, async_io) - 16usize];
};
impl Default for turso_database_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_config_t {
    #[doc = " SAFETY: turso_log_t log argument fields have lifetime scoped to the logger invocation\n caller must ensure that data is properly copied if it wants it to have longer lifetime"]
    pub logger: ::std::option::Option<unsafe extern "C" fn(log: turso_log_t)>,
    pub log_level: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_config_t"][::std::mem::size_of::<turso_config_t>() - 16usize];
    ["Alignment of turso_config_t"][::std::mem::align_of::<turso_config_t>() - 8usize];
    ["Offset of field: turso_config_t::logger"]
        [::std::mem::offset_of!(turso_config_t, logger) - 0usize];
    ["Offset of field: turso_config_t::log_level"]
        [::std::mem::offset_of!(turso_config_t, log_level) - 8usize];
};
impl Default for turso_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn turso_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Setup global database info"]
    pub fn turso_setup(config: turso_config_t) -> turso_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_database_create_result_t {
    pub status: turso_status_t,
    pub database: turso_database_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_database_create_result_t"]
        [::std::mem::size_of::<turso_database_create_result_t>() - 24usize];
    ["Alignment of turso_database_create_result_t"]
        [::std::mem::align_of::<turso_database_create_result_t>() - 8usize];
    ["Offset of field: turso_database_create_result_t::status"]
        [::std::mem::offset_of!(turso_database_create_result_t, status) - 0usize];
    ["Offset of field: turso_database_create_result_t::database"]
        [::std::mem::offset_of!(turso_database_create_result_t, database) - 16usize];
};
impl Default for turso_database_create_result_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Create database holder but do not open it"]
    pub fn turso_database_new(config: turso_database_config_t) -> turso_database_create_result_t;
}
unsafe extern "C" {
    #[doc = " Open database"]
    pub fn turso_database_open(database: turso_database_t) -> turso_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_database_connect_result_t {
    pub status: turso_status_t,
    pub connection: turso_connection_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_database_connect_result_t"]
        [::std::mem::size_of::<turso_database_connect_result_t>() - 24usize];
    ["Alignment of turso_database_connect_result_t"]
        [::std::mem::align_of::<turso_database_connect_result_t>() - 8usize];
    ["Offset of field: turso_database_connect_result_t::status"]
        [::std::mem::offset_of!(turso_database_connect_result_t, status) - 0usize];
    ["Offset of field: turso_database_connect_result_t::connection"]
        [::std::mem::offset_of!(turso_database_connect_result_t, connection) - 16usize];
};
impl Default for turso_database_connect_result_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Connect to the database"]
    pub fn turso_database_connect(self_: turso_database_t) -> turso_database_connect_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_connection_get_autocommit_result_t {
    pub status: turso_status_t,
    pub auto_commit: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_connection_get_autocommit_result_t"]
        [::std::mem::size_of::<turso_connection_get_autocommit_result_t>() - 24usize];
    ["Alignment of turso_connection_get_autocommit_result_t"]
        [::std::mem::align_of::<turso_connection_get_autocommit_result_t>() - 8usize];
    ["Offset of field: turso_connection_get_autocommit_result_t::status"]
        [::std::mem::offset_of!(turso_connection_get_autocommit_result_t, status) - 0usize];
    ["Offset of field: turso_connection_get_autocommit_result_t::auto_commit"]
        [::std::mem::offset_of!(turso_connection_get_autocommit_result_t, auto_commit) - 16usize];
};
impl Default for turso_connection_get_autocommit_result_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Get autocommit state of the connection"]
    pub fn turso_connection_get_autocommit(
        self_: turso_connection_t,
    ) -> turso_connection_get_autocommit_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_connection_prepare_single_t {
    pub status: turso_status_t,
    pub statement: turso_statement_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_connection_prepare_single_t"]
        [::std::mem::size_of::<turso_connection_prepare_single_t>() - 24usize];
    ["Alignment of turso_connection_prepare_single_t"]
        [::std::mem::align_of::<turso_connection_prepare_single_t>() - 8usize];
    ["Offset of field: turso_connection_prepare_single_t::status"]
        [::std::mem::offset_of!(turso_connection_prepare_single_t, status) - 0usize];
    ["Offset of field: turso_connection_prepare_single_t::statement"]
        [::std::mem::offset_of!(turso_connection_prepare_single_t, statement) - 16usize];
};
impl Default for turso_connection_prepare_single_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Prepare single statement in a connection"]
    pub fn turso_connection_prepare_single(
        self_: turso_connection_t,
        sql: turso_slice_ref_t,
    ) -> turso_connection_prepare_single_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_connection_prepare_first_t {
    pub status: turso_status_t,
    pub statement: turso_statement_t,
    pub tail_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_connection_prepare_first_t"]
        [::std::mem::size_of::<turso_connection_prepare_first_t>() - 32usize];
    ["Alignment of turso_connection_prepare_first_t"]
        [::std::mem::align_of::<turso_connection_prepare_first_t>() - 8usize];
    ["Offset of field: turso_connection_prepare_first_t::status"]
        [::std::mem::offset_of!(turso_connection_prepare_first_t, status) - 0usize];
    ["Offset of field: turso_connection_prepare_first_t::statement"]
        [::std::mem::offset_of!(turso_connection_prepare_first_t, statement) - 16usize];
    ["Offset of field: turso_connection_prepare_first_t::tail_idx"]
        [::std::mem::offset_of!(turso_connection_prepare_first_t, tail_idx) - 24usize];
};
impl Default for turso_connection_prepare_first_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Prepare first statement in a string containing multiple statements in a connection"]
    pub fn turso_connection_prepare_first(
        self_: turso_connection_t,
        sql: turso_slice_ref_t,
    ) -> turso_connection_prepare_first_t;
}
unsafe extern "C" {
    #[doc = " close the connection preventing any further operations executed over it\n caller still need to call deinit method to reclaim memory from the instance holding connection\n SAFETY: caller must guarantee that no ongoing operations are running over connection before calling turso_connection_close(...) method"]
    pub fn turso_connection_close(self_: turso_connection_t) -> turso_status_t;
}
unsafe extern "C" {
    #[doc = " Check if no more statements was parsed after execution of turso_connection_prepare_first method"]
    pub fn turso_connection_prepare_first_result_empty(
        result: turso_connection_prepare_first_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_statement_execute_t {
    pub status: turso_status_t,
    pub rows_changed: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_statement_execute_t"]
        [::std::mem::size_of::<turso_statement_execute_t>() - 24usize];
    ["Alignment of turso_statement_execute_t"]
        [::std::mem::align_of::<turso_statement_execute_t>() - 8usize];
    ["Offset of field: turso_statement_execute_t::status"]
        [::std::mem::offset_of!(turso_statement_execute_t, status) - 0usize];
    ["Offset of field: turso_statement_execute_t::rows_changed"]
        [::std::mem::offset_of!(turso_statement_execute_t, rows_changed) - 16usize];
};
impl Default for turso_statement_execute_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Execute single statement"]
    pub fn turso_statement_execute(self_: turso_statement_t) -> turso_statement_execute_t;
}
unsafe extern "C" {
    #[doc = " Step statement execution once\n Returns TURSO_DONE if execution finished\n Returns TURSO_ROW if execution generated the row (row values can be inspected with corresponding statement methods)\n Returns TURSO_IO if async_io was set and statement needs to execute IO to make progress"]
    pub fn turso_statement_step(self_: turso_statement_t) -> turso_status_t;
}
unsafe extern "C" {
    #[doc = " Execute one iteration of underlying IO backend"]
    pub fn turso_statement_run_io(self_: turso_statement_t) -> turso_status_t;
}
unsafe extern "C" {
    #[doc = " Reset a statement"]
    pub fn turso_statement_reset(self_: turso_statement_t) -> turso_status_t;
}
unsafe extern "C" {
    #[doc = " Finalize a statement\n This method must be called in the end of statement execution (either successfull or not)"]
    pub fn turso_statement_finalize(self_: turso_statement_t) -> turso_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_statement_column_count_result_t {
    pub status: turso_status_t,
    pub column_count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_statement_column_count_result_t"]
        [::std::mem::size_of::<turso_statement_column_count_result_t>() - 24usize];
    ["Alignment of turso_statement_column_count_result_t"]
        [::std::mem::align_of::<turso_statement_column_count_result_t>() - 8usize];
    ["Offset of field: turso_statement_column_count_result_t::status"]
        [::std::mem::offset_of!(turso_statement_column_count_result_t, status) - 0usize];
    ["Offset of field: turso_statement_column_count_result_t::column_count"]
        [::std::mem::offset_of!(turso_statement_column_count_result_t, column_count) - 16usize];
};
impl Default for turso_statement_column_count_result_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Get column count"]
    pub fn turso_statement_column_count(
        self_: turso_statement_t,
    ) -> turso_statement_column_count_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_statement_column_name_result_t {
    pub status: turso_status_t,
    pub column_name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_statement_column_name_result_t"]
        [::std::mem::size_of::<turso_statement_column_name_result_t>() - 24usize];
    ["Alignment of turso_statement_column_name_result_t"]
        [::std::mem::align_of::<turso_statement_column_name_result_t>() - 8usize];
    ["Offset of field: turso_statement_column_name_result_t::status"]
        [::std::mem::offset_of!(turso_statement_column_name_result_t, status) - 0usize];
    ["Offset of field: turso_statement_column_name_result_t::column_name"]
        [::std::mem::offset_of!(turso_statement_column_name_result_t, column_name) - 16usize];
};
impl Default for turso_statement_column_name_result_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Get the column name at the index\n C string allocated by Turso must be freed after the usage with corresponding turso_str_deinit(...) method"]
    pub fn turso_statement_column_name(
        self_: turso_statement_t,
        index: usize,
    ) -> turso_statement_column_name_result_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct turso_statement_row_value_t {
    pub status: turso_status_t,
    pub value: turso_value_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_statement_row_value_t"]
        [::std::mem::size_of::<turso_statement_row_value_t>() - 40usize];
    ["Alignment of turso_statement_row_value_t"]
        [::std::mem::align_of::<turso_statement_row_value_t>() - 8usize];
    ["Offset of field: turso_statement_row_value_t::status"]
        [::std::mem::offset_of!(turso_statement_row_value_t, status) - 0usize];
    ["Offset of field: turso_statement_row_value_t::value"]
        [::std::mem::offset_of!(turso_statement_row_value_t, value) - 16usize];
};
impl Default for turso_statement_row_value_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " Get the row value at the the index for a current statement state\n SAFETY: returned turso_value_t will be valid only until next invocation of statement operation (step, finalize, reset, etc)\n Caller must make sure that any non-owning memory is copied appropriated if it will be used for longer lifetime"]
    pub fn turso_statement_row_value(
        self_: turso_statement_t,
        index: usize,
    ) -> turso_statement_row_value_t;
}
unsafe extern "C" {
    #[doc = " Bind a named argument to a statement"]
    pub fn turso_statement_bind_named(
        self_: turso_statement_t,
        name: turso_slice_ref_t,
        value: turso_value_t,
    ) -> turso_status_t;
}
unsafe extern "C" {
    #[doc = " Bind a positional argument to a statement"]
    pub fn turso_statement_bind_positional(
        self_: turso_statement_t,
        position: usize,
        value: turso_value_t,
    ) -> turso_status_t;
}
unsafe extern "C" {
    #[doc = " Create a turso integer value"]
    pub fn turso_integer(integer: i64) -> turso_value_t;
}
unsafe extern "C" {
    #[doc = " Create a turso real value"]
    pub fn turso_real(real: f64) -> turso_value_t;
}
unsafe extern "C" {
    #[doc = " Create a turso text value"]
    pub fn turso_text(ptr: *const ::std::os::raw::c_char, len: usize) -> turso_value_t;
}
unsafe extern "C" {
    #[doc = " Create a turso blob value"]
    pub fn turso_blob(ptr: *const u8, len: usize) -> turso_value_t;
}
unsafe extern "C" {
    #[doc = " Create a turso null value"]
    pub fn turso_null() -> turso_value_t;
}
unsafe extern "C" {
    #[doc = " Deallocate a status"]
    pub fn turso_status_deinit(self_: turso_status_t);
}
unsafe extern "C" {
    #[doc = " Deallocate C string allocated by Turso"]
    pub fn turso_str_deinit(self_: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a database\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited database"]
    pub fn turso_database_deinit(self_: turso_database_t);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a connection\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited connection"]
    pub fn turso_connection_deinit(self_: turso_connection_t);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a statement\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited statement"]
    pub fn turso_statement_deinit(self_: turso_statement_t);
}
