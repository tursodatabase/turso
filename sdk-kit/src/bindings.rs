/* automatically generated by rust-bindgen 0.71.1 */

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_status_code_t {
    TURSO_OK = 0,
    TURSO_DONE = 1,
    TURSO_ROW = 2,
    TURSO_IO = 3,
    TURSO_BUSY = 4,
    TURSO_INTERRUPT = 5,
    TURSO_ERROR = 127,
    TURSO_MISUSE = 128,
    TURSO_CONSTRAINT = 129,
    TURSO_READONLY = 130,
    TURSO_DATABASE_FULL = 131,
    TURSO_NOTADB = 132,
    TURSO_CORRUPT = 133,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_type_t {
    TURSO_TYPE_UNKNOWN = 0,
    TURSO_TYPE_INTEGER = 1,
    TURSO_TYPE_REAL = 2,
    TURSO_TYPE_TEXT = 3,
    TURSO_TYPE_BLOB = 4,
    TURSO_TYPE_NULL = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_tracing_level_t {
    TURSO_TRACING_LEVEL_ERROR = 1,
    TURSO_TRACING_LEVEL_WARN = 2,
    TURSO_TRACING_LEVEL_INFO = 3,
    TURSO_TRACING_LEVEL_DEBUG = 4,
    TURSO_TRACING_LEVEL_TRACE = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_database {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoDatabase instance\n SAFETY: the database must be opened and closed only once but can be used concurrently"]
pub type turso_database_t = turso_database;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_connection {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoConnection instance\n SAFETY: the connection must be used exclusive and can't be accessed concurrently"]
pub type turso_connection_t = turso_connection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_statement {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoStatement instance\n SAFETY: the statement must be used exclusive and can't be accessed concurrently"]
pub type turso_statement_t = turso_statement;
unsafe extern "C" {
    pub fn turso_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Setup global database info"]
    pub fn turso_setup(
        logger: ::std::option::Option<
            unsafe extern "C" fn(
                message: *const ::std::os::raw::c_char,
                target: *const ::std::os::raw::c_char,
                file: *const ::std::os::raw::c_char,
                timestamp: u64,
                line: usize,
                level: turso_tracing_level_t,
            ),
        >,
        log_level: *const ::std::os::raw::c_char,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Create database holder but do not open it"]
    pub fn turso_database_new(
        path: *const ::std::os::raw::c_char,
        experimental_features: *const ::std::os::raw::c_char,
        async_io: bool,
        database: *mut *mut turso_database_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Open database"]
    pub fn turso_database_open(
        database: *mut turso_database_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Connect to the database"]
    pub fn turso_database_connect(
        self_: *mut turso_database_t,
        connection: *mut *mut turso_connection_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Get autocommit state of the connection"]
    pub fn turso_connection_get_autocommit(self_: *mut turso_connection_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Prepare single statement in a connection"]
    pub fn turso_connection_prepare_single(
        self_: *mut turso_connection_t,
        sql: *const ::std::os::raw::c_char,
        statement: *mut *mut turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Prepare first statement in a string containing multiple statements in a connection"]
    pub fn turso_connection_prepare_first(
        self_: *mut turso_connection_t,
        sql: *const ::std::os::raw::c_char,
        statement: *mut *mut turso_statement_t,
        tail_idx: *mut usize,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " close the connection preventing any further operations executed over it\n caller still need to call deinit method to reclaim memory from the instance holding connection\n SAFETY: caller must guarantee that no ongoing operations are running over connection before calling turso_connection_close(...) method"]
    pub fn turso_connection_close(
        self_: *mut turso_connection_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Execute single statement"]
    pub fn turso_statement_execute(
        self_: *mut turso_statement_t,
        rows_changes: *mut u64,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Step statement execution once\n Returns TURSO_DONE if execution finished\n Returns TURSO_ROW if execution generated the row (row values can be inspected with corresponding statement methods)\n Returns TURSO_IO if async_io was set and statement needs to execute IO to make progress"]
    pub fn turso_statement_step(
        self_: *mut turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Execute one iteration of underlying IO backend"]
    pub fn turso_statement_run_io(
        self_: *mut turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Reset a statement"]
    pub fn turso_statement_reset(
        self_: *mut turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Finalize a statement\n This method must be called in the end of statement execution (either successfull or not)"]
    pub fn turso_statement_finalize(
        self_: *mut turso_statement_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Get column count"]
    pub fn turso_statement_column_count(self_: *mut turso_statement_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the column name at the index\n C string allocated by Turso must be freed after the usage with corresponding turso_str_deinit(...) method"]
    pub fn turso_statement_column_name(
        self_: *mut turso_statement_t,
        index: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the row value at the the index for a current statement state\n SAFETY: returned pointers will be valid only until next invocation of statement operation (step, finalize, reset, etc)\n Caller must make sure that any non-owning memory is copied appropriated if it will be used for longer lifetime"]
    pub fn turso_statement_row_value_kind(
        self_: *mut turso_statement_t,
        index: usize,
    ) -> turso_type_t;
}
unsafe extern "C" {
    pub fn turso_statement_row_value_bytes_count(
        self_: *mut turso_statement_t,
        index: usize,
    ) -> i64;
}
unsafe extern "C" {
    pub fn turso_statement_row_value_bytes_ptr(
        self_: *mut turso_statement_t,
        index: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn turso_statement_row_value_int(self_: *mut turso_statement_t, index: usize) -> i64;
}
unsafe extern "C" {
    pub fn turso_statement_row_value_double(self_: *mut turso_statement_t, index: usize) -> f64;
}
unsafe extern "C" {
    #[doc = " Return named argument position in a statement"]
    pub fn turso_statement_named_position(
        self_: *mut turso_statement_t,
        name: *const ::std::os::raw::c_char,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " Bind a positional argument to a statement"]
    pub fn turso_statement_bind_positional_null(
        self_: *mut turso_statement_t,
        position: usize,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    pub fn turso_statement_bind_positional_int(
        self_: *mut turso_statement_t,
        position: usize,
        value: i64,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    pub fn turso_statement_bind_positional_double(
        self_: *mut turso_statement_t,
        position: usize,
        value: f64,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    pub fn turso_statement_bind_positional_blob(
        self_: *mut turso_statement_t,
        position: usize,
        ptr: *const u8,
        len: usize,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    pub fn turso_statement_bind_positional_text(
        self_: *mut turso_statement_t,
        position: usize,
        ptr: *const ::std::os::raw::c_char,
        len: usize,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Deallocate C string allocated by Turso"]
    pub fn turso_str_deinit(self_: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a database\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited database"]
    pub fn turso_database_deinit(self_: *mut turso_database_t);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a connection\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited connection"]
    pub fn turso_connection_deinit(self_: *mut turso_connection_t);
}
unsafe extern "C" {
    #[doc = " Deallocate and close a statement\n SAFETY: caller must ensure that no other code can concurrently or later call methods over deinited statement"]
    pub fn turso_statement_deinit(self_: *mut turso_statement_t);
}
