/* automatically generated by rust-bindgen 0.71.1 */

use turso_sdk_kit::capi::c::*;

#[repr(u32)]
#[doc = " TURSO_DATABASE_SYNC_IO_REQUEST"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_sync_io_request_type_t {
    TURSO_SYNC_IO_NONE = 0,
    TURSO_SYNC_IO_HTTP = 1,
    TURSO_SYNC_IO_FULL_READ = 2,
    TURSO_SYNC_IO_FULL_WRITE = 3,
}
#[repr(C)]
pub struct turso_sync_io_http_request_t {
    pub method: turso_slice_ref_t,
    pub path: turso_slice_ref_t,
    pub body: turso_slice_ref_t,
    pub headers: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_sync_io_http_request_t"]
        [::std::mem::size_of::<turso_sync_io_http_request_t>() - 56usize];
    ["Alignment of turso_sync_io_http_request_t"]
        [::std::mem::align_of::<turso_sync_io_http_request_t>() - 8usize];
    ["Offset of field: turso_sync_io_http_request_t::method"]
        [::std::mem::offset_of!(turso_sync_io_http_request_t, method) - 0usize];
    ["Offset of field: turso_sync_io_http_request_t::path"]
        [::std::mem::offset_of!(turso_sync_io_http_request_t, path) - 16usize];
    ["Offset of field: turso_sync_io_http_request_t::body"]
        [::std::mem::offset_of!(turso_sync_io_http_request_t, body) - 32usize];
    ["Offset of field: turso_sync_io_http_request_t::headers"]
        [::std::mem::offset_of!(turso_sync_io_http_request_t, headers) - 48usize];
};
impl Default for turso_sync_io_http_request_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct turso_sync_io_http_header_t {
    pub key: turso_slice_ref_t,
    pub value: turso_slice_ref_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_sync_io_http_header_t"]
        [::std::mem::size_of::<turso_sync_io_http_header_t>() - 32usize];
    ["Alignment of turso_sync_io_http_header_t"]
        [::std::mem::align_of::<turso_sync_io_http_header_t>() - 8usize];
    ["Offset of field: turso_sync_io_http_header_t::key"]
        [::std::mem::offset_of!(turso_sync_io_http_header_t, key) - 0usize];
    ["Offset of field: turso_sync_io_http_header_t::value"]
        [::std::mem::offset_of!(turso_sync_io_http_header_t, value) - 16usize];
};
impl Default for turso_sync_io_http_header_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct turso_sync_io_full_read_request_t {
    pub path: turso_slice_ref_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_sync_io_full_read_request_t"]
        [::std::mem::size_of::<turso_sync_io_full_read_request_t>() - 16usize];
    ["Alignment of turso_sync_io_full_read_request_t"]
        [::std::mem::align_of::<turso_sync_io_full_read_request_t>() - 8usize];
    ["Offset of field: turso_sync_io_full_read_request_t::path"]
        [::std::mem::offset_of!(turso_sync_io_full_read_request_t, path) - 0usize];
};
impl Default for turso_sync_io_full_read_request_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct turso_sync_io_full_write_request_t {
    pub path: turso_slice_ref_t,
    pub content: turso_slice_ref_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_sync_io_full_write_request_t"]
        [::std::mem::size_of::<turso_sync_io_full_write_request_t>() - 32usize];
    ["Alignment of turso_sync_io_full_write_request_t"]
        [::std::mem::align_of::<turso_sync_io_full_write_request_t>() - 8usize];
    ["Offset of field: turso_sync_io_full_write_request_t::path"]
        [::std::mem::offset_of!(turso_sync_io_full_write_request_t, path) - 0usize];
    ["Offset of field: turso_sync_io_full_write_request_t::content"]
        [::std::mem::offset_of!(turso_sync_io_full_write_request_t, content) - 16usize];
};
impl Default for turso_sync_io_full_write_request_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[doc = " TURSO_ASYNC_OPERATION_RESULT"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum turso_sync_operation_result_type_t {
    TURSO_ASYNC_RESULT_NONE = 0,
    TURSO_ASYNC_RESULT_CONNECTION = 1,
    TURSO_ASYNC_RESULT_CHANGES = 2,
    TURSO_ASYNC_RESULT_STATS = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_sync_changes {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoDatabaseSyncChanges instance\n SAFETY: turso_sync_changes_t have independent lifetime and must be explicitly deallocated with turso_sync_changes_deinit method OR passed to the turso_sync_database_apply_changes method which gather ownership to this object"]
pub type turso_sync_changes_t = turso_sync_changes;
#[doc = " structure holding opaque pointer to the SyncEngineStats instance\n SAFETY: revision string will be valid only during async operation lifetime (until turso_sync_operation_deinit)\n Most likely, caller will need to copy revision slice to its internal buffer for longer lifetime"]
#[repr(C)]
pub struct turso_sync_stats_t {
    pub cdc_operations: i64,
    pub main_wal_size: i64,
    pub revert_wal_size: i64,
    pub last_pull_unix_time: i64,
    pub last_push_unix_time: i64,
    pub network_sent_bytes: i64,
    pub network_received_bytes: i64,
    pub revision: turso_slice_ref_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_sync_stats_t"][::std::mem::size_of::<turso_sync_stats_t>() - 72usize];
    ["Alignment of turso_sync_stats_t"][::std::mem::align_of::<turso_sync_stats_t>() - 8usize];
    ["Offset of field: turso_sync_stats_t::cdc_operations"]
        [::std::mem::offset_of!(turso_sync_stats_t, cdc_operations) - 0usize];
    ["Offset of field: turso_sync_stats_t::main_wal_size"]
        [::std::mem::offset_of!(turso_sync_stats_t, main_wal_size) - 8usize];
    ["Offset of field: turso_sync_stats_t::revert_wal_size"]
        [::std::mem::offset_of!(turso_sync_stats_t, revert_wal_size) - 16usize];
    ["Offset of field: turso_sync_stats_t::last_pull_unix_time"]
        [::std::mem::offset_of!(turso_sync_stats_t, last_pull_unix_time) - 24usize];
    ["Offset of field: turso_sync_stats_t::last_push_unix_time"]
        [::std::mem::offset_of!(turso_sync_stats_t, last_push_unix_time) - 32usize];
    ["Offset of field: turso_sync_stats_t::network_sent_bytes"]
        [::std::mem::offset_of!(turso_sync_stats_t, network_sent_bytes) - 40usize];
    ["Offset of field: turso_sync_stats_t::network_received_bytes"]
        [::std::mem::offset_of!(turso_sync_stats_t, network_received_bytes) - 48usize];
    ["Offset of field: turso_sync_stats_t::revision"]
        [::std::mem::offset_of!(turso_sync_stats_t, revision) - 56usize];
};
impl Default for turso_sync_stats_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Database sync description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_sync_database_config_t {
    pub path: *const ::std::os::raw::c_char,
    pub client_name: *const ::std::os::raw::c_char,
    pub long_poll_timeout_ms: i32,
    pub bootstrap_if_empty: bool,
    pub reserved_bytes: i32,
    pub partial_bootstrap_strategy_prefix: i32,
    pub partial_bootstrap_strategy_query: *const ::std::os::raw::c_char,
    pub partial_bootstrap_segment_size: usize,
    pub partial_bootstrap_prefetch: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of turso_sync_database_config_t"]
        [::std::mem::size_of::<turso_sync_database_config_t>() - 56usize];
    ["Alignment of turso_sync_database_config_t"]
        [::std::mem::align_of::<turso_sync_database_config_t>() - 8usize];
    ["Offset of field: turso_sync_database_config_t::path"]
        [::std::mem::offset_of!(turso_sync_database_config_t, path) - 0usize];
    ["Offset of field: turso_sync_database_config_t::client_name"]
        [::std::mem::offset_of!(turso_sync_database_config_t, client_name) - 8usize];
    ["Offset of field: turso_sync_database_config_t::long_poll_timeout_ms"]
        [::std::mem::offset_of!(turso_sync_database_config_t, long_poll_timeout_ms) - 16usize];
    ["Offset of field: turso_sync_database_config_t::bootstrap_if_empty"]
        [::std::mem::offset_of!(turso_sync_database_config_t, bootstrap_if_empty) - 20usize];
    ["Offset of field: turso_sync_database_config_t::reserved_bytes"]
        [::std::mem::offset_of!(turso_sync_database_config_t, reserved_bytes) - 24usize];
    ["Offset of field: turso_sync_database_config_t::partial_bootstrap_strategy_prefix"][::std::mem::offset_of!(
        turso_sync_database_config_t,
        partial_bootstrap_strategy_prefix
    )
        - 28usize];
    ["Offset of field: turso_sync_database_config_t::partial_bootstrap_strategy_query"][::std::mem::offset_of!(
        turso_sync_database_config_t,
        partial_bootstrap_strategy_query
    )
        - 32usize];
    ["Offset of field: turso_sync_database_config_t::partial_bootstrap_segment_size"][::std::mem::offset_of!(
        turso_sync_database_config_t,
        partial_bootstrap_segment_size
    ) - 40usize];
    ["Offset of field: turso_sync_database_config_t::partial_bootstrap_prefetch"][::std::mem::offset_of!(
        turso_sync_database_config_t,
        partial_bootstrap_prefetch
    ) - 48usize];
};
impl Default for turso_sync_database_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_sync_database {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoDatabaseSync instance"]
pub type turso_sync_database_t = turso_sync_database;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_sync_operation {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the TursoAsyncOperation instance\n SAFETY: methods for the turso_sync_operation_t can't be called concurrently"]
pub type turso_sync_operation_t = turso_sync_operation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turso_sync_io_item {
    _unused: [u8; 0],
}
#[doc = " opaque pointer to the SyncEngineIoQueueItem instance"]
pub type turso_sync_io_item_t = turso_sync_io_item;
unsafe extern "C" {
    #[doc = " Create database sync holder but do not open it"]
    pub fn turso_sync_database_new(
        db_config: *const turso_database_config_t,
        sync_config: *const turso_sync_database_config_t,
        database: *mut *const turso_sync_database_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Prepare synced database for use (bootstrap if needed, setup necessary database parameters for first access)\n AsyncOperation returns None"]
    pub fn turso_sync_database_init(
        self_: *const turso_sync_database_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Open prepared synced database, fail if no properly setup database exists\n AsyncOperation returns None"]
    pub fn turso_sync_database_open(
        self_: *const turso_sync_database_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Open or prepared synced database or create it if no properly setup database exists\n AsyncOperation returns None"]
    pub fn turso_sync_database_create(
        self_: *const turso_sync_database_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Create turso database connection\n SAFETY: synced database must be opened before that operation (with either turso_database_sync_create or turso_database_sync_open)\n AsyncOperation returns Connection"]
    pub fn turso_sync_database_connect(
        self_: *const turso_sync_database_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Collect stats about synced database\n AsyncOperation returns Stats"]
    pub fn turso_sync_database_stats(
        self_: *const turso_sync_database_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Checkpoint WAL of the synced database\n AsyncOperation returns None"]
    pub fn turso_sync_database_checkpoint(
        self_: *const turso_sync_database_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Push local changes to remote\n AsyncOperation returns None"]
    pub fn turso_sync_database_push_changes(
        self_: *const turso_sync_database_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Wait for remote changes\n AsyncOperation returns Changes (which must be properly deinited or used in the [turso_sync_database_apply_changes] method)"]
    pub fn turso_sync_database_wait_changes(
        self_: *const turso_sync_database_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Apply remote changes locally\n SAFETY: caller must guarantee that no other methods are executing concurrently (push/wait/checkpoint)\n otherwise, operation will return MISUSE error\n\n the method CONSUMES turso_sync_changes_t instance and caller no longer owns it after the call\n So, the changes MUST NOT be explicitly deallocated after the method call (either successful or not)\n\n AsyncOperation returns None"]
    pub fn turso_sync_database_apply_changes(
        self_: *const turso_sync_database_t,
        changes: *const turso_sync_changes_t,
        operation: *mut *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Resume async operation\n If return error status - turso_status_t must be properly cleaned up\n If return TURSO_IO - caller must drive IO\n If return TURSO_DONE - caller must inspect result and clean up it or use it accordingly"]
    pub fn turso_sync_operation_resume(
        self_: *const turso_sync_operation_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Extract operation result kind"]
    pub fn turso_sync_operation_result_kind(
        self_: *const turso_sync_operation_t,
    ) -> turso_sync_operation_result_type_t;
}
unsafe extern "C" {
    #[doc = " Extract Connection result from finished async operation"]
    pub fn turso_sync_operation_result_extract_connection(
        self_: *const turso_sync_operation_t,
        connection: *mut *const turso_connection_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Extract Changes result from finished async operation\n If no changes were fetched - return TURSO_OK and set changes to null pointer"]
    pub fn turso_sync_operation_result_extract_changes(
        self_: *const turso_sync_operation_t,
        changes: *mut *const turso_sync_changes_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Extract Stats result from finished async operation"]
    pub fn turso_sync_operation_result_extract_stats(
        self_: *const turso_sync_operation_t,
        stats: *mut turso_sync_stats_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Try to take IO request from the sync engine IO queue"]
    pub fn turso_sync_database_io_take_item(
        self_: *const turso_sync_database_t,
        item: *mut *const turso_sync_io_item_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Run extra database callbacks after IO execution"]
    pub fn turso_sync_database_io_step_callbacks(
        self_: *const turso_sync_database_t,
        error_opt_out: *mut *const ::std::os::raw::c_char,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Get request IO kind"]
    pub fn turso_sync_database_io_request_kind(
        self_: *const turso_sync_io_item_t,
    ) -> turso_sync_io_request_type_t;
}
unsafe extern "C" {
    #[doc = " Get HTTP request header key-value pair"]
    pub fn turso_sync_database_io_request_http(
        self_: *const turso_sync_io_item_t,
        request: *mut turso_sync_io_http_request_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Get HTTP request fields"]
    pub fn turso_sync_database_io_request_http_header(
        self_: *const turso_sync_io_item_t,
        index: usize,
        header: *mut turso_sync_io_http_header_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Get HTTP request fields"]
    pub fn turso_sync_database_io_request_full_read(
        self_: *const turso_sync_io_item_t,
        request: *mut turso_sync_io_full_read_request_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Get HTTP request fields"]
    pub fn turso_sync_database_io_request_full_write(
        self_: *const turso_sync_io_item_t,
        request: *mut turso_sync_io_full_write_request_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Poison IO request completion with error"]
    pub fn turso_sync_database_io_poison(
        self_: *const turso_sync_io_item_t,
        error: *mut turso_slice_ref_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Set IO request completion status"]
    pub fn turso_sync_database_io_status(
        self_: *const turso_sync_io_item_t,
        status: i32,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Push bytes to the IO completion buffer"]
    pub fn turso_sync_database_io_push_buffer(
        self_: *const turso_sync_io_item_t,
        buffer: *mut turso_slice_ref_t,
    ) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Set IO request completion as done"]
    pub fn turso_sync_database_io_done(self_: *const turso_sync_io_item_t) -> turso_status_code_t;
}
unsafe extern "C" {
    #[doc = " Deallocate a TursoDatabaseSync"]
    pub fn turso_sync_database_deinit(self_: *const turso_sync_database_t);
}
unsafe extern "C" {
    #[doc = " Deallocate a TursoAsyncOperation"]
    pub fn turso_sync_operation_deinit(self_: *const turso_sync_operation_t);
}
unsafe extern "C" {
    #[doc = " Deallocate a SyncEngineIoQueueItem"]
    pub fn turso_sync_database_io_item_deinit(self_: *const turso_sync_io_item_t);
}
unsafe extern "C" {
    #[doc = " Deallocate a TursoDatabaseSyncChanges"]
    pub fn turso_sync_changes_deinit(self_: *const turso_sync_changes_t);
}
