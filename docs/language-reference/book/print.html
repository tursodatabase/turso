<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Turso SQL Language Reference</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex-51b85602.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-abb19179.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Turso SQL Language Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/tursodatabase/turso" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="turso-sql-language-reference"><a class="header" href="#turso-sql-language-reference">Turso SQL Language Reference</a></h1>
<p>Turso is a SQLite-compatible database. This reference documents the SQL language as supported by Turso.</p>
<p>If you are familiar with SQLite, Turso supports most of the same SQL syntax. This reference covers only what Turso supports — features not listed here are not yet available. For Turso-specific extensions beyond SQLite (custom types, vector search, CDC, materialized views, encryption), see the <a href="#custom-types">Turso Extensions</a> section.</p>
<h2 id="how-to-read-syntax-definitions"><a class="header" href="#how-to-read-syntax-definitions">How to Read Syntax Definitions</a></h2>
<p>Every statement page begins with a <strong>Syntax</strong> section showing the grammar using the following notation:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Notation</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>KEYWORD</code></td><td>A literal SQL keyword. Keywords are case-insensitive; uppercase is used by convention.</td></tr>
<tr><td><code>name</code></td><td>A placeholder for a user-supplied identifier (table name, column name, etc.).</td></tr>
<tr><td><code>expr</code></td><td>A placeholder for any SQL expression.</td></tr>
<tr><td><code>[X]</code></td><td><code>X</code> is optional.</td></tr>
<tr><td><code>{A | B}</code></td><td>Choose exactly one of <code>A</code> or <code>B</code>.</td></tr>
<tr><td><code>[A | B]</code></td><td>Optionally choose one of <code>A</code> or <code>B</code>.</td></tr>
<tr><td><code>[, ...]</code></td><td>The preceding element may be repeated, separated by commas.</td></tr>
</tbody>
</table>
</div>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-sql">INSERT [OR {ROLLBACK | ABORT | FAIL | IGNORE | REPLACE}]
  INTO table-name [(column-name [, ...])]
  VALUES (expr [, ...]) [, ...]
</code></pre>
<p>This means:</p>
<ul>
<li><code>INSERT</code> is required.</li>
<li><code>OR ROLLBACK</code>, <code>OR ABORT</code>, etc. are optional — pick one if used.</li>
<li>The column list is optional.</li>
<li>At least one <code>VALUES</code> row is required, and you may provide more separated by commas.</li>
<li>Each row contains one or more expressions separated by commas.</li>
</ul>
<h2 id="identifiers-and-quoting"><a class="header" href="#identifiers-and-quoting">Identifiers and Quoting</a></h2>
<p>Identifiers (table names, column names) follow these rules:</p>
<ul>
<li>Unquoted identifiers may contain letters, digits, and underscores, and must not start with a digit.</li>
<li>Identifiers can be quoted with double quotes (<code>"name"</code>), square brackets (<code>[name]</code>), or backticks (<code>`name`</code>).</li>
<li>Quoted identifiers may contain any character, including spaces and reserved words.</li>
<li>String literals use single quotes (<code>'text'</code>). Double quotes are for identifiers, not strings.</li>
</ul>
<h2 id="type-affinity"><a class="header" href="#type-affinity">Type Affinity</a></h2>
<p>Turso uses SQLite’s dynamic type system. Every value has one of five storage classes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Storage Class</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>NULL</td><td>A null value.</td></tr>
<tr><td>INTEGER</td><td>A signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes.</td></tr>
<tr><td>REAL</td><td>A floating-point number, stored as an 8-byte IEEE 754 float.</td></tr>
<tr><td>TEXT</td><td>A UTF-8 string.</td></tr>
<tr><td>BLOB</td><td>Raw binary data, stored exactly as provided.</td></tr>
</tbody>
</table>
</div>
<p>Column type names in <code>CREATE TABLE</code> determine the column’s <strong>type affinity</strong>, which influences how values are coerced on insertion. See <a href="#type-conversions">Type Conversions</a> for the full rules.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="select"><a class="header" href="#select">SELECT</a></h1>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-sql">SELECT [DISTINCT | ALL] result-column [, ...]
  [FROM table-or-subquery [, ...]]
  [WHERE expr]
  [GROUP BY expr [, ...] [HAVING expr]]
  [ORDER BY ordering-term [, ...]]
  [LIMIT expr [OFFSET expr]]
</code></pre>
<p>Where <code>result-column</code> is one of:</p>
<pre><code class="language-sql">*
table-name.*
expr [[AS] column-alias]
</code></pre>
<p>And <code>table-or-subquery</code> is one of:</p>
<pre><code class="language-sql">table-name [[AS] table-alias]
(select-statement) [[AS] table-alias]
table-or-subquery join-operator table-or-subquery join-constraint
</code></pre>
<p>This page covers the basic SELECT statement: the SELECT clause, FROM clause, WHERE clause, and DISTINCT/ALL keywords. For related topics, see <a href="#join">JOINs</a>, <a href="#group-by-and-having">GROUP BY and HAVING</a>, <a href="#order-by-limit-offset">ORDER BY, LIMIT, OFFSET</a>, <a href="#set-operations">Set Operations</a>, <a href="#subqueries">Subqueries</a>, and <a href="#common-table-expressions">Common Table Expressions</a>.</p>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>The SELECT statement queries the database and returns zero or more rows of data. Each row has a fixed number of columns determined by the result expression list. A SELECT statement does not modify the database.</p>
<p>Processing a SELECT statement follows four steps:</p>
<ol>
<li><strong>FROM clause</strong> – the input dataset is determined. If there is no FROM clause, the input is implicitly a single row with zero columns.</li>
<li><strong>WHERE clause</strong> – the input rows are filtered by evaluating the WHERE expression as a boolean for each row; only rows where the expression is true are kept.</li>
<li><strong>Result expressions</strong> – the result columns are computed by evaluating each expression in the SELECT list against the filtered rows.</li>
<li><strong>DISTINCT/ALL</strong> – if DISTINCT is specified, duplicate result rows are removed.</li>
</ol>
<h2 id="clauses"><a class="header" href="#clauses">Clauses</a></h2>
<h3 id="select-result-expressions"><a class="header" href="#select-result-expressions">SELECT (Result Expressions)</a></h3>
<p>The list of expressions between SELECT and FROM is the <strong>result expression list</strong>. Each expression becomes a column in the output. Expressions can be constants, column references, computed values, or function calls.</p>
<pre><code class="language-sql">-- Selecting literal values (no FROM clause needed)
SELECT 1 + 2;
</code></pre>
<pre><code class="language-sql">-- Selecting with string concatenation
SELECT 10 * 2 AS doubled, 'hello' || ' ' || 'world' AS combined;
</code></pre>
<h4 id="column-aliases"><a class="header" href="#column-aliases">Column Aliases</a></h4>
<p>Any result expression can be given a name using the AS keyword. This alias becomes the column header in the output and can be referenced in ORDER BY and GROUP BY clauses.</p>
<pre><code class="language-sql">SELECT name AS user_name, email AS contact
  FROM users
  WHERE active = 1;
</code></pre>
<p>The AS keyword is optional – <code>SELECT name user_name FROM users</code> is also valid – but including it is recommended for clarity.</p>
<h4 id="the-asterisk-wildcard"><a class="header" href="#the-asterisk-wildcard">The Asterisk Wildcard</a></h4>
<p>The special expression <code>*</code> expands to all columns from all tables in the FROM clause.</p>
<pre><code class="language-sql">-- Return all columns from the users table
SELECT * FROM users;
</code></pre>
<p>To expand all columns from a specific table (useful with multiple tables), use <code>table.*</code> or <code>alias.*</code>:</p>
<pre><code class="language-sql">SELECT u.* FROM users u WHERE u.active = 1;
</code></pre>
<p>The <code>*</code> and <code>table.*</code> forms can only be used in the result expression list of a SELECT that has a FROM clause.</p>
<h3 id="from"><a class="header" href="#from">FROM</a></h3>
<p>The FROM clause specifies the input data for the query. If omitted, the input is implicitly a single row with zero columns, which is useful for evaluating expressions.</p>
<pre><code class="language-sql">-- No FROM clause: evaluate an expression directly
SELECT typeof(42), typeof(3.14), typeof('text'), typeof(NULL);
</code></pre>
<h4 id="single-table"><a class="header" href="#single-table">Single Table</a></h4>
<p>The simplest FROM clause names a single table. The query operates on all rows of that table.</p>
<pre><code class="language-sql">SELECT name, email FROM users;
</code></pre>
<h4 id="table-aliases"><a class="header" href="#table-aliases">Table Aliases</a></h4>
<p>A table can be given an alias with the AS keyword (or simply by placing the alias after the table name). The alias can then be used to qualify column names.</p>
<pre><code class="language-sql">SELECT u.name, u.email
  FROM users AS u
  WHERE u.active = 1;
</code></pre>
<p>Aliases are required when the same table appears more than once in a query, and they are convenient for shortening long table names.</p>
<h4 id="multiple-tables"><a class="header" href="#multiple-tables">Multiple Tables</a></h4>
<p>When multiple tables are listed in the FROM clause separated by commas, Turso computes the <strong>Cartesian product</strong> of all rows from each table. This means every combination of rows is produced. A WHERE clause is typically used to filter the result to only the meaningful combinations.</p>
<pre><code class="language-sql">-- Comma-separated tables with a WHERE condition (implicit join)
SELECT u.name, o.amount
  FROM users AS u, orders AS o
  WHERE u.id = o.user_id;
</code></pre>
<p>A comma between tables is equivalent to INNER JOIN or JOIN with no ON clause. For explicit join syntax with ON or USING clauses, see <a href="#join">JOINs</a>.</p>
<h4 id="subqueries-in-from"><a class="header" href="#subqueries-in-from">Subqueries in FROM</a></h4>
<p>A parenthesized SELECT statement can appear in the FROM clause. The subquery is treated as a virtual table containing the data it returns. A subquery in FROM should be given an alias.</p>
<pre><code class="language-sql">SELECT *
  FROM (
    SELECT user_id, sum(amount) AS total
      FROM orders
      GROUP BY user_id
  ) AS user_totals
  WHERE total &gt; 500;
</code></pre>
<p>Each column of the subquery inherits the type affinity and collation of the corresponding expression in the subquery’s result list.</p>
<h3 id="where"><a class="header" href="#where">WHERE</a></h3>
<p>The WHERE clause filters the input rows by evaluating its expression as a boolean for each row. Only rows where the expression evaluates to true are included in the result. Rows for which the expression evaluates to false or NULL are excluded.</p>
<pre><code class="language-sql">-- Simple equality condition
SELECT name, email FROM users WHERE active = 1;
</code></pre>
<pre><code class="language-sql">-- Multiple conditions with AND
SELECT name, email FROM users WHERE active = 1 AND name &lt;&gt; 'Alice';
</code></pre>
<pre><code class="language-sql">-- Using OR to match alternative conditions
SELECT name, price
  FROM products
  WHERE category = 'Electronics' OR price &lt; 250;
</code></pre>
<h4 id="null-handling"><a class="header" href="#null-handling">NULL Handling</a></h4>
<p>Comparisons with NULL using <code>=</code> or <code>&lt;&gt;</code> always evaluate to NULL (not true or false), so rows with NULL values in the compared column are excluded by such conditions. Use IS NULL and IS NOT NULL to test for null values explicitly.</p>
<pre><code class="language-sql">-- Find rows where email is missing
SELECT name FROM users WHERE email IS NULL;
</code></pre>
<pre><code class="language-sql">-- Find rows where email is present
SELECT name, email FROM users WHERE email IS NOT NULL;
</code></pre>
<h4 id="pattern-matching-with-like"><a class="header" href="#pattern-matching-with-like">Pattern Matching with LIKE</a></h4>
<p>The LIKE operator performs case-insensitive pattern matching on text values. The <code>%</code> wildcard matches any sequence of characters, and <code>_</code> matches any single character.</p>
<pre><code class="language-sql">-- Names starting with 'A'
SELECT name, email FROM users WHERE name LIKE 'A%';
</code></pre>
<pre><code class="language-sql">-- Names containing 'a' anywhere (case-insensitive)
SELECT name FROM products WHERE name LIKE '%a%';
</code></pre>
<p>For more details, see <a href="#pattern-matching">Pattern Matching</a>.</p>
<h4 id="between"><a class="header" href="#between">BETWEEN</a></h4>
<p>The BETWEEN operator tests whether a value falls within an inclusive range.</p>
<pre><code class="language-sql">SELECT name, price FROM products WHERE price BETWEEN 200 AND 700;
</code></pre>
<p>For more details, see <a href="#in-and-between">IN and BETWEEN</a>.</p>
<h4 id="in"><a class="header" href="#in">IN</a></h4>
<p>The IN operator tests whether a value matches any value in a list or subquery result.</p>
<pre><code class="language-sql">SELECT name, category
  FROM products
  WHERE category IN ('Electronics', 'Furniture') AND price &gt; 500;
</code></pre>
<p>For more details, see <a href="#in-and-between">IN and BETWEEN</a>.</p>
<h3 id="distinct-and-all"><a class="header" href="#distinct-and-all">DISTINCT and ALL</a></h3>
<p>By default (or when ALL is specified explicitly), all result rows are returned, including duplicates. When DISTINCT is specified, duplicate rows are removed from the result set before it is returned.</p>
<pre><code class="language-sql">-- Without DISTINCT: may contain duplicate categories
SELECT ALL category FROM products;

-- With DISTINCT: each category appears only once
SELECT DISTINCT category FROM products;
</code></pre>
<p>For the purposes of detecting duplicates, two NULL values are considered equal. An integer is equal to a floating-point number if they represent the same quantity. Text values are compared using the appropriate collation sequence.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>The examples below use the following tables:</p>
<pre><code class="language-sql">CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name TEXT,
  email TEXT,
  active INTEGER
);
INSERT INTO users VALUES
  (1, 'Alice', 'alice@example.com', 1),
  (2, 'Bob', 'bob@example.com', 0),
  (3, 'Charlie', 'charlie@example.com', 1);

CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  category TEXT,
  price REAL
);
INSERT INTO products VALUES
  (1, 'Laptop', 'Electronics', 999.99),
  (2, 'Phone', 'Electronics', 699.99),
  (3, 'Desk', 'Furniture', 299.99),
  (4, 'Chair', 'Furniture', 199.99),
  (5, 'Tablet', 'Electronics', 499.99);

CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  user_id INTEGER,
  product TEXT,
  amount REAL
);
INSERT INTO orders VALUES
  (1, 1, 'Laptop', 999.99),
  (2, 1, 'Phone', 699.99),
  (3, 2, 'Desk', 299.99),
  (4, 3, 'Chair', 199.99),
  (5, 1, 'Tablet', 499.99);
</code></pre>
<h3 id="selecting-all-columns"><a class="header" href="#selecting-all-columns">Selecting All Columns</a></h3>
<pre><code class="language-sql">SELECT * FROM users;
-- id | name    | email               | active
-- 1  | Alice   | alice@example.com   | 1
-- 2  | Bob     | bob@example.com     | 0
-- 3  | Charlie | charlie@example.com | 1
</code></pre>
<h3 id="selecting-specific-columns"><a class="header" href="#selecting-specific-columns">Selecting Specific Columns</a></h3>
<pre><code class="language-sql">SELECT name, email FROM users;
-- name    | email
-- Alice   | alice@example.com
-- Bob     | bob@example.com
-- Charlie | charlie@example.com
</code></pre>
<h3 id="filtering-with-where"><a class="header" href="#filtering-with-where">Filtering with WHERE</a></h3>
<pre><code class="language-sql">SELECT name, email FROM users WHERE active = 1;
-- name    | email
-- Alice   | alice@example.com
-- Charlie | charlie@example.com
</code></pre>
<h3 id="column-aliases-and-computed-expressions"><a class="header" href="#column-aliases-and-computed-expressions">Column Aliases and Computed Expressions</a></h3>
<pre><code class="language-sql">SELECT
  name,
  price,
  price * 0.9 AS discounted_price
FROM products
WHERE price &gt; 300;
-- name   | price  | discounted_price
-- Laptop | 999.99 | 899.991
-- Phone  | 699.99 | 629.991
-- Tablet | 499.99 | 449.991
</code></pre>
<h3 id="case-expressions-in-select"><a class="header" href="#case-expressions-in-select">CASE Expressions in SELECT</a></h3>
<pre><code class="language-sql">SELECT
  name,
  price,
  CASE
    WHEN price &gt; 500 THEN 'expensive'
    WHEN price &gt; 200 THEN 'moderate'
    ELSE 'affordable'
  END AS price_tier
FROM products;
-- name   | price  | price_tier
-- Laptop | 999.99 | expensive
-- Phone  | 699.99 | expensive
-- Desk   | 299.99 | moderate
-- Chair  | 199.99 | affordable
-- Tablet | 499.99 | moderate
</code></pre>
<h3 id="multiple-tables-with-implicit-join"><a class="header" href="#multiple-tables-with-implicit-join">Multiple Tables with Implicit Join</a></h3>
<pre><code class="language-sql">SELECT u.name, o.amount
  FROM users AS u, orders AS o
  WHERE u.id = o.user_id;
-- name  | amount
-- Alice | 999.99
-- Alice | 699.99
-- Alice | 499.99
-- Bob   | 299.99
-- Charlie | 199.99
</code></pre>
<h3 id="subquery-in-from"><a class="header" href="#subquery-in-from">Subquery in FROM</a></h3>
<pre><code class="language-sql">SELECT *
  FROM (
    SELECT user_id, sum(amount) AS total
      FROM orders
      GROUP BY user_id
  ) AS user_totals
  WHERE total &gt; 500;
-- user_id | total
-- 1       | 2199.97
</code></pre>
<h3 id="distinct"><a class="header" href="#distinct">DISTINCT</a></h3>
<pre><code class="language-sql">SELECT DISTINCT category FROM products;
-- category
-- Electronics
-- Furniture
</code></pre>
<h2 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h2>
<p>Turso supports the standard SELECT statement with the following note:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><code>schema.table.column</code> (three-part names)</td><td>Not supported. Turso does not support attached databases or schema-qualified table names. Use <code>table.column</code> (two-part names) instead.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="join"><a class="header" href="#join">JOIN</a></h1>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code class="language-sql">table-or-subquery {[INNER] JOIN | LEFT [OUTER] JOIN | NATURAL [LEFT [OUTER]] JOIN} table-or-subquery [join-constraint]
</code></pre>
<p>Where <code>join-constraint</code> is one of:</p>
<pre><code class="language-sql">ON expr
USING (column-name [, ...])
</code></pre>
<p>Tables may also be joined implicitly using a comma:</p>
<pre><code class="language-sql">SELECT ... FROM table1, table2 WHERE expr
</code></pre>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>A JOIN combines rows from two or more tables based on a related column between them. The result of a join is a new set of rows, where each row contains columns from both tables.</p>
<p>Conceptually, a join starts with the cartesian product of the left and right datasets – every row from the left table paired with every row from the right table. A join constraint (ON or USING) then filters this cartesian product to only the rows where the constraint is satisfied. Different join types control what happens with rows that have no match.</p>
<p>Turso supports INNER JOIN, LEFT OUTER JOIN, and NATURAL JOIN. Multiple joins can be chained in a single query and are evaluated left to right.</p>
<h2 id="join-types"><a class="header" href="#join-types">Join Types</a></h2>
<h3 id="inner-join"><a class="header" href="#inner-join">INNER JOIN</a></h3>
<p>An INNER JOIN returns only the rows where the join constraint is satisfied in both tables. Rows from either table that have no matching row in the other table are excluded from the result.</p>
<p>The keyword <code>INNER</code> is optional – <code>JOIN</code> by itself is equivalent to <code>INNER JOIN</code>.</p>
<pre><code class="language-sql">-- These are equivalent
SELECT * FROM users INNER JOIN departments ON users.department_id = departments.id;
SELECT * FROM users JOIN departments ON users.department_id = departments.id;
</code></pre>
<h3 id="left-outer-join"><a class="header" href="#left-outer-join">LEFT OUTER JOIN</a></h3>
<p>A LEFT JOIN returns all rows from the left table, even if there is no matching row in the right table. When a left-table row has no match, the columns from the right table are filled with NULL.</p>
<p>The keyword <code>OUTER</code> is optional – <code>LEFT JOIN</code> and <code>LEFT OUTER JOIN</code> are equivalent.</p>
<pre><code class="language-sql">-- These are equivalent
SELECT * FROM users LEFT JOIN departments ON users.department_id = departments.id;
SELECT * FROM users LEFT OUTER JOIN departments ON users.department_id = departments.id;
</code></pre>
<h3 id="natural-join"><a class="header" href="#natural-join">NATURAL JOIN</a></h3>
<p>A NATURAL JOIN automatically joins two tables on all columns that share the same name in both tables. It is equivalent to a join with a USING clause that lists every common column name.</p>
<p>If the two tables share no column names, a NATURAL JOIN behaves like a cartesian product (every row paired with every row).</p>
<p>NATURAL can be combined with LEFT to form a NATURAL LEFT JOIN. A NATURAL JOIN cannot have an explicit ON or USING clause.</p>
<pre><code class="language-sql">-- If both tables have a column named "id", this is equivalent to:
-- SELECT * FROM users JOIN profiles USING(id)
SELECT * FROM users NATURAL JOIN profiles;
</code></pre>
<h3 id="comma-separated-tables-implicit-join"><a class="header" href="#comma-separated-tables-implicit-join">Comma-Separated Tables (Implicit Join)</a></h3>
<p>Listing tables separated by commas in the FROM clause produces the cartesian product of those tables. A WHERE clause is typically used to filter the result, which is functionally equivalent to an INNER JOIN with an ON clause.</p>
<pre><code class="language-sql">-- These produce the same result
SELECT * FROM users, departments WHERE users.department_id = departments.id;
SELECT * FROM users JOIN departments ON users.department_id = departments.id;
</code></pre>
<h2 id="join-constraints"><a class="header" href="#join-constraints">Join Constraints</a></h2>
<h3 id="on-clause"><a class="header" href="#on-clause">ON Clause</a></h3>
<p>The ON clause specifies a boolean expression that is evaluated for each row of the cartesian product. Only rows where the expression evaluates to true are included in the result. The expression can reference columns from both tables.</p>
<pre><code class="language-sql">SELECT users.name, departments.name
FROM users JOIN departments ON users.department_id = departments.id;
</code></pre>
<p>The ON clause can contain compound conditions using AND, OR, and other operators:</p>
<pre><code class="language-sql">SELECT u.name, o.amount
FROM users u LEFT JOIN orders o ON u.id = o.user_id AND o.amount &gt; 75.00;
</code></pre>
<h3 id="using-clause"><a class="header" href="#using-clause">USING Clause</a></h3>
<p>The USING clause specifies one or more column names that must exist in both tables. For each named column, the join matches rows where the values are equal. This is equivalent to writing <code>ON left.col = right.col</code> for each column, but more concise.</p>
<p>An important difference from ON: the USING clause eliminates the duplicate column from the result. Only one copy of each named column appears in the output.</p>
<pre><code class="language-sql">SELECT users.name, departments.dept_name
FROM users JOIN departments USING(department_id);
</code></pre>
<p>Multiple columns can be specified in a single USING clause:</p>
<pre><code class="language-sql">SELECT * FROM t1 JOIN t2 USING(a, b);
</code></pre>
<h2 id="on-vs-where-in-outer-joins"><a class="header" href="#on-vs-where-in-outer-joins">ON vs WHERE in Outer Joins</a></h2>
<p>For INNER JOINs, placing a condition in the ON clause or the WHERE clause produces the same result. For LEFT JOINs, however, the distinction matters:</p>
<ul>
<li><strong>ON clause</strong>: The condition is applied during the join. Rows from the left table that do not match still appear in the result with NULLs for the right-table columns.</li>
<li><strong>WHERE clause</strong>: The condition is applied after the join, including after NULL rows have been added. This can filter out the unmatched rows.</li>
</ul>
<p>Consider this example where Charlie has no department (<code>department_id</code> is NULL):</p>
<pre><code class="language-sql">-- ON clause: Charlie appears with NULL department
SELECT users.name, departments.name
FROM users LEFT JOIN departments ON users.department_id = departments.id;
</code></pre>
<pre><code>┌─────────┬─────────────┐
│ name    │ name        │
├─────────┼─────────────┤
│ Alice   │ Engineering │
│ Bob     │ Marketing   │
│ Charlie │             │
└─────────┴─────────────┘
</code></pre>
<pre><code class="language-sql">-- WHERE clause: Charlie is excluded because departments.name IS NOT NULL fails
SELECT users.name, departments.name
FROM users LEFT JOIN departments ON users.department_id = departments.id
WHERE departments.name IS NOT NULL;
</code></pre>
<pre><code>┌───────┬─────────────┐
│ name  │ name        │
├───────┼─────────────┤
│ Alice │ Engineering │
│ Bob   │ Marketing   │
└───────┴─────────────┘
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="basic-inner-join"><a class="header" href="#basic-inner-join">Basic Inner Join</a></h3>
<pre><code class="language-sql">CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER);
CREATE TABLE departments (id INTEGER PRIMARY KEY, name TEXT);

INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (2, 'Bob', 2);
INSERT INTO users VALUES (3, 'Charlie', NULL);

INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO departments VALUES (2, 'Marketing');
INSERT INTO departments VALUES (3, 'Sales');

-- Return only users that have a matching department
SELECT users.name, departments.name
FROM users INNER JOIN departments ON users.department_id = departments.id;
</code></pre>
<pre><code>┌───────┬─────────────┐
│ name  │ name        │
├───────┼─────────────┤
│ Alice │ Engineering │
│ Bob   │ Marketing   │
└───────┴─────────────┘
</code></pre>
<h3 id="left-join-to-find-unmatched-rows"><a class="header" href="#left-join-to-find-unmatched-rows">Left Join to Find Unmatched Rows</a></h3>
<pre><code class="language-sql">CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE orders (id INTEGER PRIMARY KEY, user_id INTEGER, amount REAL);

INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
INSERT INTO users VALUES (3, 'Charlie');

INSERT INTO orders VALUES (1, 1, 99.99);
INSERT INTO orders VALUES (2, 1, 49.50);
INSERT INTO orders VALUES (3, 2, 150.00);

-- Find users who have never placed an order
SELECT u.name
FROM users u LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL;
</code></pre>
<pre><code>┌─────────┐
│ name    │
├─────────┤
│ Charlie │
└─────────┘
</code></pre>
<h3 id="self-join"><a class="header" href="#self-join">Self-Join</a></h3>
<p>A table can be joined to itself using aliases. This is useful for hierarchical data such as employee-manager relationships.</p>
<pre><code class="language-sql">CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, manager_id INTEGER);

INSERT INTO employees VALUES (1, 'Alice', NULL);
INSERT INTO employees VALUES (2, 'Bob', 1);
INSERT INTO employees VALUES (3, 'Charlie', 1);
INSERT INTO employees VALUES (4, 'Diana', 2);

-- Show each employee alongside their manager's name
SELECT e.name AS employee, m.name AS manager
FROM employees e LEFT JOIN employees m ON e.manager_id = m.id;
</code></pre>
<pre><code>┌──────────┬─────────┐
│ employee │ manager │
├──────────┼─────────┤
│ Alice    │         │
│ Bob      │ Alice   │
│ Charlie  │ Alice   │
│ Diana    │ Bob     │
└──────────┴─────────┘
</code></pre>
<h3 id="multi-table-join-with-aggregation"><a class="header" href="#multi-table-join-with-aggregation">Multi-Table Join with Aggregation</a></h3>
<pre><code class="language-sql">CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, department_id INTEGER);
CREATE TABLE departments (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE orders (id INTEGER PRIMARY KEY, user_id INTEGER, amount REAL);

INSERT INTO users VALUES (1, 'Alice', 1);
INSERT INTO users VALUES (2, 'Bob', 2);
INSERT INTO users VALUES (3, 'Charlie', NULL);

INSERT INTO departments VALUES (1, 'Engineering');
INSERT INTO departments VALUES (2, 'Marketing');
INSERT INTO departments VALUES (3, 'Sales');

INSERT INTO orders VALUES (1, 1, 99.99);
INSERT INTO orders VALUES (2, 1, 49.50);
INSERT INTO orders VALUES (3, 2, 150.00);

-- Show each user's department and total spending
SELECT u.name, d.name AS department, SUM(o.amount) AS total_spent
FROM users u
JOIN departments d ON u.department_id = d.id
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;
</code></pre>
<pre><code>┌───────┬─────────────┬─────────────┐
│ name  │ department  │ total_spent │
├───────┼─────────────┼─────────────┤
│ Alice │ Engineering │      149.49 │
│ Bob   │ Marketing   │       150.0 │
└───────┴─────────────┴─────────────┘
</code></pre>
<h3 id="natural-left-join"><a class="header" href="#natural-left-join">Natural Left Join</a></h3>
<pre><code class="language-sql">CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE profiles (id INTEGER PRIMARY KEY, bio TEXT);

INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
INSERT INTO users VALUES (3, 'Charlie');

INSERT INTO profiles VALUES (1, 'Engineer');
INSERT INTO profiles VALUES (2, 'Designer');

-- NATURAL LEFT JOIN matches on the shared "id" column
-- and preserves users with no profile
SELECT name, bio FROM users NATURAL LEFT JOIN profiles;
</code></pre>
<pre><code>┌─────────┬──────────┐
│ name    │ bio      │
├─────────┼──────────┤
│ Alice   │ Engineer │
│ Bob     │ Designer │
│ Charlie │          │
└─────────┴──────────┘
</code></pre>
<h3 id="join-with-a-subquery"><a class="header" href="#join-with-a-subquery">Join with a Subquery</a></h3>
<pre><code class="language-sql">CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE orders (id INTEGER PRIMARY KEY, user_id INTEGER, amount REAL);

INSERT INTO users VALUES (1, 'Alice');
INSERT INTO users VALUES (2, 'Bob');
INSERT INTO users VALUES (3, 'Charlie');

INSERT INTO orders VALUES (1, 1, 99.99);
INSERT INTO orders VALUES (2, 1, 49.50);
INSERT INTO orders VALUES (3, 2, 150.00);

-- Join against an aggregated subquery
SELECT u.name, totals.total_amount
FROM users u
JOIN (SELECT user_id, SUM(amount) AS total_amount FROM orders GROUP BY user_id) AS totals
  ON u.id = totals.user_id;
</code></pre>
<pre><code>┌───────┬──────────────┐
│ name  │ total_amount │
├───────┼──────────────┤
│ Alice │       149.49 │
│ Bob   │        150.0 │
└───────┴──────────────┘
</code></pre>
<h3 id="cartesian-product-with-comma-syntax"><a class="header" href="#cartesian-product-with-comma-syntax">Cartesian Product with Comma Syntax</a></h3>
<pre><code class="language-sql">CREATE TABLE colors (name TEXT);
CREATE TABLE sizes (name TEXT);

INSERT INTO colors VALUES ('red');
INSERT INTO colors VALUES ('blue');

INSERT INTO sizes VALUES ('small');
INSERT INTO sizes VALUES ('large');

-- Every combination of color and size
SELECT colors.name, sizes.name FROM colors, sizes;
</code></pre>
<pre><code>┌──────┬───────┐
│ name │ name  │
├──────┼───────┤
│ red  │ small │
│ red  │ large │
│ blue │ small │
│ blue │ large │
└──────┴───────┘
</code></pre>
<h2 id="compatibility-1"><a class="header" href="#compatibility-1">Compatibility</a></h2>
<p>Turso does not support the following join features available in SQLite:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>RIGHT JOIN / RIGHT OUTER JOIN</td><td>Not supported</td></tr>
<tr><td>FULL JOIN / FULL OUTER JOIN</td><td>Not supported</td></tr>
<tr><td>CROSS JOIN</td><td>Not supported. In SQLite, <code>CROSS JOIN</code> is semantically identical to <code>INNER JOIN</code> but hints the optimizer not to reorder the join. Turso does not parse this syntax. Use <code>INNER JOIN</code> or comma syntax instead.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="group-by-and-having"><a class="header" href="#group-by-and-having">GROUP BY and HAVING</a></h1>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<pre><code class="language-sql">SELECT result-column [, ...]
FROM table-or-subquery
[WHERE where-expr]
[GROUP BY expr [, ...]]
[HAVING having-expr]
</code></pre>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>The <code>GROUP BY</code> clause organizes rows into groups based on one or more expressions. When <code>GROUP BY</code> is present, each unique combination of values in the grouping expressions forms a single group, and the query returns one row per group. Aggregate functions in the result set (such as <code>COUNT()</code>, <code>SUM()</code>, <code>AVG()</code>, <code>MIN()</code>, <code>MAX()</code>, and <code>GROUP_CONCAT()</code>) are evaluated once per group rather than once for the entire result set.</p>
<p>The <code>HAVING</code> clause filters groups after they have been formed. It works like <code>WHERE</code>, but operates on the grouped results rather than on individual rows. <code>HAVING</code> is evaluated once per group and may reference aggregate functions.</p>
<p>Together, <code>GROUP BY</code> and <code>HAVING</code> enable summary queries – computing totals, averages, counts, and other statistics across categories of data.</p>
<h2 id="clauses-1"><a class="header" href="#clauses-1">Clauses</a></h2>
<h3 id="group-by"><a class="header" href="#group-by">GROUP BY</a></h3>
<p>The <code>GROUP BY</code> clause accepts one or more expressions, separated by commas. Each expression is evaluated for every row in the input, and rows that produce equal values for all grouping expressions are combined into a single group.</p>
<p>Key behaviors:</p>
<ul>
<li><strong>NULL values are considered equal</strong> for grouping purposes. All rows with NULL in a grouping column belong to the same group.</li>
<li><strong>Expressions, not just column names</strong>, may be used. You can group by computed values, <code>CASE</code> expressions, or function calls.</li>
<li><strong>Column position numbers</strong> may be used. <code>GROUP BY 1</code> refers to the first column in the result set.</li>
<li><strong>Grouping expressions need not appear in the result set.</strong> You can group by a column without selecting it.</li>
<li><strong>Grouping expressions must not be aggregate expressions.</strong> <code>GROUP BY SUM(x)</code> is an error.</li>
<li><strong>Collation sequences apply</strong> when comparing TEXT values. The default collation is <code>BINARY</code>.</li>
</ul>
<p>When no <code>GROUP BY</code> clause is present but the result set contains aggregate functions, the entire input is treated as a single group and the query returns exactly one row.</p>
<h3 id="having"><a class="header" href="#having">HAVING</a></h3>
<p>The <code>HAVING</code> clause contains a boolean expression that is evaluated once per group. Groups for which the expression evaluates to false (or NULL) are excluded from the result set.</p>
<ul>
<li><code>HAVING</code> may reference aggregate functions. This is the primary distinction from <code>WHERE</code>, which cannot.</li>
<li><code>HAVING</code> may reference values that are not in the result set.</li>
<li>If <code>HAVING</code> contains a non-aggregate expression, it is evaluated against an arbitrarily selected row from the group.</li>
<li><code>HAVING</code> can be used without <code>GROUP BY</code>. In that case the entire result set is treated as one group, and <code>HAVING</code> determines whether that single group is returned or discarded.</li>
</ul>
<h3 id="evaluation-order"><a class="header" href="#evaluation-order">Evaluation Order</a></h3>
<p>When <code>WHERE</code>, <code>GROUP BY</code>, and <code>HAVING</code> all appear in the same query, they are processed in this order:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Step</th><th>Clause</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>WHERE</code></td><td>Filters individual rows before grouping</td></tr>
<tr><td>2</td><td><code>GROUP BY</code></td><td>Organizes remaining rows into groups</td></tr>
<tr><td>3</td><td>Aggregate functions</td><td>Computed once per group</td></tr>
<tr><td>4</td><td><code>HAVING</code></td><td>Filters groups after aggregation</td></tr>
</tbody>
</table>
</div>
<p>This means <code>WHERE</code> reduces the input before any grouping occurs, while <code>HAVING</code> operates on the already-grouped results. Use <code>WHERE</code> to exclude rows you do not want aggregated. Use <code>HAVING</code> to exclude groups based on aggregate values.</p>
<h2 id="bare-columns-in-aggregate-queries"><a class="header" href="#bare-columns-in-aggregate-queries">Bare Columns in Aggregate Queries</a></h2>
<p>A “bare” column is a non-aggregate column that does not appear in the <code>GROUP BY</code> clause. For example:</p>
<pre><code class="language-sql">SELECT customer, product, SUM(quantity) FROM orders GROUP BY customer;
</code></pre>
<p>Here <code>customer</code> is in <code>GROUP BY</code>, <code>SUM(quantity)</code> is an aggregate, but <code>product</code> is a bare column. Since each group may contain multiple distinct values for <code>product</code>, the value of <code>product</code> in the result is selected from an arbitrary row within the group.</p>
<p><strong>Special behavior with <code>MIN()</code> and <code>MAX()</code>:</strong> When there is exactly one <code>MIN()</code> or <code>MAX()</code> aggregate in the query, bare columns take their values from the row that contains the minimum or maximum value. For example:</p>
<pre><code class="language-sql">SELECT customer, product, MAX(quantity) AS max_quantity
FROM orders
GROUP BY customer;
</code></pre>
<p>The <code>product</code> value in each row comes from the input row that has the largest <code>quantity</code> for that customer.</p>
<p>This behavior is an extension beyond the SQL standard. Most other database engines require every non-aggregate column to appear in the <code>GROUP BY</code> clause.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<h3 id="basic-group-by-with-count"><a class="header" href="#basic-group-by-with-count">Basic GROUP BY with COUNT</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer TEXT,
  product TEXT,
  quantity INTEGER,
  price REAL,
  region TEXT
);
INSERT INTO orders VALUES (1, 'Alice', 'Widget', 5, 9.99, 'East');
INSERT INTO orders VALUES (2, 'Bob', 'Gadget', 2, 24.99, 'West');
INSERT INTO orders VALUES (3, 'Alice', 'Gadget', 1, 24.99, 'East');
INSERT INTO orders VALUES (4, 'Carol', 'Widget', 10, 9.99, 'East');
INSERT INTO orders VALUES (5, 'Bob', 'Widget', 3, 9.99, 'West');
INSERT INTO orders VALUES (6, 'Alice', 'Gizmo', 2, 49.99, 'East');
INSERT INTO orders VALUES (7, 'Carol', 'Gadget', 4, 24.99, 'West');
INSERT INTO orders VALUES (8, 'Dave', 'Widget', 7, 9.99, 'South');

-- Count orders per customer
SELECT customer, COUNT(*) AS order_count
FROM orders
GROUP BY customer;
-- Alice|3
-- Bob|2
-- Carol|2
-- Dave|1
</code></pre>
<h3 id="group-by-with-sum"><a class="header" href="#group-by-with-sum">GROUP BY with SUM</a></h3>
<pre><code class="language-sql">-- Total quantity and revenue per product
SELECT product,
       SUM(quantity) AS total_quantity,
       SUM(quantity * price) AS total_revenue
FROM orders
GROUP BY product;
-- Gadget|7|174.93
-- Gizmo|2|99.98
-- Widget|25|249.75
</code></pre>
<h3 id="group-by-with-having"><a class="header" href="#group-by-with-having">GROUP BY with HAVING</a></h3>
<pre><code class="language-sql">-- Customers who spent more than $100
SELECT customer, SUM(quantity * price) AS total_spent
FROM orders
GROUP BY customer
HAVING SUM(quantity * price) &gt; 100;
-- Alice|174.92
-- Carol|199.86
</code></pre>
<h3 id="multiple-group-by-columns"><a class="header" href="#multiple-group-by-columns">Multiple GROUP BY Columns</a></h3>
<pre><code class="language-sql">-- Quantity sold per region and product
SELECT region, product, SUM(quantity) AS total_quantity
FROM orders
GROUP BY region, product;
-- East|Gadget|1
-- East|Gizmo|2
-- East|Widget|15
-- South|Widget|7
-- West|Gadget|6
-- West|Widget|3
</code></pre>
<h3 id="group-by-with-expression"><a class="header" href="#group-by-with-expression">GROUP BY with Expression</a></h3>
<pre><code class="language-sql">-- Classify products into price tiers and count orders per tier
SELECT CASE WHEN price &lt; 20 THEN 'Budget' ELSE 'Premium' END AS tier,
       COUNT(*) AS order_count
FROM orders
GROUP BY CASE WHEN price &lt; 20 THEN 'Budget' ELSE 'Premium' END;
-- Budget|4
-- Premium|4
</code></pre>
<h3 id="combining-where-group-by-and-having"><a class="header" href="#combining-where-group-by-and-having">Combining WHERE, GROUP BY, and HAVING</a></h3>
<pre><code class="language-sql">-- Products in the East region with total quantity above 3
SELECT product, SUM(quantity) AS total_quantity
FROM orders
WHERE region = 'East'
GROUP BY product
HAVING SUM(quantity) &gt; 3;
-- Widget|15
</code></pre>
<h3 id="multiple-aggregate-functions"><a class="header" href="#multiple-aggregate-functions">Multiple Aggregate Functions</a></h3>
<pre><code class="language-sql">-- Summary statistics per product
SELECT product,
       AVG(quantity) AS avg_quantity,
       MIN(quantity) AS min_quantity,
       MAX(quantity) AS max_quantity
FROM orders
GROUP BY product;
-- Gadget|2.33333333333333|1|4
-- Gizmo|2.0|2|2
-- Widget|6.25|3|10
</code></pre>
<h3 id="countdistinct-with-group-by"><a class="header" href="#countdistinct-with-group-by">COUNT(DISTINCT) with GROUP BY</a></h3>
<pre><code class="language-sql">-- Count unique customers and products per region
SELECT region,
       COUNT(DISTINCT customer) AS unique_customers,
       COUNT(DISTINCT product) AS unique_products
FROM orders
GROUP BY region;
-- East|2|3
-- South|1|1
-- West|2|2
</code></pre>
<h3 id="group_concat-with-group-by"><a class="header" href="#group_concat-with-group-by">GROUP_CONCAT with GROUP BY</a></h3>
<pre><code class="language-sql">-- List distinct products purchased by each customer
SELECT customer, GROUP_CONCAT(DISTINCT product) AS products
FROM orders
GROUP BY customer;
-- Alice|Widget,Gadget,Gizmo
-- Bob|Gadget,Widget
-- Carol|Widget,Gadget
-- Dave|Widget
</code></pre>
<h3 id="aggregate-without-group-by"><a class="header" href="#aggregate-without-group-by">Aggregate Without GROUP BY</a></h3>
<p>When aggregate functions appear without a <code>GROUP BY</code> clause, the entire table is treated as one group:</p>
<pre><code class="language-sql">-- Overall totals across all orders
SELECT COUNT(*) AS total_orders, SUM(quantity) AS total_items
FROM orders;
-- 8|34
</code></pre>
<h3 id="having-without-group-by"><a class="header" href="#having-without-group-by">HAVING Without GROUP BY</a></h3>
<pre><code class="language-sql">-- Return total revenue only if it exceeds $500
SELECT SUM(quantity * price) AS revenue
FROM orders
HAVING SUM(quantity * price) &gt; 500;
-- 524.66
</code></pre>
<h3 id="null-grouping"><a class="header" href="#null-grouping">NULL Grouping</a></h3>
<pre><code class="language-sql">CREATE TABLE survey (
  id INTEGER PRIMARY KEY,
  respondent TEXT,
  rating INTEGER
);
INSERT INTO survey VALUES (1, 'Alice', 5);
INSERT INTO survey VALUES (2, NULL, 3);
INSERT INTO survey VALUES (3, 'Bob', 4);
INSERT INTO survey VALUES (4, NULL, 2);
INSERT INTO survey VALUES (5, 'Alice', 3);

-- NULL respondents are grouped together
SELECT respondent, COUNT(*) AS responses, AVG(rating) AS avg_rating
FROM survey
GROUP BY respondent;
-- (NULL)|2|2.5
-- Alice|2|4.0
-- Bob|1|4.0
</code></pre>
<h3 id="group-by-with-column-position"><a class="header" href="#group-by-with-column-position">GROUP BY with Column Position</a></h3>
<pre><code class="language-sql">-- Group by the first column in the result set
SELECT customer, COUNT(*) AS order_count
FROM orders
GROUP BY 1;
-- Alice|3
-- Bob|2
-- Carol|2
-- Dave|1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="order-by-limit-offset"><a class="header" href="#order-by-limit-offset">ORDER BY, LIMIT, OFFSET</a></h1>
<h2 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h2>
<pre><code class="language-sql">SELECT result-column [, ...]
FROM table-or-subquery
[WHERE expr]
[GROUP BY expr [, ...]]
[ORDER BY ordering-term [, ...]]
[LIMIT expr [{OFFSET expr | , expr}]]
</code></pre>
<p>Where each <code>ordering-term</code> is:</p>
<pre><code class="language-sql">expr [{ASC | DESC}] [COLLATE collation-name]
</code></pre>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>The <code>ORDER BY</code> clause determines the order in which rows are returned by a <code>SELECT</code> statement. Without an <code>ORDER BY</code> clause, the order of rows in the result set is undefined – the database may return them in any order it chooses, and that order may differ between executions.</p>
<p>The <code>LIMIT</code> clause places an upper bound on the number of rows returned. The optional <code>OFFSET</code> clause (or the comma syntax) skips a number of rows before returning results. Together, <code>ORDER BY</code>, <code>LIMIT</code>, and <code>OFFSET</code> are the building blocks for sorted output, top-N queries, and pagination.</p>
<p>These clauses appear at the end of a <code>SELECT</code> statement, after any <code>WHERE</code>, <code>GROUP BY</code>, and <code>HAVING</code> clauses. In a compound <code>SELECT</code> (using <code>UNION</code>, <code>INTERSECT</code>, or <code>EXCEPT</code>), only the final <code>SELECT</code> may include <code>ORDER BY</code> and <code>LIMIT</code>, and they apply to the entire compound result.</p>
<h2 id="clauses-2"><a class="header" href="#clauses-2">Clauses</a></h2>
<h3 id="order-by"><a class="header" href="#order-by">ORDER BY</a></h3>
<p>The <code>ORDER BY</code> clause accepts one or more ordering terms, separated by commas. Each term is an expression that defines a sort key. Rows are sorted by the first term; ties are broken by the second term, and so on.</p>
<p>Each ordering term is evaluated against every row. The resulting values are compared to determine output order. By default, rows are sorted in ascending order (<code>ASC</code>), where smaller values come first.</p>
<p><strong>Sort direction:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>ASC</code></td><td>Ascending order (default). Smaller values first.</td></tr>
<tr><td><code>DESC</code></td><td>Descending order. Larger values first.</td></tr>
</tbody>
</table>
</div>
<p><strong>NULL handling:</strong></p>
<p>Turso considers NULL values to be smaller than any other value for sorting purposes. This means:</p>
<ul>
<li>In ascending order (<code>ASC</code>), NULLs appear at the beginning of the result set.</li>
<li>In descending order (<code>DESC</code>), NULLs appear at the end of the result set.</li>
</ul>
<p><strong>Expression resolution:</strong></p>
<p>Each <code>ORDER BY</code> expression is resolved in the following order of precedence:</p>
<ol>
<li><strong>Integer constant K:</strong> Treated as a reference to the K-th column of the result set, numbered from left to right starting at 1.</li>
<li><strong>Identifier matching a column alias:</strong> If the expression is a simple identifier that matches the alias of an output column, it refers to that column.</li>
<li><strong>Arbitrary expression:</strong> Otherwise, the expression is evaluated per row and the resulting value determines sort order. Any valid expression may be used, including function calls, arithmetic, and <code>CASE</code> expressions.</li>
</ol>
<p><strong>Collation:</strong></p>
<p>Text values are compared using a collation sequence. The collation used for each ordering term is determined by this precedence:</p>
<ol>
<li>If the ordering term includes <code>COLLATE collation-name</code>, that collation is used.</li>
<li>If the ordering term refers to a column (directly or via alias) that has a default collation, that collation is used.</li>
<li>Otherwise, the <code>BINARY</code> collation is used.</li>
</ol>
<p>The built-in collation sequences are:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Collation</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>BINARY</code></td><td>Byte-by-byte comparison. Uppercase letters sort before lowercase. Default.</td></tr>
<tr><td><code>NOCASE</code></td><td>Case-insensitive comparison for ASCII characters.</td></tr>
<tr><td><code>RTRIM</code></td><td>Like <code>BINARY</code>, but trailing spaces are ignored.</td></tr>
</tbody>
</table>
</div>
<h3 id="limit"><a class="header" href="#limit">LIMIT</a></h3>
<p>The <code>LIMIT</code> clause restricts the number of rows returned. It takes a single expression that must evaluate to an integer (or a value that can be losslessly converted to an integer).</p>
<ul>
<li>If the LIMIT value is non-negative, at most that many rows are returned.</li>
<li>If the LIMIT value is negative, there is no upper bound – all rows are returned.</li>
<li>If the LIMIT expression evaluates to NULL or to a value that cannot be losslessly converted to an integer, an error is returned.</li>
</ul>
<p><code>LIMIT</code> is most useful when combined with <code>ORDER BY</code>. Without <code>ORDER BY</code>, the set of rows returned by <code>LIMIT</code> is arbitrary and unpredictable.</p>
<h3 id="offset"><a class="header" href="#offset">OFFSET</a></h3>
<p>The <code>OFFSET</code> clause skips a specified number of rows from the beginning of the result set before returning rows. The expression must evaluate to an integer (or a value that can be losslessly converted to an integer).</p>
<ul>
<li>If the OFFSET value is zero or negative, no rows are skipped.</li>
<li>If the OFFSET value is NULL or cannot be losslessly converted to an integer, an error is returned.</li>
</ul>
<p>When both <code>LIMIT</code> and <code>OFFSET</code> are specified, the first M rows are skipped (where M is the OFFSET value), and then the next N rows are returned (where N is the LIMIT value). If the result set contains fewer than M + N rows, all rows after the first M are returned.</p>
<p><strong>Two syntax forms:</strong></p>
<p>Turso supports two equivalent ways to write LIMIT with OFFSET:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Form</th><th>Syntax</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>Keyword form</td><td><code>LIMIT N OFFSET M</code></td><td>Skip M rows, return at most N rows</td></tr>
<tr><td>Comma form</td><td><code>LIMIT M, N</code></td><td>Skip M rows, return at most N rows</td></tr>
</tbody>
</table>
</div>
<p>Note that the comma form reverses the order of the values: the first value is the offset and the second is the limit. This is a common source of confusion. The keyword form (<code>LIMIT N OFFSET M</code>) is recommended for clarity.</p>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="sorting-by-a-single-column"><a class="header" href="#sorting-by-a-single-column">Sorting by a Single Column</a></h3>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price REAL,
  category TEXT
);
INSERT INTO products VALUES (1, 'Keyboard', 49.99, 'Electronics');
INSERT INTO products VALUES (2, 'Notebook', 5.99, 'Stationery');
INSERT INTO products VALUES (3, 'Monitor', 299.99, 'Electronics');
INSERT INTO products VALUES (4, 'Pen', 1.99, 'Stationery');
INSERT INTO products VALUES (5, 'Mouse', 29.99, 'Electronics');

-- Sort by price, cheapest first (ascending is the default)
SELECT name, price FROM products ORDER BY price;
-- Pen|1.99
-- Notebook|5.99
-- Mouse|29.99
-- Keyboard|49.99
-- Monitor|299.99
</code></pre>
<h3 id="descending-order"><a class="header" href="#descending-order">Descending Order</a></h3>
<pre><code class="language-sql">-- Sort by price, most expensive first
SELECT name, price FROM products ORDER BY price DESC;
-- Monitor|299.99
-- Keyboard|49.99
-- Mouse|29.99
-- Notebook|5.99
-- Pen|1.99
</code></pre>
<h3 id="sorting-by-multiple-columns"><a class="header" href="#sorting-by-multiple-columns">Sorting by Multiple Columns</a></h3>
<pre><code class="language-sql">-- Sort by category ascending, then by price descending within each category
SELECT name, category, price FROM products ORDER BY category ASC, price DESC;
-- Monitor|Electronics|299.99
-- Keyboard|Electronics|49.99
-- Mouse|Electronics|29.99
-- Notebook|Stationery|5.99
-- Pen|Stationery|1.99
</code></pre>
<h3 id="ordering-by-column-number"><a class="header" href="#ordering-by-column-number">Ordering by Column Number</a></h3>
<pre><code class="language-sql">-- Order by the second column in the result set (price)
SELECT name, price FROM products ORDER BY 2;
-- Pen|1.99
-- Notebook|5.99
-- Mouse|29.99
-- Keyboard|49.99
-- Monitor|299.99
</code></pre>
<h3 id="ordering-by-alias"><a class="header" href="#ordering-by-alias">Ordering by Alias</a></h3>
<pre><code class="language-sql">-- Order by a computed column alias
SELECT name, price * 1.1 AS price_with_tax
FROM products ORDER BY price_with_tax LIMIT 3;
-- Pen|2.189
-- Notebook|6.589
-- Mouse|32.989
</code></pre>
<h3 id="ordering-by-expression"><a class="header" href="#ordering-by-expression">Ordering by Expression</a></h3>
<pre><code class="language-sql">-- Sort by name length (descending), then alphabetically for ties
SELECT name, length(name) AS name_len
FROM products ORDER BY length(name) DESC, name ASC LIMIT 3;
-- Keyboard|8
-- Notebook|8
-- Monitor|7
</code></pre>
<h3 id="collation-in-order-by"><a class="header" href="#collation-in-order-by">Collation in ORDER BY</a></h3>
<pre><code class="language-sql">CREATE TABLE words (word TEXT);
INSERT INTO words VALUES ('banana');
INSERT INTO words VALUES ('Apple');
INSERT INTO words VALUES ('cherry');
INSERT INTO words VALUES ('Blueberry');

-- Default BINARY collation: uppercase letters sort before lowercase
SELECT word FROM words ORDER BY word;
-- Apple
-- Blueberry
-- banana
-- cherry

-- NOCASE collation: case-insensitive sorting
SELECT word FROM words ORDER BY word COLLATE NOCASE;
-- Apple
-- banana
-- Blueberry
-- cherry
</code></pre>
<h3 id="null-ordering"><a class="header" href="#null-ordering">NULL Ordering</a></h3>
<pre><code class="language-sql">CREATE TABLE scores (student TEXT, score INTEGER);
INSERT INTO scores VALUES ('Alice', 90);
INSERT INTO scores VALUES ('Bob', NULL);
INSERT INTO scores VALUES ('Carol', 85);
INSERT INTO scores VALUES ('Dave', NULL);

-- Ascending: NULLs appear first (NULLs are considered smaller than all other values)
SELECT student, score FROM scores ORDER BY score ASC;
-- Bob|
-- Dave|
-- Carol|85
-- Alice|90

-- Descending: NULLs appear last
SELECT student, score FROM scores ORDER BY score DESC;
-- Alice|90
-- Carol|85
-- Bob|
-- Dave|
</code></pre>
<h3 id="basic-limit"><a class="header" href="#basic-limit">Basic LIMIT</a></h3>
<pre><code class="language-sql">-- Return the 3 cheapest products
SELECT name, price FROM products ORDER BY price LIMIT 3;
-- Pen|1.99
-- Notebook|5.99
-- Mouse|29.99
</code></pre>
<h3 id="limit-with-offset-keyword-form"><a class="header" href="#limit-with-offset-keyword-form">LIMIT with OFFSET (Keyword Form)</a></h3>
<pre><code class="language-sql">-- Skip the 2 cheapest products, return the next 2
SELECT name, price FROM products ORDER BY price LIMIT 2 OFFSET 2;
-- Mouse|29.99
-- Keyboard|49.99
</code></pre>
<h3 id="limit-with-offset-comma-form"><a class="header" href="#limit-with-offset-comma-form">LIMIT with OFFSET (Comma Form)</a></h3>
<pre><code class="language-sql">-- Same result as above: LIMIT offset, count
SELECT name, price FROM products ORDER BY price LIMIT 2, 2;
-- Mouse|29.99
-- Keyboard|49.99
</code></pre>
<h3 id="negative-limit"><a class="header" href="#negative-limit">Negative LIMIT</a></h3>
<pre><code class="language-sql">-- A negative LIMIT returns all rows (no upper bound)
SELECT name FROM products ORDER BY name LIMIT -1;
-- Keyboard
-- Monitor
-- Mouse
-- Notebook
-- Pen
</code></pre>
<h3 id="pagination-pattern"><a class="header" href="#pagination-pattern">Pagination Pattern</a></h3>
<pre><code class="language-sql">CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT,
  department TEXT,
  salary REAL
);
INSERT INTO employees VALUES (1, 'Alice', 'Engineering', 95000);
INSERT INTO employees VALUES (2, 'Bob', 'Marketing', 72000);
INSERT INTO employees VALUES (3, 'Carol', 'Engineering', 98000);
INSERT INTO employees VALUES (4, 'Dave', 'Sales', 68000);
INSERT INTO employees VALUES (5, 'Eve', 'Marketing', 75000);
INSERT INTO employees VALUES (6, 'Frank', 'Engineering', 102000);
INSERT INTO employees VALUES (7, 'Grace', 'Sales', 71000);
INSERT INTO employees VALUES (8, 'Heidi', 'Engineering', 91000);

-- Page 1 (first 3 employees by salary descending)
SELECT name, salary FROM employees ORDER BY salary DESC LIMIT 3 OFFSET 0;
-- Frank|102000.0
-- Carol|98000.0
-- Alice|95000.0

-- Page 2 (next 3)
SELECT name, salary FROM employees ORDER BY salary DESC LIMIT 3 OFFSET 3;
-- Heidi|91000.0
-- Eve|75000.0
-- Bob|72000.0

-- Page 3 (remaining)
SELECT name, salary FROM employees ORDER BY salary DESC LIMIT 3 OFFSET 6;
-- Grace|71000.0
-- Dave|68000.0
</code></pre>
<h2 id="compatibility-2"><a class="header" href="#compatibility-2">Compatibility</a></h2>
<ul>
<li><code>NULLS FIRST</code> and <code>NULLS LAST</code> are not yet fully supported. <code>NULLS LAST</code> returns a parse error. <code>NULLS FIRST</code> is accepted by the parser but does not change the sort behavior – NULLs always sort as the smallest values regardless. This means there is currently no way to override the default NULL placement in sort results.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="set-operations"><a class="header" href="#set-operations">Set Operations</a></h1>
<h2 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h2>
<pre><code class="language-sql">select-statement {UNION | UNION ALL | INTERSECT | EXCEPT} select-statement
</code></pre>
<p>A compound SELECT chains two or more simple SELECT statements with a set operator. Multiple operators can be chained:</p>
<pre><code class="language-sql">select-statement op select-statement [op select-statement ...]
</code></pre>
<p>An optional LIMIT clause may appear after the last SELECT:</p>
<pre><code class="language-sql">select-statement op select-statement [LIMIT expr [OFFSET expr]]
</code></pre>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<p>Set operations combine the results of two or more SELECT statements into a single result set. Each constituent SELECT must return the same number of columns. Columns are matched by position (left to right), not by name. The column names in the final result are taken from the leftmost SELECT statement.</p>
<p>Turso supports four set operators:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Duplicates</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>UNION ALL</code></td><td>Keeps all</td><td>Returns every row from both queries, including duplicates.</td></tr>
<tr><td><code>UNION</code></td><td>Removed</td><td>Returns all rows from both queries, removing duplicate rows.</td></tr>
<tr><td><code>INTERSECT</code></td><td>Removed</td><td>Returns only rows that appear in both queries.</td></tr>
<tr><td><code>EXCEPT</code></td><td>Removed</td><td>Returns rows from the left query that do not appear in the right query.</td></tr>
</tbody>
</table>
</div>
<p>UNION, INTERSECT, and EXCEPT all remove duplicate rows from the final result. UNION ALL is the only operator that preserves duplicates.</p>
<h2 id="clauses-3"><a class="header" href="#clauses-3">Clauses</a></h2>
<h3 id="union-all"><a class="header" href="#union-all">UNION ALL</a></h3>
<p>UNION ALL returns all rows from the left SELECT followed by all rows from the right SELECT. No duplicate detection or removal is performed, making UNION ALL the most efficient set operator.</p>
<pre><code class="language-sql">-- Combine all employees and contractors, keeping duplicates
SELECT name, department FROM employees
UNION ALL
SELECT name, department FROM contractors;
</code></pre>
<p>If a person appears in both tables with the same name and department, that combination appears twice in the result.</p>
<h3 id="union"><a class="header" href="#union">UNION</a></h3>
<p>UNION works the same way as UNION ALL but removes duplicate rows from the combined result. Two rows are considered duplicates when every corresponding column value is equal.</p>
<pre><code class="language-sql">-- Combine employees and contractors, removing duplicates
SELECT name, department FROM employees
UNION
SELECT name, department FROM contractors;
</code></pre>
<h3 id="intersect"><a class="header" href="#intersect">INTERSECT</a></h3>
<p>INTERSECT returns only rows that appear in both the left and right result sets. The output contains no duplicates.</p>
<pre><code class="language-sql">-- Find people who appear in both tables with the same department
SELECT name, department FROM employees
INTERSECT
SELECT name, department FROM contractors;
</code></pre>
<h3 id="except"><a class="header" href="#except">EXCEPT</a></h3>
<p>EXCEPT returns rows from the left query that are not present in the right query. The output contains no duplicates. The order of the two queries matters: <code>A EXCEPT B</code> is different from <code>B EXCEPT A</code>.</p>
<pre><code class="language-sql">-- Find employees who are not also contractors (by name and department)
SELECT name, department FROM employees
EXCEPT
SELECT name, department FROM contractors;
</code></pre>
<h3 id="limit-1"><a class="header" href="#limit-1">LIMIT</a></h3>
<p>A LIMIT clause may appear after the final SELECT in a compound statement. The limit applies to the entire combined result, not just the last SELECT.</p>
<pre><code class="language-sql">-- Get the first 4 rows from the combined result
SELECT name, department FROM employees
UNION ALL
SELECT name, department FROM contractors
LIMIT 4;
</code></pre>
<p>OFFSET is also supported:</p>
<pre><code class="language-sql">-- Skip the first row and return the next 3
SELECT name, department FROM employees
UNION ALL
SELECT name, department FROM contractors
LIMIT 3 OFFSET 1;
</code></pre>
<h2 id="column-matching-rules"><a class="header" href="#column-matching-rules">Column Matching Rules</a></h2>
<p>All SELECT statements in a compound query must produce the same number of result columns. If they do not, Turso returns an error:</p>
<pre><code class="language-sql">-- Error: different number of columns
SELECT name, department FROM employees
UNION ALL
SELECT name FROM contractors;
-- SELECTs to the left and right of UNION ALL do not have the same number of result columns
</code></pre>
<p>Columns are matched by position. The first column of the left SELECT pairs with the first column of the right SELECT, and so on. Column names and types do not need to match – only the count must be equal.</p>
<p>The result column names are always determined by the leftmost SELECT:</p>
<pre><code class="language-sql">SELECT 1 AS first_col, 2 AS second_col
UNION ALL
SELECT 3, 4;
-- Column headers are "first_col" and "second_col"
</code></pre>
<h2 id="duplicate-detection"><a class="header" href="#duplicate-detection">Duplicate Detection</a></h2>
<p>For the purpose of identifying duplicate rows in UNION, INTERSECT, and EXCEPT:</p>
<ul>
<li><strong>NULL values are considered equal to each other.</strong> Two rows that both contain NULL in the same column position are treated as matching in that column.</li>
<li><strong>No type affinity transformations</strong> are applied when comparing rows. Values are compared as-is.</li>
<li><strong>Text comparisons</strong> use the collation sequence that would apply if the columns from the left and right SELECTs were operands of the <code>=</code> operator.</li>
</ul>
<pre><code class="language-sql">-- NULL is treated as equal to NULL for dedup purposes
SELECT NULL UNION SELECT NULL;
-- Returns one row (a single NULL)
</code></pre>
<h2 id="chaining-multiple-operators"><a class="header" href="#chaining-multiple-operators">Chaining Multiple Operators</a></h2>
<p>Three or more SELECT statements can be connected with set operators. When chained, they group from left to right. That is, <code>A op1 B op2 C</code> is evaluated as <code>(A op1 B) op2 C</code>.</p>
<pre><code class="language-sql">-- Three-way UNION ALL: employees, contractors, and interns
SELECT name, department FROM employees
UNION ALL
SELECT name, department FROM contractors
UNION ALL
SELECT name, department FROM interns;
</code></pre>
<p>Different operators can be mixed in the same compound statement:</p>
<pre><code class="language-sql">-- First combine and deduplicate, then append without dedup
SELECT name, department FROM employees
UNION
SELECT name, department FROM contractors
UNION ALL
SELECT name, department FROM interns;
</code></pre>
<h2 id="using-set-operations-in-subqueries"><a class="header" href="#using-set-operations-in-subqueries">Using Set Operations in Subqueries</a></h2>
<p>A compound SELECT can be used as a subquery in the FROM clause. This is useful for aggregating or filtering the combined result:</p>
<pre><code class="language-sql">-- Count headcount per department across all worker types
SELECT department, COUNT(*) AS headcount
FROM (
    SELECT name, department FROM employees
    UNION ALL
    SELECT name, department FROM contractors
)
GROUP BY department;
</code></pre>
<pre><code class="language-sql">-- Filter the combined result
SELECT *
FROM (
    SELECT name, department FROM employees
    UNION ALL
    SELECT name, department FROM contractors
)
WHERE department = 'Engineering';
</code></pre>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>The examples below use the following tables:</p>
<pre><code class="language-sql">CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT,
  department TEXT,
  salary REAL
);
INSERT INTO employees VALUES
  (1, 'Alice', 'Engineering', 95000),
  (2, 'Bob', 'Engineering', 88000),
  (3, 'Carol', 'Marketing', 72000),
  (4, 'Dave', 'Marketing', 68000),
  (5, 'Eve', 'Sales', 75000);

CREATE TABLE contractors (
  id INTEGER PRIMARY KEY,
  name TEXT,
  department TEXT,
  rate REAL
);
INSERT INTO contractors VALUES
  (1, 'Frank', 'Engineering', 110000),
  (2, 'Grace', 'Marketing', 65000),
  (3, 'Alice', 'Engineering', 95000);
</code></pre>
<h3 id="union-all--all-people-including-duplicates"><a class="header" href="#union-all--all-people-including-duplicates">UNION ALL – All People Including Duplicates</a></h3>
<pre><code class="language-sql">SELECT name, department FROM employees
UNION ALL
SELECT name, department FROM contractors;
-- Alice|Engineering
-- Bob|Engineering
-- Carol|Marketing
-- Dave|Marketing
-- Eve|Sales
-- Frank|Engineering
-- Grace|Marketing
-- Alice|Engineering
</code></pre>
<p>Note that “Alice | Engineering” appears twice because UNION ALL does not remove duplicates.</p>
<h3 id="union--all-people-without-duplicates"><a class="header" href="#union--all-people-without-duplicates">UNION – All People Without Duplicates</a></h3>
<pre><code class="language-sql">SELECT name, department FROM employees
UNION
SELECT name, department FROM contractors;
-- Alice|Engineering
-- Bob|Engineering
-- Carol|Marketing
-- Dave|Marketing
-- Eve|Sales
-- Frank|Engineering
-- Grace|Marketing
</code></pre>
<p>The duplicate “Alice | Engineering” row has been removed. The result has 7 rows instead of 8.</p>
<h3 id="intersect--people-in-both-tables"><a class="header" href="#intersect--people-in-both-tables">INTERSECT – People in Both Tables</a></h3>
<pre><code class="language-sql">SELECT name, department FROM employees
INTERSECT
SELECT name, department FROM contractors;
-- Alice|Engineering
</code></pre>
<p>Only “Alice | Engineering” appears in both tables.</p>
<h3 id="except--employees-who-are-not-contractors"><a class="header" href="#except--employees-who-are-not-contractors">EXCEPT – Employees Who Are Not Contractors</a></h3>
<pre><code class="language-sql">SELECT name, department FROM employees
EXCEPT
SELECT name, department FROM contractors;
-- Bob|Engineering
-- Carol|Marketing
-- Dave|Marketing
-- Eve|Sales
</code></pre>
<p>Alice is excluded because she appears in both tables with the same name and department.</p>
<h3 id="finding-common-departments"><a class="header" href="#finding-common-departments">Finding Common Departments</a></h3>
<pre><code class="language-sql">SELECT department FROM employees
INTERSECT
SELECT department FROM contractors;
-- Engineering
-- Marketing
</code></pre>
<h3 id="finding-departments-unique-to-employees"><a class="header" href="#finding-departments-unique-to-employees">Finding Departments Unique to Employees</a></h3>
<pre><code class="language-sql">SELECT department FROM employees
EXCEPT
SELECT department FROM contractors;
-- Sales
</code></pre>
<p>Sales exists only in the employees table.</p>
<h3 id="aggregating-a-combined-result"><a class="header" href="#aggregating-a-combined-result">Aggregating a Combined Result</a></h3>
<pre><code class="language-sql">SELECT department, COUNT(*) AS headcount
FROM (
    SELECT name, department FROM employees
    UNION ALL
    SELECT name, department FROM contractors
)
GROUP BY department;
-- Engineering|4
-- Marketing|3
-- Sales|1
</code></pre>
<p>Note that UNION ALL is used here so that each person is counted, even if they appear in both tables.</p>
<h3 id="limiting-the-combined-result"><a class="header" href="#limiting-the-combined-result">Limiting the Combined Result</a></h3>
<pre><code class="language-sql">SELECT name, department FROM employees
UNION ALL
SELECT name, department FROM contractors
LIMIT 4;
-- Alice|Engineering
-- Bob|Engineering
-- Carol|Marketing
-- Dave|Marketing
</code></pre>
<h3 id="using-values-with-set-operations"><a class="header" href="#using-values-with-set-operations">Using VALUES with Set Operations</a></h3>
<pre><code class="language-sql">VALUES (1, 'Alice'), (2, 'Bob')
UNION ALL
VALUES (3, 'Carol');
-- 1|Alice
-- 2|Bob
-- 3|Carol
</code></pre>
<h2 id="compatibility-3"><a class="header" href="#compatibility-3">Compatibility</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>ORDER BY on compound SELECT</td><td>Not yet supported. Turso does not currently allow ORDER BY on the final result of a compound SELECT. As a workaround, wrap the compound SELECT in a subquery and apply ORDER BY to the outer query.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="subqueries"><a class="header" href="#subqueries">Subqueries</a></h1>
<h2 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h2>
<p>A subquery is a <code>SELECT</code> statement enclosed in parentheses, used as an expression or table source within another SQL statement.</p>
<pre><code class="language-sql">-- Scalar subquery (returns a single value)
(SELECT expr FROM table-name [WHERE ...])

-- EXISTS / NOT EXISTS
[NOT] EXISTS (SELECT ... FROM table-name [WHERE ...])

-- IN / NOT IN with subquery
expr [NOT] IN (SELECT expr FROM table-name [WHERE ...])

-- Derived table (subquery in FROM clause)
SELECT ... FROM (SELECT ... FROM table-name) AS alias
</code></pre>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<p>Subqueries allow you to nest one query inside another. They appear in several forms depending on context: as a single value in an expression (scalar subquery), as a set membership test (<code>IN</code>), as an existence check (<code>EXISTS</code>), or as a virtual table in the <code>FROM</code> clause (derived table).</p>
<p>A subquery can reference columns from its enclosing query. When it does, it is called a <strong>correlated subquery</strong> and is re-evaluated for each row of the outer query. When a subquery does not reference any outer columns, it is an <strong>uncorrelated subquery</strong> and may be evaluated once and its result reused.</p>
<h2 id="scalar-subqueries"><a class="header" href="#scalar-subqueries">Scalar Subqueries</a></h2>
<p>A scalar subquery is a <code>SELECT</code> enclosed in parentheses that returns a single column. It can appear anywhere an expression is allowed: in the <code>SELECT</code> list, <code>WHERE</code> clause, <code>HAVING</code> clause, or even <code>LIMIT</code> and <code>OFFSET</code>.</p>
<p>The value of a scalar subquery is the value from the first row returned. If the subquery returns no rows, the result is <code>NULL</code>. If the subquery returns more than one column, Turso raises an error.</p>
<pre><code class="language-sql">-- Scalar subquery in SELECT list
SELECT expr, (SELECT agg_func(...) FROM table-name) AS alias FROM table-name

-- Scalar subquery in WHERE clause
SELECT ... FROM table-name WHERE column &gt; (SELECT agg_func(...) FROM table-name)
</code></pre>
<h2 id="exists-and-not-exists"><a class="header" href="#exists-and-not-exists">EXISTS and NOT EXISTS</a></h2>
<p>The <code>EXISTS</code> operator takes a subquery and evaluates to <code>1</code> (true) if the subquery returns at least one row, or <code>0</code> (false) if the subquery returns no rows. <code>NOT EXISTS</code> returns the opposite.</p>
<p>The number of columns returned by the subquery and their values do not matter. Only the presence or absence of rows is significant. By convention, <code>SELECT 1</code> is often used inside <code>EXISTS</code> subqueries.</p>
<pre><code class="language-sql">-- Returns rows from outer query where the subquery matches at least one row
SELECT ... FROM table-name t
WHERE EXISTS (SELECT 1 FROM other-table o WHERE o.ref_id = t.id)

-- Returns rows where no matching row exists
SELECT ... FROM table-name t
WHERE NOT EXISTS (SELECT 1 FROM other-table o WHERE o.ref_id = t.id)
</code></pre>
<p><code>EXISTS</code> is commonly used with correlated subqueries to test whether related rows exist in another table.</p>
<h2 id="in-and-not-in-with-subqueries"><a class="header" href="#in-and-not-in-with-subqueries">IN and NOT IN with Subqueries</a></h2>
<p>The <code>IN</code> operator tests whether a value is a member of the set of values returned by a subquery. The subquery must return a single column. <code>NOT IN</code> tests the inverse.</p>
<pre><code class="language-sql">expr [NOT] IN (SELECT column FROM table-name [WHERE ...])
</code></pre>
<h3 id="null-handling-1"><a class="header" href="#null-handling-1">NULL Handling</a></h3>
<p>The behavior of <code>IN</code> and <code>NOT IN</code> with <code>NULL</code> values follows specific rules:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Left Value</th><th>Subquery Contains NULL</th><th>Value Found</th><th><code>IN</code> Result</th><th><code>NOT IN</code> Result</th></tr>
</thead>
<tbody>
<tr><td>non-NULL</td><td>no</td><td>no</td><td>0 (false)</td><td>1 (true)</td></tr>
<tr><td>non-NULL</td><td>no</td><td>yes</td><td>1 (true)</td><td>0 (false)</td></tr>
<tr><td>non-NULL</td><td>yes</td><td>no</td><td>NULL</td><td>NULL</td></tr>
<tr><td>non-NULL</td><td>yes</td><td>yes</td><td>1 (true)</td><td>0 (false)</td></tr>
<tr><td>NULL</td><td>any</td><td>(empty set)</td><td>0 (false)</td><td>1 (true)</td></tr>
<tr><td>NULL</td><td>any</td><td>(non-empty)</td><td>NULL</td><td>NULL</td></tr>
</tbody>
</table>
</div>
<p>Key takeaways:</p>
<ul>
<li>When the subquery returns an empty set, <code>IN</code> always returns <code>0</code> and <code>NOT IN</code> always returns <code>1</code>, regardless of <code>NULL</code> values.</li>
<li>When the left value is found in the set, <code>IN</code> returns <code>1</code> even if the set also contains <code>NULL</code>.</li>
<li>When the left value is not found and the set contains <code>NULL</code>, the result is <code>NULL</code> (unknown), not <code>0</code>. This is because the value might match the unknown (<code>NULL</code>) element.</li>
</ul>
<h2 id="correlated-subqueries"><a class="header" href="#correlated-subqueries">Correlated Subqueries</a></h2>
<p>A correlated subquery references one or more columns from the outer query. Turso re-evaluates a correlated subquery for each row processed by the outer query.</p>
<pre><code class="language-sql">-- The inner query references e.department_id from the outer query
SELECT ... FROM employees e
WHERE e.salary &gt; (
    SELECT AVG(e2.salary) FROM employees e2
    WHERE e2.department_id = e.department_id
)
</code></pre>
<p>Correlated subqueries are supported in the <code>SELECT</code> list, <code>WHERE</code> clause, <code>HAVING</code> clause, and <code>GROUP BY</code> clause. Correlated subqueries can also be used with <code>EXISTS</code> and <code>IN</code>.</p>
<p><strong>Note:</strong> Correlated subqueries in the <code>ORDER BY</code> clause are not currently supported.</p>
<h2 id="derived-tables"><a class="header" href="#derived-tables">Derived Tables</a></h2>
<p>A subquery in the <code>FROM</code> clause creates a derived table (also called an inline view). The subquery result is treated as a temporary table for the duration of the outer query.</p>
<p>A derived table must be given an alias using the <code>AS</code> keyword.</p>
<pre><code class="language-sql">SELECT alias.column [, ...]
FROM (SELECT ... FROM table-name [WHERE ...] [GROUP BY ...]) AS alias
[JOIN other-table ON ...]
[WHERE ...]
</code></pre>
<p>Each column of the derived table inherits the type affinity and collation sequence of the corresponding expression in the subquery.</p>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<h3 id="scalar-subquery-in-select-list"><a class="header" href="#scalar-subquery-in-select-list">Scalar Subquery in SELECT List</a></h3>
<pre><code class="language-sql">CREATE TABLE employees (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    department_id INTEGER,
    salary REAL
);
INSERT INTO employees VALUES
    (1, 'Alice', 1, 95000), (2, 'Bob', 1, 88000),
    (3, 'Carol', 2, 72000), (4, 'Dave', 3, 68000),
    (5, 'Eve', 1, 105000), (6, 'Frank', 2, 71000);

-- Show each employee's salary alongside the company average
SELECT name, salary,
       (SELECT AVG(salary) FROM employees) AS avg_salary
FROM employees
ORDER BY salary DESC;
-- Eve   | 105000.0 | 83166.6666666667
-- Alice |  95000.0 | 83166.6666666667
-- Bob   |  88000.0 | 83166.6666666667
-- Carol |  72000.0 | 83166.6666666667
-- Frank |  71000.0 | 83166.6666666667
-- Dave  |  68000.0 | 83166.6666666667
</code></pre>
<h3 id="scalar-subquery-in-where-clause"><a class="header" href="#scalar-subquery-in-where-clause">Scalar Subquery in WHERE Clause</a></h3>
<pre><code class="language-sql">-- Find employees earning above the company average
SELECT name, salary
FROM employees
WHERE salary &gt; (SELECT AVG(salary) FROM employees);
-- Alice |  95000.0
-- Bob   |  88000.0
-- Eve   | 105000.0
</code></pre>
<h3 id="scalar-subquery-returning-null"><a class="header" href="#scalar-subquery-returning-null">Scalar Subquery Returning NULL</a></h3>
<p>When a scalar subquery matches no rows, it returns <code>NULL</code>:</p>
<pre><code class="language-sql">SELECT (SELECT name FROM employees WHERE id = 999) AS result;
-- (NULL)
</code></pre>
<h3 id="exists-find-departments-with-employees"><a class="header" href="#exists-find-departments-with-employees">EXISTS: Find Departments with Employees</a></h3>
<pre><code class="language-sql">CREATE TABLE departments (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
);
INSERT INTO departments VALUES
    (1, 'Engineering'), (2, 'Marketing'),
    (3, 'Sales'), (4, 'HR');

-- Departments that have at least one employee
SELECT d.name
FROM departments d
WHERE EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);
-- Engineering
-- Marketing
-- Sales
</code></pre>
<h3 id="not-exists-find-departments-without-employees"><a class="header" href="#not-exists-find-departments-without-employees">NOT EXISTS: Find Departments without Employees</a></h3>
<pre><code class="language-sql">-- Departments with no employees assigned
SELECT d.name
FROM departments d
WHERE NOT EXISTS (
    SELECT 1 FROM employees e WHERE e.department_id = d.id
);
-- HR
</code></pre>
<h3 id="in-with-subquery"><a class="header" href="#in-with-subquery">IN with Subquery</a></h3>
<pre><code class="language-sql">-- Employees in the Engineering department
SELECT name
FROM employees
WHERE department_id IN (
    SELECT id FROM departments WHERE name = 'Engineering'
);
-- Alice
-- Bob
-- Eve
</code></pre>
<h3 id="not-in-with-subquery"><a class="header" href="#not-in-with-subquery">NOT IN with Subquery</a></h3>
<pre><code class="language-sql">-- Employees outside the Engineering department
SELECT name
FROM employees
WHERE department_id NOT IN (
    SELECT id FROM departments WHERE name = 'Engineering'
);
-- Carol
-- Dave
-- Frank
</code></pre>
<h3 id="correlated-subquery-look-up-related-data"><a class="header" href="#correlated-subquery-look-up-related-data">Correlated Subquery: Look Up Related Data</a></h3>
<pre><code class="language-sql">-- Show each employee with their department name
SELECT e.name, e.salary,
       (SELECT d.name FROM departments d WHERE d.id = e.department_id) AS dept_name
FROM employees e
ORDER BY e.salary DESC;
-- Eve   | 105000.0 | Engineering
-- Alice |  95000.0 | Engineering
-- Bob   |  88000.0 | Engineering
-- Carol |  72000.0 | Marketing
-- Frank |  71000.0 | Marketing
-- Dave  |  68000.0 | Sales
</code></pre>
<h3 id="correlated-subquery-compare-against-group-average"><a class="header" href="#correlated-subquery-compare-against-group-average">Correlated Subquery: Compare Against Group Average</a></h3>
<pre><code class="language-sql">-- Employees earning above their department's average salary
SELECT e.name, e.salary, e.department_id
FROM employees e
WHERE e.salary &gt; (
    SELECT AVG(e2.salary)
    FROM employees e2
    WHERE e2.department_id = e.department_id
);
-- Carol | 72000.0 | 2
-- Eve   | 105000.0 | 1
</code></pre>
<h3 id="correlated-subquery-with-count"><a class="header" href="#correlated-subquery-with-count">Correlated Subquery with COUNT</a></h3>
<pre><code class="language-sql">-- Count employees per department
SELECT d.name,
       (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.id) AS emp_count
FROM departments d;
-- Engineering | 3
-- Marketing   | 2
-- Sales       | 1
-- HR          | 0
</code></pre>
<h3 id="derived-table"><a class="header" href="#derived-table">Derived Table</a></h3>
<pre><code class="language-sql">-- Average salary per department using a derived table
SELECT dept_name, avg_salary
FROM (
    SELECT d.name AS dept_name, AVG(e.salary) AS avg_salary
    FROM departments d
    JOIN employees e ON d.id = e.department_id
    GROUP BY d.name
) AS dept_stats
ORDER BY avg_salary DESC;
-- Engineering | 96000.0
-- Marketing   | 71500.0
-- Sales       | 68000.0
</code></pre>
<h3 id="derived-table-joined-with-another-table"><a class="header" href="#derived-table-joined-with-another-table">Derived Table Joined with Another Table</a></h3>
<pre><code class="language-sql">-- Join a derived table of aggregate stats back to the departments table
SELECT c.name AS department, stats.emp_count, stats.avg_salary
FROM departments c
JOIN (
    SELECT department_id,
           COUNT(*) AS emp_count,
           AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id
) AS stats ON stats.department_id = c.id;
-- Engineering | 3 | 96000.0
-- Marketing   | 2 | 71500.0
-- Sales       | 1 | 68000.0
</code></pre>
<h3 id="combining-exists-and-in"><a class="header" href="#combining-exists-and-in">Combining EXISTS and IN</a></h3>
<pre><code class="language-sql">CREATE TABLE products (
    id INTEGER PRIMARY KEY, name TEXT,
    category_id INTEGER, price REAL
);
CREATE TABLE categories (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE reviews (id INTEGER PRIMARY KEY, product_id INTEGER, rating INTEGER);

INSERT INTO categories VALUES (1, 'Electronics'), (2, 'Clothing');
INSERT INTO products VALUES
    (1, 'Laptop', 1, 999.99),
    (2, 'T-Shirt', 2, 29.99),
    (3, 'Headphones', 1, 79.99);
INSERT INTO reviews VALUES (1, 1, 5), (2, 1, 4), (3, 3, 3);

-- Electronics with at least one review rated 4 or higher
SELECT p.name, p.price
FROM products p
WHERE EXISTS (
    SELECT 1 FROM reviews r
    WHERE r.product_id = p.id AND r.rating &gt;= 4
)
AND p.category_id IN (
    SELECT id FROM categories WHERE name = 'Electronics'
);
-- Laptop | 999.99
</code></pre>
<h2 id="compatibility-4"><a class="header" href="#compatibility-4">Compatibility</a></h2>
<p>Turso supports scalar subqueries used with comparison operators (e.g. <code>WHERE x &gt; (SELECT ...)</code>), but does not support row value subqueries such as <code>(x, y) = (SELECT a, b FROM ...)</code>. Only single-column subqueries are valid in comparison contexts.</p>
<p>Correlated subqueries in the <code>ORDER BY</code> clause are not yet supported. Uncorrelated subqueries in <code>ORDER BY</code> work as expected.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="common-table-expressions"><a class="header" href="#common-table-expressions">Common Table Expressions</a></h1>
<h2 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h2>
<pre><code class="language-sql">WITH cte-name [(column-name [, ...])] AS (select-stmt)
  [, cte-name [(column-name [, ...])] AS (select-stmt) [, ...]]
{SELECT | INSERT | UPDATE | DELETE} ...
</code></pre>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<p>A Common Table Expression (CTE) is a named temporary result set defined within a <code>WITH</code> clause. CTEs exist only for the duration of the statement they are attached to. They behave like temporary views: you define them once and can reference them by name in the main statement that follows.</p>
<p>CTEs make complex queries easier to read by breaking them into named, reusable pieces. Instead of deeply nested subqueries, you can define each logical step as a separate CTE and compose them together.</p>
<p>A single <code>WITH</code> clause can define multiple CTEs, separated by commas. Later CTEs in the list can reference earlier ones, allowing you to build up results incrementally.</p>
<h2 id="clauses-4"><a class="header" href="#clauses-4">Clauses</a></h2>
<h3 id="with"><a class="header" href="#with">WITH</a></h3>
<p>The <code>WITH</code> keyword introduces one or more CTE definitions. It must appear at the beginning of a top-level <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement.</p>
<pre><code class="language-sql">WITH cte-name AS (select-stmt)
</code></pre>
<p>Each CTE definition consists of:</p>
<ul>
<li><strong>cte-name</strong> – the name used to reference the CTE in the main statement. CTE names must be unique within a single <code>WITH</code> clause; duplicate names produce an error.</li>
<li><strong>select-stmt</strong> – a <code>SELECT</code> statement (including compound <code>SELECT</code> with <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, or <code>EXCEPT</code>) that defines the CTE’s contents.</li>
</ul>
<h3 id="column-names"><a class="header" href="#column-names">Column Names</a></h3>
<p>You can optionally specify explicit column names for the CTE by listing them in parentheses after the CTE name:</p>
<pre><code class="language-sql">WITH cte-name (column-name [, ...]) AS (select-stmt)
</code></pre>
<p>When column names are provided, they replace whatever column names the <code>select-stmt</code> would otherwise produce. This is useful when the CTE body contains expressions without natural names, or when you want to rename columns for clarity.</p>
<h3 id="multiple-ctes"><a class="header" href="#multiple-ctes">Multiple CTEs</a></h3>
<p>Multiple CTEs are separated by commas within a single <code>WITH</code> clause. Each subsequent CTE can reference any CTE defined before it:</p>
<pre><code class="language-sql">WITH
  first AS (select-stmt),
  second AS (select-stmt),   -- can reference 'first'
  third AS (select-stmt)     -- can reference 'first' and 'second'
SELECT ... FROM third;
</code></pre>
<h3 id="cte-body-with-compound-select"><a class="header" href="#cte-body-with-compound-select">CTE Body with Compound SELECT</a></h3>
<p>The <code>select-stmt</code> inside a CTE definition can be a compound <code>SELECT</code> using set operators:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>UNION</code></td><td>Combines results, removing duplicate rows</td></tr>
<tr><td><code>UNION ALL</code></td><td>Combines results, keeping all rows including duplicates</td></tr>
<tr><td><code>INTERSECT</code></td><td>Returns only rows present in both result sets</td></tr>
<tr><td><code>EXCEPT</code></td><td>Returns rows from the first result set that are not in the second</td></tr>
</tbody>
</table>
</div>
<p>The compound <code>SELECT</code> can also include <code>LIMIT</code> and <code>OFFSET</code> to restrict the CTE’s result set.</p>
<h2 id="using-ctes-with-different-statements"><a class="header" href="#using-ctes-with-different-statements">Using CTEs with Different Statements</a></h2>
<h3 id="with--select"><a class="header" href="#with--select">WITH … SELECT</a></h3>
<p>The most common use of CTEs. The main <code>SELECT</code> can reference any defined CTE by name in its <code>FROM</code> clause, in subqueries, or in <code>WHERE</code> clause conditions. A CTE can be referenced multiple times within the same statement.</p>
<pre><code class="language-sql">WITH cte AS (select-stmt)
SELECT ... FROM cte;
</code></pre>
<h3 id="with--insert"><a class="header" href="#with--insert">WITH … INSERT</a></h3>
<p>A <code>WITH</code> clause can precede an <code>INSERT</code> statement. The CTEs are visible in the <code>INSERT ... SELECT</code> source query, in scalar subqueries within a <code>VALUES</code> clause, and in <code>RETURNING</code> clause subqueries.</p>
<pre><code class="language-sql">WITH cte AS (select-stmt)
INSERT INTO table-name SELECT ... FROM cte;
</code></pre>
<h3 id="with--update"><a class="header" href="#with--update">WITH … UPDATE</a></h3>
<p>A <code>WITH</code> clause can precede an <code>UPDATE</code> statement. The CTEs are visible in the <code>WHERE</code> clause, <code>SET</code> expressions, and <code>RETURNING</code> clause of the <code>UPDATE</code>.</p>
<pre><code class="language-sql">WITH cte AS (select-stmt)
UPDATE table-name SET ... WHERE ... IN (SELECT ... FROM cte);
</code></pre>
<h3 id="with--delete"><a class="header" href="#with--delete">WITH … DELETE</a></h3>
<p>A <code>WITH</code> clause can precede a <code>DELETE</code> statement. The CTEs are visible in the <code>WHERE</code> clause and <code>RETURNING</code> clause of the <code>DELETE</code>.</p>
<pre><code class="language-sql">WITH cte AS (select-stmt)
DELETE FROM table-name WHERE ... IN (SELECT ... FROM cte);
</code></pre>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<h3 id="basic-cte"><a class="header" href="#basic-cte">Basic CTE</a></h3>
<pre><code class="language-sql">-- Define a simple CTE and select from it
WITH recent_cutoff AS (SELECT 30 AS days)
SELECT days FROM recent_cutoff;
-- 30
</code></pre>
<h3 id="cte-with-explicit-column-names"><a class="header" href="#cte-with-explicit-column-names">CTE with Explicit Column Names</a></h3>
<pre><code class="language-sql">-- Rename the CTE columns to 'sum' and 'product'
WITH calculations(sum, product) AS (SELECT 3 + 4, 3 * 4)
SELECT sum, product FROM calculations;
-- 7|12
</code></pre>
<h3 id="multiple-ctes-1"><a class="header" href="#multiple-ctes-1">Multiple CTEs</a></h3>
<pre><code class="language-sql">-- Chain CTEs: the second references the first
WITH
  base AS (SELECT 10 AS val),
  doubled AS (SELECT val * 2 AS val FROM base)
SELECT * FROM doubled;
-- 20
</code></pre>
<h3 id="long-cte-chain"><a class="header" href="#long-cte-chain">Long CTE Chain</a></h3>
<pre><code class="language-sql">-- Build a pipeline of CTEs, each referencing the previous one
WITH
  step1 AS (SELECT 1 AS x),
  step2 AS (SELECT x FROM step1),
  step3 AS (SELECT x FROM step2),
  step4 AS (SELECT x FROM step3)
SELECT * FROM step4;
-- 1
</code></pre>
<h3 id="cte-with-union"><a class="header" href="#cte-with-union">CTE with UNION</a></h3>
<pre><code class="language-sql">-- Combine two result sets, removing duplicates
WITH statuses AS (
  SELECT 'active' AS status
  UNION
  SELECT 'inactive'
  UNION
  SELECT 'pending'
)
SELECT * FROM statuses ORDER BY 1;
-- active
-- inactive
-- pending
</code></pre>
<h3 id="cte-with-union-all-and-aggregation"><a class="header" href="#cte-with-union-all-and-aggregation">CTE with UNION ALL and Aggregation</a></h3>
<pre><code class="language-sql">-- UNION ALL preserves all rows, enabling accurate counts
WITH all_scores AS (
  SELECT 1 AS score
  UNION ALL
  SELECT 2
  UNION ALL
  SELECT 3
)
SELECT COUNT(*) FROM all_scores;
-- 3
</code></pre>
<h3 id="cte-with-limit-and-offset"><a class="header" href="#cte-with-limit-and-offset">CTE with LIMIT and OFFSET</a></h3>
<pre><code class="language-sql">-- Restrict the CTE result set using LIMIT and OFFSET
WITH numbers AS (
  SELECT 1 UNION SELECT 2 UNION SELECT 3
  LIMIT 2 OFFSET 1
)
SELECT * FROM numbers ORDER BY 1;
-- 2
-- 3
</code></pre>
<h3 id="cte-referenced-multiple-times"><a class="header" href="#cte-referenced-multiple-times">CTE Referenced Multiple Times</a></h3>
<pre><code class="language-sql">-- Reference the same CTE twice to form a cross join
WITH codes AS (SELECT 1 AS x UNION SELECT 2)
SELECT * FROM codes AS a, codes AS b ORDER BY 1, 2;
-- 1|1
-- 1|2
-- 2|1
-- 2|2
</code></pre>
<h3 id="cte-visible-in-scalar-subqueries"><a class="header" href="#cte-visible-in-scalar-subqueries">CTE Visible in Scalar Subqueries</a></h3>
<pre><code class="language-sql">-- A CTE can be referenced inside scalar subqueries in the SELECT list
WITH constants AS (SELECT 10 AS x, 20 AS y)
SELECT (SELECT x FROM constants), (SELECT y FROM constants);
-- 10|20
</code></pre>
<h3 id="cte-with-insert"><a class="header" href="#cte-with-insert">CTE with INSERT</a></h3>
<pre><code class="language-sql">-- Use a CTE to supply rows for an INSERT ... SELECT
CREATE TABLE orders(amount);
WITH new_orders AS (
  SELECT 100 UNION SELECT 250 UNION SELECT 75
)
INSERT INTO orders SELECT * FROM new_orders;

SELECT * FROM orders ORDER BY 1;
-- 75
-- 100
-- 250
</code></pre>
<h3 id="cte-with-insert-and-returning"><a class="header" href="#cte-with-insert-and-returning">CTE with INSERT and RETURNING</a></h3>
<pre><code class="language-sql">-- CTEs work with the RETURNING clause
CREATE TABLE items(name TEXT);
WITH new_items AS (SELECT 'widget' AS name)
INSERT INTO items SELECT * FROM new_items RETURNING name;
-- widget
</code></pre>
<h3 id="cte-with-insert-values-subquery"><a class="header" href="#cte-with-insert-values-subquery">CTE with INSERT VALUES Subquery</a></h3>
<pre><code class="language-sql">-- Reference a CTE inside a VALUES clause via scalar subquery
CREATE TABLE settings(key TEXT, value INT);
WITH defaults AS (SELECT 99 AS x)
INSERT INTO settings VALUES ('threshold', (SELECT x FROM defaults));

SELECT * FROM settings;
-- threshold|99
</code></pre>
<h3 id="cte-with-update"><a class="header" href="#cte-with-update">CTE with UPDATE</a></h3>
<pre><code class="language-sql">-- Use a CTE to identify rows to update
CREATE TABLE products(id INTEGER, price REAL);
INSERT INTO products VALUES (1, 10.0), (2, 20.0), (3, 30.0);

WITH expensive AS (SELECT id FROM products WHERE price &gt; 15.0)
UPDATE products SET price = price * 0.9
WHERE id IN (SELECT id FROM expensive);

SELECT * FROM products ORDER BY id;
-- 1|10.0
-- 2|18.0
-- 3|27.0
</code></pre>
<h3 id="cte-with-delete"><a class="header" href="#cte-with-delete">CTE with DELETE</a></h3>
<pre><code class="language-sql">-- Use a CTE to identify rows to delete
CREATE TABLE tasks(id INTEGER, status TEXT);
INSERT INTO tasks VALUES (1, 'done'), (2, 'pending'), (3, 'done');

WITH completed AS (SELECT id FROM tasks WHERE status = 'done')
DELETE FROM tasks WHERE id IN (SELECT id FROM completed);

SELECT * FROM tasks;
-- 2|pending
</code></pre>
<h3 id="cte-with-multiple-ctes-in-delete"><a class="header" href="#cte-with-multiple-ctes-in-delete">CTE with Multiple CTEs in DELETE</a></h3>
<pre><code class="language-sql">-- Combine multiple CTEs to build complex conditions
CREATE TABLE inventory(id INTEGER);
INSERT INTO inventory VALUES (1),(2),(3),(4),(5);

WITH
  low AS (SELECT 1 UNION SELECT 2),
  high AS (SELECT 4 UNION SELECT 5)
DELETE FROM inventory
WHERE id IN (SELECT * FROM low) OR id IN (SELECT * FROM high);

SELECT * FROM inventory;
-- 3
</code></pre>
<h3 id="cte-feeding-another-cte-for-insert"><a class="header" href="#cte-feeding-another-cte-for-insert">CTE Feeding Another CTE for INSERT</a></h3>
<pre><code class="language-sql">-- Chain CTEs: the first provides base data, the second transforms it
CREATE TABLE results(value INTEGER);
WITH
  base AS (SELECT 1 AS x),
  transformed AS (SELECT x + 10 FROM base)
INSERT INTO results SELECT * FROM transformed;

SELECT * FROM results;
-- 11
</code></pre>
<h3 id="cte-visible-in-returning-subqueries"><a class="header" href="#cte-visible-in-returning-subqueries">CTE Visible in RETURNING Subqueries</a></h3>
<pre><code class="language-sql">-- Reference a CTE inside the RETURNING clause
CREATE TABLE logs(entry TEXT);
INSERT INTO logs VALUES ('old_entry');

WITH marker AS (SELECT 99 AS code)
DELETE FROM logs WHERE entry = 'old_entry'
RETURNING (SELECT code FROM marker);
-- 99
</code></pre>
<h2 id="compatibility-5"><a class="header" href="#compatibility-5">Compatibility</a></h2>
<p>Turso supports the <code>WITH</code> clause with the following limitations compared to SQLite:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Ordinary CTEs</td><td>Supported</td></tr>
<tr><td>Multiple CTEs in one <code>WITH</code> clause</td><td>Supported</td></tr>
<tr><td>CTE with <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code></td><td>Supported</td></tr>
<tr><td>Explicit CTE column names</td><td>Supported</td></tr>
<tr><td>Compound <code>SELECT</code> in CTE body (<code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, <code>EXCEPT</code>)</td><td>Supported</td></tr>
<tr><td><code>RECURSIVE</code> CTEs</td><td>Not supported</td></tr>
<tr><td><code>MATERIALIZED</code> / <code>NOT MATERIALIZED</code> hints</td><td>Not supported</td></tr>
<tr><td>Non-<code>SELECT</code> statements in CTE body (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> inside the CTE definition)</td><td>Not supported</td></tr>
</tbody>
</table>
</div>
<p>Only <code>SELECT</code> statements (including compound <code>SELECT</code>) are allowed in the CTE body. The main statement that follows the <code>WITH</code> clause can be <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="insert"><a class="header" href="#insert">INSERT</a></h1>
<h2 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h2>
<pre><code class="language-sql">{INSERT | REPLACE} [OR {ROLLBACK | ABORT | FAIL | IGNORE | REPLACE}]
  INTO table-name [AS alias] [(column-name [, ...])]
  {VALUES (expr [, ...]) [, ...] | SELECT ... | DEFAULT VALUES}
  [RETURNING expr [AS alias] [, ...]]
</code></pre>
<h2 id="description-7"><a class="header" href="#description-7">Description</a></h2>
<p>The INSERT statement creates new rows in an existing table. There are three
forms: INSERT … VALUES inserts one or more explicitly specified rows,
INSERT … SELECT inserts rows produced by a query, and INSERT … DEFAULT
VALUES inserts a single row where every column takes its default value.</p>
<p>The keyword <code>REPLACE</code> is shorthand for <code>INSERT OR REPLACE</code>. When a constraint
violation occurs, <code>REPLACE</code> deletes the conflicting row and inserts the new
one.</p>
<h2 id="clauses-5"><a class="header" href="#clauses-5">Clauses</a></h2>
<h3 id="column-list"><a class="header" href="#column-list">Column List</a></h3>
<p>An optional parenthesized list of column names may appear after the table name.
When provided, the number of values in each VALUES row (or columns in the
SELECT result) must match the number of listed columns. Columns not named in
the list receive their default value, or NULL if no default is defined.</p>
<p>When the column list is omitted, the number of values must match the total
number of columns in the table, and values are assigned left-to-right.</p>
<pre><code class="language-sql">-- With column list: unlisted columns get defaults
INSERT INTO products (name, price) VALUES ('Widget', 9.99);

-- Without column list: must supply every column
INSERT INTO products VALUES (1, 'Widget', 9.99, 1);
</code></pre>
<h3 id="values"><a class="header" href="#values">VALUES</a></h3>
<p>The VALUES clause provides one or more rows of literal expressions. Multiple
rows are separated by commas.</p>
<pre><code class="language-sql">-- Single row
INSERT INTO products (name, price) VALUES ('Widget', 9.99);

-- Multiple rows
INSERT INTO products (name, price)
  VALUES ('Widget', 9.99), ('Gadget', 24.95), ('Gizmo', 4.50);
</code></pre>
<h3 id="select-1"><a class="header" href="#select-1">SELECT</a></h3>
<p>A SELECT statement may be used instead of VALUES to insert rows produced by a
query. Any valid SELECT is allowed, including compound SELECTs (UNION, UNION
ALL, INTERSECT, EXCEPT) and SELECTs with ORDER BY or LIMIT.</p>
<p>If a column list is specified, the number of columns in the SELECT result must
match the number of listed columns. Otherwise it must match the total number
of columns in the target table.</p>
<pre><code class="language-sql">CREATE TABLE products_archive (id INTEGER PRIMARY KEY, name TEXT, price REAL);
INSERT INTO products_archive SELECT id, name, price FROM products WHERE in_stock = 0;
</code></pre>
<h3 id="default-values"><a class="header" href="#default-values">DEFAULT VALUES</a></h3>
<p>The DEFAULT VALUES form inserts exactly one row. Every column receives its
default value as specified in the CREATE TABLE statement, or NULL if no default
was defined.</p>
<pre><code class="language-sql">CREATE TABLE logs (id INTEGER PRIMARY KEY, created_at TEXT DEFAULT 'now', msg TEXT DEFAULT 'empty');
INSERT INTO logs DEFAULT VALUES;
-- Result: id=1, created_at='now', msg='empty'
</code></pre>
<h3 id="or-conflict-algorithm"><a class="header" href="#or-conflict-algorithm">OR Conflict Algorithm</a></h3>
<p>By prefixing the INSERT with <code>OR algorithm</code>, you can control what happens when
the insertion would violate a constraint (UNIQUE, NOT NULL, CHECK, or PRIMARY
KEY). The keyword appears between <code>INSERT</code> and <code>INTO</code>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Algorithm</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>ABORT</td><td>Abort the current statement and roll back any changes it made. This is the default behavior when no algorithm is specified.</td></tr>
<tr><td>ROLLBACK</td><td>Abort the current statement and roll back the entire enclosing transaction.</td></tr>
<tr><td>FAIL</td><td>Abort the current statement but keep changes made by earlier rows within the same statement.</td></tr>
<tr><td>IGNORE</td><td>Skip the row that caused the violation and continue processing remaining rows.</td></tr>
<tr><td>REPLACE</td><td>Delete the existing row that caused the conflict, then insert the new row. If the conflicting column has a NOT NULL constraint with a DEFAULT value, the default is used when NULL is supplied. If there is no default, the statement fails.</td></tr>
</tbody>
</table>
</div>
<p>Foreign key constraint violations are <strong>not</strong> affected by the conflict
algorithm. They always behave like ABORT regardless of which algorithm is
specified.</p>
<pre><code class="language-sql">-- IGNORE: silently skip rows that violate constraints
CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com');
INSERT OR IGNORE INTO users VALUES (2, 'alice@example.com');
-- The second row is silently skipped; the table still contains only row 1.

-- REPLACE: delete the conflicting row and insert the new one
INSERT OR REPLACE INTO users VALUES (2, 'alice@example.com');
-- Row 1 is deleted, row 2 with the same email is inserted.
</code></pre>
<p>The <code>REPLACE</code> keyword (without <code>INSERT OR</code>) is equivalent to
<code>INSERT OR REPLACE</code>:</p>
<pre><code class="language-sql">REPLACE INTO users VALUES (3, 'alice@example.com');
</code></pre>
<h3 id="returning"><a class="header" href="#returning">RETURNING</a></h3>
<p>The RETURNING clause causes the INSERT statement to return values from each
inserted row, much like a SELECT. It accepts a list of expressions that may
reference columns of the inserted row, use functions, or contain arbitrary
expressions. Use <code>*</code> to return all columns.</p>
<pre><code class="language-sql">CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, qty INTEGER);
INSERT INTO orders (product, qty) VALUES ('Widget', 5) RETURNING *;
-- Returns: 1|Widget|5

INSERT INTO orders (product, qty)
  VALUES ('Gadget', 3), ('Gizmo', 12)
  RETURNING id, product;
-- Returns:
-- 2|Gadget
-- 3|Gizmo
</code></pre>
<p>RETURNING expressions can include functions and computed values:</p>
<pre><code class="language-sql">CREATE TABLE line_items (id INTEGER PRIMARY KEY, product TEXT, qty INTEGER, unit_price REAL);
INSERT INTO line_items (product, qty, unit_price)
  VALUES ('Widget', 5, 9.99)
  RETURNING id, product, qty * unit_price AS total;
-- Returns: 1|Widget|49.95
</code></pre>
<p>For full details on the RETURNING clause, see <a href="#returning-3">RETURNING</a>.</p>
<h3 id="table-alias"><a class="header" href="#table-alias">Table Alias</a></h3>
<p>The optional <code>AS alias</code> after the table name provides an alternative name for
the table. This alias is primarily useful with the UPSERT clause (ON CONFLICT
… DO UPDATE), which is documented separately.</p>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<pre><code class="language-sql">-- Create a sample table
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  department TEXT,
  salary REAL DEFAULT 50000.00
);
</code></pre>
<pre><code class="language-sql">-- Insert a single row, specifying all columns
INSERT INTO employees VALUES (1, 'Alice Johnson', 'Engineering', 95000.00);
</code></pre>
<pre><code class="language-sql">-- Insert with a column list; salary gets its default value
INSERT INTO employees (id, name, department)
  VALUES (2, 'Bob Smith', 'Marketing');
</code></pre>
<pre><code class="language-sql">-- Insert multiple rows at once
INSERT INTO employees (name, department, salary) VALUES
  ('Carol White', 'Engineering', 105000.00),
  ('David Brown', 'Sales', 72000.00),
  ('Eve Davis', 'Marketing', 68000.00);
</code></pre>
<pre><code class="language-sql">-- Insert from a SELECT: copy all engineers into a new table
CREATE TABLE engineers (id INTEGER PRIMARY KEY, name TEXT, salary REAL);
INSERT INTO engineers
  SELECT id, name, salary FROM employees WHERE department = 'Engineering';
</code></pre>
<pre><code class="language-sql">-- Insert from a compound SELECT
CREATE TABLE all_names (name TEXT);
INSERT INTO all_names
  SELECT name FROM employees
  UNION ALL
  SELECT name FROM engineers;
</code></pre>
<pre><code class="language-sql">-- Insert a single row with all defaults
CREATE TABLE events (id INTEGER PRIMARY KEY, description TEXT DEFAULT 'unknown');
INSERT INTO events DEFAULT VALUES;
-- Result: id=1, description='unknown'
</code></pre>
<pre><code class="language-sql">-- INSERT OR IGNORE: skip rows that would violate a UNIQUE constraint
CREATE TABLE tags (id INTEGER PRIMARY KEY, label TEXT UNIQUE);
INSERT INTO tags (label) VALUES ('urgent'), ('review'), ('done');
INSERT OR IGNORE INTO tags (label) VALUES ('urgent'), ('new'), ('done');
-- Only 'new' is inserted; 'urgent' and 'done' are skipped.
SELECT label FROM tags ORDER BY label;
-- done
-- new
-- review
-- urgent
</code></pre>
<pre><code class="language-sql">-- INSERT OR REPLACE: replace the conflicting row
CREATE TABLE settings (key TEXT PRIMARY KEY, value TEXT);
INSERT INTO settings VALUES ('theme', 'light');
INSERT OR REPLACE INTO settings VALUES ('theme', 'dark');
SELECT * FROM settings;
-- theme|dark
</code></pre>
<pre><code class="language-sql">-- REPLACE shorthand (equivalent to INSERT OR REPLACE)
REPLACE INTO settings VALUES ('theme', 'solarized');
</code></pre>
<pre><code class="language-sql">-- INSERT with RETURNING to get generated IDs
CREATE TABLE tickets (id INTEGER PRIMARY KEY, title TEXT, priority INTEGER);
INSERT INTO tickets (title, priority)
  VALUES ('Fix login bug', 1), ('Update docs', 3)
  RETURNING id, title;
-- 1|Fix login bug
-- 2|Update docs
</code></pre>
<pre><code class="language-sql">-- INSERT ... SELECT with RETURNING
CREATE TABLE source (name TEXT, amount INTEGER);
INSERT INTO source VALUES ('Alice', 10), ('Bob', 20);
CREATE TABLE totals (name TEXT, amount INTEGER);
INSERT INTO totals SELECT * FROM source RETURNING *;
-- Alice|10
-- Bob|20
</code></pre>
<pre><code class="language-sql">-- INSERT OR IGNORE with RETURNING: only inserted rows are returned
CREATE TABLE codes (id INTEGER PRIMARY KEY, code TEXT UNIQUE);
INSERT INTO codes (code) VALUES ('A');
INSERT OR IGNORE INTO codes (code) VALUES ('A'), ('B') RETURNING id, code;
-- 2|B
-- (The duplicate 'A' is skipped and does not appear in the output.)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="upsert-on-conflict"><a class="header" href="#upsert-on-conflict">UPSERT (ON CONFLICT)</a></h1>
<h2 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h2>
<pre><code class="language-sql">INSERT [OR {ROLLBACK | ABORT | FAIL | IGNORE | REPLACE}]
  INTO table-name [(column-name [, ...])]
  {VALUES (expr [, ...]) [, ...] | select-stmt}
  [ON CONFLICT [(column-name [, ...]) [WHERE expr]]
    {DO NOTHING | DO UPDATE SET assignment [, ...] [WHERE expr]}
  ] [, ...]
</code></pre>
<p>Where each <code>assignment</code> is:</p>
<pre><code class="language-sql">column-name = expr
</code></pre>
<p>or:</p>
<pre><code class="language-sql">(column-name [, ...]) = (expr [, ...])
</code></pre>
<h2 id="description-8"><a class="header" href="#description-8">Description</a></h2>
<p>UPSERT is not a standalone statement. It is an optional clause that can be appended to an <code>INSERT</code> statement to control what happens when the insertion would violate a uniqueness constraint (a <code>UNIQUE</code> column, a <code>UNIQUE</code> index, or a <code>PRIMARY KEY</code>). Without an UPSERT clause, a uniqueness violation causes the statement to fail with an error.</p>
<p>An UPSERT clause begins with <code>ON CONFLICT</code> and specifies one of two actions: <code>DO NOTHING</code>, which silently skips the conflicting row, or <code>DO UPDATE SET</code>, which converts the insert into an update of the existing row. This gives you an atomic “insert or update” operation in a single statement, eliminating the need for separate existence checks.</p>
<p>Turso follows the PostgreSQL-style UPSERT syntax. UPSERT only applies to uniqueness constraints. It does not intercept <code>NOT NULL</code>, <code>CHECK</code>, or foreign key violations – those always produce an error regardless of any <code>ON CONFLICT</code> clause.</p>
<h2 id="clauses-6"><a class="header" href="#clauses-6">Clauses</a></h2>
<h3 id="conflict-target"><a class="header" href="#conflict-target">Conflict Target</a></h3>
<p>The conflict target appears between <code>ON CONFLICT</code> and <code>DO</code>. It specifies which uniqueness constraint should trigger the upsert behavior.</p>
<pre><code class="language-sql">ON CONFLICT (column-name [, ...]) [WHERE expr] DO ...
</code></pre>
<p>The column list must exactly match the columns of a <code>UNIQUE</code> index or <code>PRIMARY KEY</code>. For a composite unique index, all columns must be listed, though the order does not matter.</p>
<pre><code class="language-sql">-- Matches a UNIQUE index on (a, b), regardless of column order
ON CONFLICT (b, a) DO UPDATE SET ...
</code></pre>
<p>The conflict target is optional on the last (or only) <code>ON CONFLICT</code> clause. When omitted, the clause matches any uniqueness constraint violation that has not already been handled by a preceding <code>ON CONFLICT</code> clause.</p>
<pre><code class="language-sql">-- Omitted target: matches any uniqueness violation
ON CONFLICT DO NOTHING
</code></pre>
<p>If a conflict target includes a <code>WHERE</code> clause, it becomes a partial conflict target. The <code>WHERE</code> expression restricts which rows of a partial unique index are considered when matching. This is relevant when the unique index itself was created with a <code>WHERE</code> clause.</p>
<h3 id="do-nothing"><a class="header" href="#do-nothing">DO NOTHING</a></h3>
<pre><code class="language-sql">ON CONFLICT [(conflict-target)] DO NOTHING
</code></pre>
<p>When a uniqueness constraint is violated, the conflicting row is silently skipped. No insert or update occurs for that row. If the <code>INSERT</code> statement includes a <code>RETURNING</code> clause, skipped rows produce no output.</p>
<h3 id="do-update-set"><a class="header" href="#do-update-set">DO UPDATE SET</a></h3>
<pre><code class="language-sql">ON CONFLICT [(conflict-target)] DO UPDATE SET assignment [, ...] [WHERE expr]
</code></pre>
<p>When a uniqueness constraint is violated, Turso updates the existing row instead of inserting a new one. The <code>SET</code> clause works the same as in a regular <code>UPDATE</code> statement. You can set individual columns or use the tuple form to set multiple columns at once:</p>
<pre><code class="language-sql">-- Individual assignments
DO UPDATE SET price = excluded.price, quantity = excluded.quantity

-- Tuple assignment
DO UPDATE SET (price, quantity) = (excluded.price, excluded.quantity)
</code></pre>
<p>Within the <code>SET</code> clause and its optional <code>WHERE</code> clause, column references that are unqualified or qualified with the target table name refer to the existing row (before the update). To reference the values that were proposed for insertion, use the special <code>excluded</code> table qualifier.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Reference</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>column-name</code></td><td>Value in the existing row</td></tr>
<tr><td><code>table-name.column-name</code></td><td>Value in the existing row (explicit)</td></tr>
<tr><td><code>excluded.column-name</code></td><td>Value from the attempted <code>INSERT</code></td></tr>
</tbody>
</table>
</div>
<p>The <code>DO UPDATE</code> clause always uses <code>ABORT</code> conflict resolution internally. If the update itself causes a constraint violation (for example, setting a column to a value that duplicates another row’s unique key), the entire <code>INSERT</code> statement is rolled back.</p>
<h3 id="where-on-do-update"><a class="header" href="#where-on-do-update">WHERE on DO UPDATE</a></h3>
<p>An optional <code>WHERE</code> clause after <code>DO UPDATE SET</code> controls whether the update actually takes effect. If the condition evaluates to false or NULL, the update is skipped for that row, effectively making the clause behave like <code>DO NOTHING</code> for that particular conflict.</p>
<pre><code class="language-sql">ON CONFLICT (name) DO UPDATE SET
  phonenumber = excluded.phonenumber,
  valid_date = excluded.valid_date
WHERE excluded.valid_date &gt; table-name.valid_date
</code></pre>
<p>This is useful for “only update if the new data is newer” patterns, or for conditional merges.</p>
<h3 id="multiple-on-conflict-clauses"><a class="header" href="#multiple-on-conflict-clauses">Multiple ON CONFLICT Clauses</a></h3>
<p>An <code>INSERT</code> statement may include more than one <code>ON CONFLICT</code> clause. Turso evaluates them in order. When a uniqueness violation occurs, the first clause whose conflict target matches the violated constraint is used. Only one clause executes per conflicting row.</p>
<p>Every <code>ON CONFLICT</code> clause except the last one must include a conflict target. The last clause may omit the conflict target to serve as a catch-all for any remaining uniqueness violations.</p>
<pre><code class="language-sql">INSERT INTO table-name (...)
  VALUES (...)
  ON CONFLICT (x) DO UPDATE SET ...   -- handles conflicts on x
  ON CONFLICT (y) DO UPDATE SET ...   -- handles conflicts on y
  ON CONFLICT DO NOTHING;             -- catch-all for any other uniqueness violation
</code></pre>
<h3 id="multi-row-inserts"><a class="header" href="#multi-row-inserts">Multi-Row Inserts</a></h3>
<p>When an <code>INSERT</code> provides multiple rows (either through multiple <code>VALUES</code> rows or a <code>SELECT</code> subquery), the upsert decision is made independently for each row. Some rows may be inserted normally, while others trigger <code>DO UPDATE</code> or <code>DO NOTHING</code>.</p>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<pre><code class="language-sql">-- Create a table with a unique constraint
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT UNIQUE,
  price REAL,
  quantity INTEGER
);

INSERT INTO products VALUES (1, 'Widget', 9.99, 100);
</code></pre>
<pre><code class="language-sql">-- DO NOTHING: silently skip if the name already exists
INSERT INTO products VALUES (2, 'Widget', 12.99, 200)
  ON CONFLICT DO NOTHING;

SELECT * FROM products;
-- 1|Widget|9.99|100
</code></pre>
<pre><code class="language-sql">-- DO UPDATE: update price and quantity when name conflicts
INSERT INTO products VALUES (1, 'Widget', 12.99, 200)
  ON CONFLICT(name) DO UPDATE SET
    price = excluded.price,
    quantity = excluded.quantity;

SELECT * FROM products;
-- 1|Widget|12.99|200
</code></pre>
<pre><code class="language-sql">-- Mix existing row values with excluded values
CREATE TABLE counters (key TEXT UNIQUE, hits INTEGER, last_seen TEXT);
INSERT INTO counters VALUES ('page_home', 1, '2024-01-01');

-- Increment hits while updating last_seen from the new row
INSERT INTO counters VALUES ('page_home', 1, '2024-06-15')
  ON CONFLICT(key) DO UPDATE SET
    hits = hits + 1,
    last_seen = excluded.last_seen;

SELECT * FROM counters;
-- page_home|2|2024-06-15
</code></pre>
<pre><code class="language-sql">-- Conditional update: only apply if the new value is greater
CREATE TABLE high_scores (player TEXT UNIQUE, score INTEGER);
INSERT INTO high_scores VALUES ('Alice', 5);

INSERT INTO high_scores VALUES ('Alice', 3)
  ON CONFLICT(player) DO UPDATE SET score = excluded.score
  WHERE excluded.score &gt; score;

SELECT * FROM high_scores;
-- Alice|5  (unchanged because 3 is not greater than 5)

INSERT INTO high_scores VALUES ('Alice', 10)
  ON CONFLICT(player) DO UPDATE SET score = excluded.score
  WHERE excluded.score &gt; score;

SELECT * FROM high_scores;
-- Alice|10  (updated because 10 &gt; 5)
</code></pre>
<pre><code class="language-sql">-- Multi-row insert with upsert: each row handled independently
CREATE TABLE inventory (sku TEXT UNIQUE, name TEXT);
INSERT INTO inventory VALUES ('A001', 'Original');

INSERT INTO inventory VALUES ('A001', 'Updated'), ('B002', 'New Item')
  ON CONFLICT(sku) DO UPDATE SET name = excluded.name;

SELECT * FROM inventory ORDER BY sku;
-- A001|Updated
-- B002|New Item
</code></pre>
<pre><code class="language-sql">-- Multiple ON CONFLICT clauses with different targets
CREATE TABLE records (
  id INTEGER PRIMARY KEY,
  code TEXT UNIQUE,
  email TEXT UNIQUE,
  note TEXT DEFAULT NULL
);

INSERT INTO records VALUES (1, 'x', 'a@test.com', 'original');
INSERT INTO records VALUES (2, 'y', 'b@test.com', 'original');

INSERT INTO records VALUES (3, 'x', 'c@test.com', 'new')
  ON CONFLICT(code) DO UPDATE SET note = 'code-conflict'
  ON CONFLICT(email) DO UPDATE SET note = 'email-conflict'
  ON CONFLICT DO UPDATE SET note = 'other-conflict';

SELECT * FROM records ORDER BY id;
-- 1|x|a@test.com|code-conflict
-- 2|y|b@test.com|original
</code></pre>
<pre><code class="language-sql">-- Upsert with RETURNING clause
CREATE TABLE settings (key TEXT PRIMARY KEY, value TEXT);
INSERT INTO settings VALUES ('theme', 'light');

INSERT INTO settings VALUES ('theme', 'dark')
  ON CONFLICT DO UPDATE SET value = excluded.value
  RETURNING key, value;
-- theme|dark
</code></pre>
<pre><code class="language-sql">-- DO NOTHING with RETURNING produces no output for skipped rows
CREATE TABLE tags (name TEXT PRIMARY KEY);
INSERT INTO tags VALUES ('important');

INSERT INTO tags VALUES ('important')
  ON CONFLICT DO NOTHING
  RETURNING name;
-- (no output)
</code></pre>
<pre><code class="language-sql">-- Composite unique index: target must list all columns
CREATE TABLE assignments (project TEXT, employee TEXT, role TEXT);
CREATE UNIQUE INDEX assignments_pk ON assignments(project, employee);

INSERT INTO assignments VALUES ('Atlas', 'Alice', 'Lead');

-- Column order in the target does not need to match the index
INSERT INTO assignments VALUES ('Atlas', 'Alice', 'Manager')
  ON CONFLICT(employee, project) DO UPDATE SET role = excluded.role;

SELECT * FROM assignments;
-- Atlas|Alice|Manager
</code></pre>
<pre><code class="language-sql">-- Using the table-qualified name in the conflict target
CREATE TABLE metrics (sensor_id INTEGER UNIQUE, reading REAL);
INSERT INTO metrics VALUES (1, 23.5);

INSERT INTO metrics VALUES (1, 25.0)
  ON CONFLICT(metrics.sensor_id) DO UPDATE SET
    reading = metrics.reading + excluded.reading;

SELECT * FROM metrics;
-- 1|48.5
</code></pre>
<h2 id="compatibility-6"><a class="header" href="#compatibility-6">Compatibility</a></h2>
<p>UPSERT is fully supported in Turso. The syntax and behavior match SQLite, including support for multiple <code>ON CONFLICT</code> clauses, the <code>excluded</code> table, conditional <code>WHERE</code> clauses on <code>DO UPDATE</code>, composite conflict targets, and tuple-form <code>SET</code> assignments.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="update"><a class="header" href="#update">UPDATE</a></h1>
<h2 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h2>
<pre><code class="language-sql">UPDATE [OR {ROLLBACK | ABORT | FAIL | IGNORE | REPLACE}]
  table-name [AS alias]
  SET {column-name = expr | (column-name [, ...]) = (expr [, ...])} [, ...]
  [WHERE expr]
  [RETURNING expr [AS alias] [, ...]]
  [LIMIT expr [OFFSET expr]]
</code></pre>
<h2 id="description-9"><a class="header" href="#description-9">Description</a></h2>
<p>The UPDATE statement modifies the values of columns in zero or more rows of an
existing table. Each SET clause assigns a new value to a column. If no WHERE
clause is provided, every row in the table is updated. When a WHERE clause is
present, only rows for which the expression evaluates to true are modified.</p>
<p>It is not an error if the WHERE clause matches zero rows. The statement
completes successfully and modifies nothing.</p>
<p>All expressions on the right-hand side of SET assignments are evaluated before
any assignments are made. This means SET expressions can safely reference the
current (pre-update) values of any column in the same row, including columns
that appear on the left-hand side of another assignment in the same statement.</p>
<h2 id="clauses-7"><a class="header" href="#clauses-7">Clauses</a></h2>
<h3 id="set"><a class="header" href="#set">SET</a></h3>
<p>The SET clause specifies one or more column assignments. Each assignment is
either a single column name paired with an expression, or a parenthesized list
of column names paired with a matching parenthesized list of expressions (row
value syntax).</p>
<pre><code class="language-sql">-- Single column assignment
UPDATE products SET price = 19.99 WHERE id = 1;

-- Multiple column assignments
UPDATE products SET price = 19.99, in_stock = 1 WHERE id = 1;

-- Row value syntax (equivalent to individual assignments)
UPDATE products SET (price, in_stock) = (19.99, 1) WHERE id = 1;
</code></pre>
<p>Columns not mentioned in the SET clause retain their existing values. If a
column name appears more than once in the SET clause, all but the rightmost
occurrence are ignored.</p>
<h3 id="where-1"><a class="header" href="#where-1">WHERE</a></h3>
<p>The WHERE clause limits which rows are updated. Only rows for which the
expression evaluates to true are affected. The expression can be any valid SQL
expression, including subqueries.</p>
<pre><code class="language-sql">-- Update rows matching a condition
UPDATE orders SET status = 'shipped' WHERE status = 'pending';

-- Update using a subquery in WHERE
UPDATE orders SET status = 'priority'
  WHERE customer_id IN (SELECT id FROM customers WHERE tier = 'gold');
</code></pre>
<h3 id="or-conflict-algorithm-1"><a class="header" href="#or-conflict-algorithm-1">OR Conflict Algorithm</a></h3>
<p>By prefixing the UPDATE with <code>OR algorithm</code>, you can control what happens when
an updated value would violate a constraint (UNIQUE, NOT NULL, CHECK, or
PRIMARY KEY). The keyword appears between <code>UPDATE</code> and the table name.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Algorithm</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>ABORT</td><td>Abort the current statement and roll back any changes it made. This is the default behavior when no algorithm is specified.</td></tr>
<tr><td>ROLLBACK</td><td>Abort the current statement and roll back the entire enclosing transaction.</td></tr>
<tr><td>FAIL</td><td>Abort the current statement but keep changes already made to earlier rows within the same statement.</td></tr>
<tr><td>IGNORE</td><td>Skip the row that caused the violation and continue processing remaining rows.</td></tr>
<tr><td>REPLACE</td><td>Delete the existing row that conflicts with the updated value, then apply the update. If the conflicting column has a NOT NULL constraint with a DEFAULT value, the default is used when NULL is supplied. If there is no default, the statement fails.</td></tr>
</tbody>
</table>
</div>
<p>Foreign key constraint violations are <strong>not</strong> affected by the conflict
algorithm. They always behave like ABORT regardless of which algorithm is
specified.</p>
<pre><code class="language-sql">-- IGNORE: skip updates that would violate a UNIQUE constraint
CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT UNIQUE);
INSERT INTO users VALUES (1, 'alice@example.com'), (2, 'bob@example.com');
UPDATE OR IGNORE users SET email = 'alice@example.com' WHERE id = 2;
-- Row 2 is unchanged because the update would violate the UNIQUE constraint.

-- REPLACE: delete the conflicting row, then apply the update
UPDATE OR REPLACE users SET email = 'alice@example.com' WHERE id = 2;
-- Row 1 is deleted, row 2 now has email 'alice@example.com'.
</code></pre>
<h3 id="returning-1"><a class="header" href="#returning-1">RETURNING</a></h3>
<p>The RETURNING clause causes the UPDATE statement to return values from each
modified row, much like a SELECT. It accepts a list of expressions that may
reference columns of the updated row (with their new, post-update values), use
functions, or contain arbitrary expressions. Use <code>*</code> to return all columns.</p>
<pre><code class="language-sql">UPDATE employees SET salary = salary * 1.10 WHERE department = 'Engineering'
  RETURNING id, name, salary;
</code></pre>
<p>For full details on the RETURNING clause, see <a href="#returning-3">RETURNING</a>.</p>
<h3 id="limit-and-offset"><a class="header" href="#limit-and-offset">LIMIT and OFFSET</a></h3>
<p>The LIMIT clause restricts the maximum number of rows that the UPDATE
modifies. A negative value for LIMIT means no limit. When OFFSET is specified,
the first N rows that would otherwise be updated are skipped.</p>
<p>Note that without ORDER BY (which Turso does not currently support for UPDATE),
the order in which rows are considered is arbitrary. Therefore, LIMIT and
OFFSET choose from an unpredictable set of qualifying rows.</p>
<pre><code class="language-sql">-- Update at most 1 row
UPDATE products SET featured = 1 WHERE category = 'electronics' LIMIT 1;

-- Update 2 rows, skipping the first 3
UPDATE logs SET archived = 1 LIMIT 2 OFFSET 3;
</code></pre>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<pre><code class="language-sql">-- Update a single row
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT, salary REAL);
INSERT INTO employees VALUES
  (1, 'Alice', 'Engineering', 85000.0),
  (2, 'Bob', 'Marketing', 72000.0),
  (3, 'Charlie', 'Engineering', 92000.0);
UPDATE employees SET salary = 90000.0 WHERE id = 1;
SELECT * FROM employees WHERE id = 1;
-- 1|Alice|Engineering|90000.0
</code></pre>
<pre><code class="language-sql">-- Update multiple columns at once
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT, salary REAL);
INSERT INTO employees VALUES (2, 'Bob', 'Marketing', 72000.0);
UPDATE employees SET department = 'Sales', salary = 78000.0 WHERE id = 2;
SELECT * FROM employees WHERE id = 2;
-- 2|Bob|Sales|78000.0
</code></pre>
<pre><code class="language-sql">-- Update all rows using an expression that references the current value
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, salary REAL);
INSERT INTO employees VALUES (1, 'Alice', 100.0), (2, 'Bob', 200.0), (3, 'Charlie', 300.0);
UPDATE employees SET salary = salary * 2;
SELECT * FROM employees ORDER BY id;
-- 1|Alice|200.0
-- 2|Bob|400.0
-- 3|Charlie|600.0
</code></pre>
<pre><code class="language-sql">-- Self-referencing expression: columns on the right side use pre-update values
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, salary REAL);
INSERT INTO employees VALUES (1, 'Alice', 10.0), (2, 'Bob', 20.0);
UPDATE employees SET salary = salary + 5.0 WHERE salary &lt; 15.0;
SELECT * FROM employees ORDER BY id;
-- 1|Alice|15.0
-- 2|Bob|20.0
</code></pre>
<pre><code class="language-sql">-- Update with a subquery in the WHERE clause
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT, salary REAL);
INSERT INTO employees VALUES (1, 'Alice', 'Engineering', 85000.0), (2, 'Bob', 'Sales', 72000.0);
CREATE TABLE priority_departments (name TEXT);
INSERT INTO priority_departments VALUES ('Engineering');
UPDATE employees SET salary = salary + 10000.0
  WHERE department IN (SELECT name FROM priority_departments);
SELECT name, salary FROM employees ORDER BY id;
-- Alice|95000.0
-- Bob|72000.0
</code></pre>
<pre><code class="language-sql">-- Scalar subquery in SET to assign a computed value
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, salary REAL);
INSERT INTO employees VALUES (1, 'Alice', 80000.0), (2, 'Bob', 60000.0);
UPDATE employees SET salary = (SELECT AVG(salary) FROM employees) WHERE id = 2;
SELECT * FROM employees ORDER BY id;
-- 1|Alice|80000.0
-- 2|Bob|70000.0
</code></pre>
<pre><code class="language-sql">-- Update with EXISTS subquery
CREATE TABLE orders (id INTEGER PRIMARY KEY, customer_id INTEGER, status TEXT);
INSERT INTO orders VALUES (1, 100, 'pending'), (2, 101, 'pending'), (3, 102, 'pending');
CREATE TABLE order_items (order_id INTEGER, product TEXT);
INSERT INTO order_items VALUES (1, 'widget'), (3, 'gadget');
UPDATE orders SET status = 'has_items'
  WHERE EXISTS (SELECT 1 FROM order_items WHERE order_items.order_id = orders.id);
SELECT id, status FROM orders ORDER BY id;
-- 1|has_items
-- 2|pending
-- 3|has_items
</code></pre>
<pre><code class="language-sql">-- UPDATE with RETURNING to see new values
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, salary REAL);
INSERT INTO employees VALUES (1, 'Alice', 85000.0), (2, 'Bob', 72000.0);
UPDATE employees SET salary = salary + 10000.0 WHERE id = 1 RETURNING id, name, salary;
-- 1|Alice|95000.0
</code></pre>
<pre><code class="language-sql">-- RETURNING with expressions and functions
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, salary REAL);
INSERT INTO employees VALUES (1, 'Alice', 85000.0);
UPDATE employees SET name = 'alice johnson' WHERE id = 1
  RETURNING id, upper(name), salary;
-- 1|ALICE JOHNSON|85000.0
</code></pre>
<pre><code class="language-sql">-- RETURNING all columns with *
CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, salary REAL);
INSERT INTO employees VALUES (1, 'Alice', 85000.0);
UPDATE employees SET salary = 90000.0 WHERE id = 1 RETURNING *;
-- 1|Alice|90000.0
</code></pre>
<pre><code class="language-sql">-- Row value syntax for multiple assignments
CREATE TABLE contacts (id INTEGER PRIMARY KEY, first_name TEXT, last_name TEXT);
INSERT INTO contacts VALUES (1, 'Jane', 'Doe');
UPDATE contacts SET (first_name, last_name) = ('John', 'Smith') WHERE id = 1
  RETURNING *;
-- 1|John|Smith
</code></pre>
<pre><code class="language-sql">-- UPDATE OR IGNORE: skip rows that would violate a UNIQUE constraint
CREATE TABLE tags (id INTEGER PRIMARY KEY, label TEXT UNIQUE);
INSERT INTO tags VALUES (1, 'urgent'), (2, 'review');
UPDATE OR IGNORE tags SET label = 'urgent' WHERE id = 2;
SELECT * FROM tags ORDER BY id;
-- 1|urgent
-- 2|review
</code></pre>
<pre><code class="language-sql">-- UPDATE OR REPLACE: delete the conflicting row and apply the update
CREATE TABLE tags (id INTEGER PRIMARY KEY, label TEXT UNIQUE);
INSERT INTO tags VALUES (1, 'urgent'), (2, 'review');
UPDATE OR REPLACE tags SET label = 'urgent' WHERE id = 2;
SELECT * FROM tags ORDER BY id;
-- 2|urgent
</code></pre>
<pre><code class="language-sql">-- UPDATE with LIMIT
CREATE TABLE tasks (id INTEGER PRIMARY KEY, done INTEGER DEFAULT 0);
INSERT INTO tasks (id) VALUES (1), (2), (3), (4), (5);
UPDATE tasks SET done = 1 LIMIT 2;
SELECT COUNT(*) FROM tasks WHERE done = 1;
-- 2
</code></pre>
<pre><code class="language-sql">-- Update the rowid directly
CREATE TABLE notes (content TEXT);
INSERT INTO notes (content) VALUES ('hello');
UPDATE notes SET rowid = 42;
SELECT rowid, content FROM notes;
-- 42|hello
</code></pre>
<pre><code class="language-sql">-- Update using a table alias in the WHERE clause
CREATE TABLE scores (player TEXT, points INTEGER);
INSERT INTO scores VALUES ('Alice', 10), ('Bob', 20);
UPDATE scores AS s SET points = 99 WHERE s.player = 'Alice';
SELECT * FROM scores ORDER BY player;
-- Alice|99
-- Bob|20
</code></pre>
<h2 id="compatibility-7"><a class="header" href="#compatibility-7">Compatibility</a></h2>
<p>Turso supports the core UPDATE statement with full compatibility. The following
features are not yet available:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>UPDATE … FROM</td><td>Not supported. Use subqueries in SET or WHERE instead.</td></tr>
<tr><td>ORDER BY clause</td><td>Not supported. LIMIT and OFFSET select from an arbitrary set of qualifying rows.</td></tr>
<tr><td>INDEXED BY / NOT INDEXED</td><td>Not supported. The query planner chooses indexes automatically.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="delete"><a class="header" href="#delete">DELETE</a></h1>
<h2 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h2>
<pre><code class="language-sql">[WITH cte-name AS (SELECT ...) [, ...]]
DELETE FROM table-name
  [WHERE expr]
  [RETURNING expr [AS alias] [, ...]]
  [LIMIT expr]
</code></pre>
<h2 id="description-10"><a class="header" href="#description-10">Description</a></h2>
<p>The DELETE statement removes rows from a table. If a WHERE clause is provided,
only the rows for which the WHERE expression evaluates to true are removed. Rows
where the expression evaluates to false or NULL are retained.</p>
<p>If the WHERE clause is omitted, all rows in the table are deleted. The table
itself is not dropped – it remains in the schema with zero rows.</p>
<p>The optional RETURNING clause causes the DELETE statement to return values from
each deleted row, behaving much like a SELECT over the rows being removed.
The optional LIMIT clause restricts the maximum number of rows deleted.</p>
<h2 id="clauses-8"><a class="header" href="#clauses-8">Clauses</a></h2>
<h3 id="where-2"><a class="header" href="#where-2">WHERE</a></h3>
<p>The WHERE clause specifies which rows to delete. It accepts any SQL expression
that evaluates to a boolean result. Only rows where the expression is true are
deleted. The expression may reference columns of the target table, use
subqueries, and include any supported operators or functions.</p>
<p>When the WHERE clause is omitted, every row in the table is deleted.</p>
<pre><code class="language-sql">-- Delete a single row by primary key
DELETE FROM employees WHERE id = 42;

-- Delete rows matching a compound condition
DELETE FROM employees WHERE salary &lt; 90000 AND department = 'Marketing';

-- Delete rows using an IN list
DELETE FROM orders WHERE status IN ('cancelled', 'expired');
</code></pre>
<h3 id="returning-2"><a class="header" href="#returning-2">RETURNING</a></h3>
<p>The RETURNING clause causes the DELETE statement to return values from each
deleted row. It accepts a comma-separated list of expressions that may reference
columns of the deleted row, use functions, or contain computed values. Use <code>*</code> to
return all columns.</p>
<pre><code class="language-sql">DELETE FROM products WHERE quantity = 0 RETURNING id, name;

DELETE FROM employees WHERE department = 'Sales' RETURNING *;
</code></pre>
<p>For full details on the RETURNING clause, see <a href="#returning-3">RETURNING</a>.</p>
<h3 id="limit-2"><a class="header" href="#limit-2">LIMIT</a></h3>
<p>The LIMIT clause restricts the maximum number of rows deleted. When present, at
most <code>expr</code> rows are removed. A negative LIMIT value means no limit.</p>
<pre><code class="language-sql">-- Delete at most 2 rows from the table
DELETE FROM employees LIMIT 2;
</code></pre>
<h3 id="with-common-table-expressions"><a class="header" href="#with-common-table-expressions">WITH (Common Table Expressions)</a></h3>
<p>A DELETE statement may be preceded by a WITH clause that defines one or more
common table expressions. CTEs defined this way can be referenced in the WHERE
clause or in subqueries within the statement.</p>
<pre><code class="language-sql">WITH low_earners AS (
  SELECT id FROM employees WHERE salary &lt; 90000
)
DELETE FROM employees WHERE id IN (SELECT id FROM low_earners);
</code></pre>
<p>For more on CTEs, see <a href="#common-table-expressions">Common Table Expressions</a>.</p>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<pre><code class="language-sql">-- Create and populate a sample table
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  department TEXT,
  salary REAL
);

INSERT INTO employees VALUES
  (1, 'Alice', 'Engineering', 120000.00),
  (2, 'Bob', 'Marketing', 85000.00),
  (3, 'Carol', 'Engineering', 110000.00),
  (4, 'Dave', 'Sales', 90000.00),
  (5, 'Eve', 'Marketing', 78000.00);
</code></pre>
<pre><code class="language-sql">-- Delete a single row by primary key
DELETE FROM employees WHERE id = 4;
SELECT * FROM employees;
-- 1|Alice|Engineering|120000.0
-- 2|Bob|Marketing|85000.0
-- 3|Carol|Engineering|110000.0
-- 5|Eve|Marketing|78000.0
</code></pre>
<pre><code class="language-sql">-- Delete all rows matching a condition
DELETE FROM employees WHERE department = 'Marketing';
SELECT * FROM employees;
-- 1|Alice|Engineering|120000.0
-- 3|Carol|Engineering|110000.0
-- 4|Dave|Sales|90000.0
</code></pre>
<pre><code class="language-sql">-- Delete all rows from a table (table itself remains)
DELETE FROM employees;
SELECT * FROM employees;
-- (no rows returned)
</code></pre>
<pre><code class="language-sql">-- Delete with RETURNING to see which rows were removed
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price REAL,
  quantity INTEGER
);

INSERT INTO products VALUES
  (1, 'Widget', 9.99, 100),
  (2, 'Gadget', 24.99, 0),
  (3, 'Doohickey', 4.99, 0),
  (4, 'Thingamajig', 14.99, 50);

DELETE FROM products WHERE quantity = 0 RETURNING id, name;
-- 2|Gadget
-- 3|Doohickey
</code></pre>
<pre><code class="language-sql">-- RETURNING with a computed expression
DELETE FROM products WHERE quantity = 0
  RETURNING id, name, price * quantity AS lost_value;
-- 2|Gadget|0.0
-- 3|Doohickey|0.0
</code></pre>
<pre><code class="language-sql">-- RETURNING * returns all columns of each deleted row
DELETE FROM products WHERE price &gt; 100.00 RETURNING *;
</code></pre>
<pre><code class="language-sql">-- Delete using a subquery in WHERE
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  department TEXT,
  salary REAL
);

INSERT INTO employees VALUES
  (1, 'Alice', 'Engineering', 120000.00),
  (2, 'Bob', 'Marketing', 85000.00),
  (3, 'Carol', 'Engineering', 110000.00);

DELETE FROM employees
  WHERE id IN (SELECT id FROM employees WHERE department = 'Engineering');
SELECT * FROM employees;
-- 2|Bob|Marketing|85000.0
</code></pre>
<pre><code class="language-sql">-- Delete with a CTE
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  department TEXT,
  salary REAL
);

INSERT INTO employees VALUES
  (1, 'Alice', 'Engineering', 120000.00),
  (2, 'Bob', 'Marketing', 85000.00),
  (3, 'Carol', 'Engineering', 110000.00),
  (4, 'Dave', 'Sales', 90000.00),
  (5, 'Eve', 'Marketing', 78000.00);

WITH low_earners AS (
  SELECT id FROM employees WHERE salary &lt; 90000
)
DELETE FROM employees WHERE id IN (SELECT id FROM low_earners);
SELECT * FROM employees;
-- 1|Alice|Engineering|120000.0
-- 3|Carol|Engineering|110000.0
-- 4|Dave|Sales|90000.0
</code></pre>
<pre><code class="language-sql">-- Delete with LIMIT: remove at most 2 rows
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  department TEXT,
  salary REAL
);

INSERT INTO employees VALUES
  (1, 'Alice', 'Engineering', 120000.00),
  (2, 'Bob', 'Marketing', 85000.00),
  (3, 'Carol', 'Engineering', 110000.00),
  (4, 'Dave', 'Sales', 90000.00),
  (5, 'Eve', 'Marketing', 78000.00);

DELETE FROM employees LIMIT 2;
SELECT * FROM employees;
-- 3|Carol|Engineering|110000.0
-- 4|Dave|Sales|90000.0
-- 5|Eve|Marketing|78000.0
</code></pre>
<pre><code class="language-sql">-- Delete with WHERE and LIMIT: remove one matching row
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  department TEXT,
  salary REAL
);

INSERT INTO employees VALUES
  (1, 'Alice', 'Engineering', 120000.00),
  (2, 'Bob', 'Marketing', 85000.00),
  (3, 'Carol', 'Engineering', 110000.00);

DELETE FROM employees WHERE department = 'Engineering' LIMIT 1;
SELECT * FROM employees;
-- 2|Bob|Marketing|85000.0
-- 3|Carol|Engineering|110000.0
</code></pre>
<pre><code class="language-sql">-- Use changes() to check how many rows were deleted
CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  department TEXT,
  salary REAL
);

INSERT INTO employees VALUES
  (1, 'Alice', 'Engineering', 120000.00),
  (2, 'Bob', 'Marketing', 85000.00),
  (3, 'Carol', 'Engineering', 110000.00),
  (4, 'Dave', 'Sales', 90000.00),
  (5, 'Eve', 'Marketing', 78000.00);

DELETE FROM employees WHERE department = 'Marketing';
SELECT changes();
-- 2
</code></pre>
<h2 id="compatibility-8"><a class="header" href="#compatibility-8">Compatibility</a></h2>
<p>Turso supports the DELETE statement with broad compatibility to SQLite, including
the WHERE clause, RETURNING clause, LIMIT, and common table expressions.</p>
<p>The following differences from SQLite apply:</p>
<ul>
<li>
<p><strong>ORDER BY on DELETE</strong> is not supported. In SQLite, ORDER BY is available
(when compiled with <code>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</code>) and is used together
with LIMIT to control which specific rows are deleted. Turso supports LIMIT on
DELETE but does not support ORDER BY in this context.</p>
</li>
<li>
<p><strong>OFFSET on DELETE</strong> is parsed but not currently effective. While the syntax is
accepted, the OFFSET value is ignored and all deletions start from the first
matching row. Use a subquery with LIMIT and OFFSET in a SELECT if you need to
skip rows before deleting.</p>
</li>
<li>
<p><strong>INDEXED BY / NOT INDEXED</strong> hints are not supported on DELETE statements.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="returning-3"><a class="header" href="#returning-3">RETURNING</a></h1>
<h2 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h2>
<pre><code class="language-sql">{INSERT | UPDATE | DELETE} ...
  RETURNING {expr [[AS] column-alias] | *} [, ...]
</code></pre>
<h2 id="description-11"><a class="header" href="#description-11">Description</a></h2>
<p>The <code>RETURNING</code> clause is an optional clause that can be appended to <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements. It causes the statement to return one result row for each database row that is inserted, updated, or deleted. This eliminates the need for a separate <code>SELECT</code> query to retrieve values that were generated or modified by the statement.</p>
<p>A common use case is retrieving auto-generated primary keys, computed default values, or confirming which rows were affected by an <code>UPDATE</code> or <code>DELETE</code>.</p>
<p>The <code>RETURNING</code> clause is not part of the SQL standard. It follows the syntax established by PostgreSQL.</p>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>The <code>RETURNING</code> keyword is followed by a comma-separated list of expressions, similar to the expressions that follow <code>SELECT</code> in a query. Each expression may reference columns of the table being modified, use literal values, call scalar functions, or combine these with operators.</p>
<h3 id="column-references"><a class="header" href="#column-references">Column References</a></h3>
<p>Expressions in <code>RETURNING</code> can reference any column of the modified table, either unqualified or qualified with the table name:</p>
<pre><code class="language-sql">RETURNING id, name
RETURNING orders.id, orders.name
</code></pre>
<p>For <code>INSERT</code> and <code>UPDATE</code>, column references reflect the values <strong>after</strong> the change has been applied. For <code>DELETE</code>, column references reflect the values of the row <strong>before</strong> it is removed.</p>
<h3 id="the--operator"><a class="header" href="#the--operator">The * Operator</a></h3>
<p>The <code>*</code> expands into all columns of the table being modified:</p>
<pre><code class="language-sql">INSERT INTO orders (...) VALUES (...) RETURNING *;
</code></pre>
<h3 id="column-aliases-1"><a class="header" href="#column-aliases-1">Column Aliases</a></h3>
<p>Each expression may optionally be followed by <code>AS column-alias</code> (or just <code>column-alias</code> without <code>AS</code>) to set the name of the result column:</p>
<pre><code class="language-sql">RETURNING quantity * unit_price AS total
</code></pre>
<h3 id="allowed-expressions"><a class="header" href="#allowed-expressions">Allowed Expressions</a></h3>
<p>The following kinds of expressions are allowed in a <code>RETURNING</code> clause:</p>
<ul>
<li>Literal values (<code>42</code>, <code>'hello'</code>, <code>NULL</code>)</li>
<li>Column references (<code>id</code>, <code>table_name.column_name</code>)</li>
<li>Arithmetic and comparison operators (<code>price * 1.1</code>, <code>value &gt; 0</code>)</li>
<li>String concatenation (<code>first || ' ' || last</code>)</li>
<li>Scalar function calls (<code>upper(name)</code>, <code>round(price, 2)</code>, <code>coalesce(a, b)</code>)</li>
<li><code>CASE</code> expressions</li>
<li><code>CAST</code> expressions</li>
<li><code>IN</code>, <code>BETWEEN</code>, <code>LIKE</code>, <code>GLOB</code>, <code>IS NULL</code>, <code>IS NOT NULL</code> operators</li>
<li>The <code>rowid</code> pseudo-column</li>
</ul>
<h3 id="disallowed-expressions"><a class="header" href="#disallowed-expressions">Disallowed Expressions</a></h3>
<p>Top-level aggregate functions (<code>SUM</code>, <code>COUNT</code>, <code>AVG</code>, etc.) and window functions are not permitted in <code>RETURNING</code>. Using them produces an error:</p>
<pre><code class="language-sql">-- Error: aggregate functions not allowed in RETURNING
INSERT INTO t VALUES (1, 42) RETURNING SUM(value);
</code></pre>
<h2 id="behavior"><a class="header" href="#behavior">Behavior</a></h2>
<h3 id="insert-returning"><a class="header" href="#insert-returning">INSERT RETURNING</a></h3>
<p>Returns one row for each inserted row. When inserting multiple rows, one result row is produced per input row. The returned values reflect the state after insertion, including auto-generated primary keys and evaluated <code>DEFAULT</code> expressions.</p>
<h3 id="update-returning"><a class="header" href="#update-returning">UPDATE RETURNING</a></h3>
<p>Returns one row for each row that was actually modified by the <code>UPDATE</code>. Column values in the result reflect the new values after the update. If the <code>WHERE</code> clause matches no rows, no result rows are produced.</p>
<h3 id="delete-returning"><a class="header" href="#delete-returning">DELETE RETURNING</a></h3>
<p>Returns one row for each deleted row. Column values in the result reflect the values the row had before deletion. If the <code>WHERE</code> clause matches no rows, no result rows are produced.</p>
<h3 id="upsert-on-conflict-returning"><a class="header" href="#upsert-on-conflict-returning">UPSERT (ON CONFLICT) RETURNING</a></h3>
<p>When <code>RETURNING</code> is used with an <code>INSERT ... ON CONFLICT</code> statement, it returns rows for both the insert and update code paths. If the conflict resolution is <code>DO NOTHING</code> and a conflict occurs, no row is returned for that conflicting input row.</p>
<h3 id="output-order"><a class="header" href="#output-order">Output Order</a></h3>
<p>The order of rows returned by <code>RETURNING</code> is not guaranteed. It typically matches the order in which rows were processed, but applications should not rely on any particular ordering.</p>
<h3 id="triggers"><a class="header" href="#triggers">Triggers</a></h3>
<p>The <code>RETURNING</code> clause reports the direct changes made by the statement. It does not report additional changes caused by triggers or foreign key constraint actions.</p>
<h2 id="examples-11"><a class="header" href="#examples-11">Examples</a></h2>
<pre><code class="language-sql">-- Retrieve the auto-generated id after inserting a row
CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer TEXT NOT NULL,
  product TEXT NOT NULL,
  quantity INTEGER NOT NULL,
  unit_price REAL NOT NULL
);

INSERT INTO orders (customer, product, quantity, unit_price)
  VALUES ('Alice', 'Widget', 5, 9.99)
  RETURNING id;
-- 1
</code></pre>
<pre><code class="language-sql">-- Return all columns of newly inserted rows
INSERT INTO orders (customer, product, quantity, unit_price)
  VALUES ('Alice', 'Widget', 5, 9.99)
  RETURNING *;
-- 1|Alice|Widget|5|9.99
</code></pre>
<pre><code class="language-sql">-- Return a computed expression with an alias
INSERT INTO orders (customer, product, quantity, unit_price)
  VALUES ('Alice', 'Widget', 5, 9.99)
  RETURNING id, customer, quantity * unit_price AS total;
-- 1|Alice|49.95
</code></pre>
<pre><code class="language-sql">-- Return multiple rows from a multi-row INSERT
CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  active INTEGER DEFAULT 1
);

INSERT INTO users (name, email)
  VALUES ('Alice', 'alice@example.com'),
         ('Bob', 'bob@example.com'),
         ('Charlie', 'charlie@example.com')
  RETURNING id, name;
-- 1|Alice
-- 2|Bob
-- 3|Charlie
</code></pre>
<pre><code class="language-sql">-- Retrieve auto-filled DEFAULT values
CREATE TABLE events (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  created_at TEXT DEFAULT (datetime('now'))
);

INSERT INTO events (name) VALUES ('signup')
  RETURNING id, name, created_at;
-- 1|signup|2026-02-11 18:52:48
</code></pre>
<pre><code class="language-sql">-- See which rows were updated and their new values
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  price REAL NOT NULL
);

INSERT INTO products (name, price)
  VALUES ('Laptop', 999.99), ('Mouse', 29.99), ('Keyboard', 79.99);

UPDATE products SET price = price * 0.9
  RETURNING id, name, round(price, 2) AS discounted_price;
-- 1|Laptop|899.99
-- 2|Mouse|26.99
-- 3|Keyboard|71.99
</code></pre>
<pre><code class="language-sql">-- Use a CASE expression in RETURNING
CREATE TABLE tasks (
  id INTEGER PRIMARY KEY,
  title TEXT NOT NULL,
  done INTEGER DEFAULT 0
);

INSERT INTO tasks (title)
  VALUES ('Write report'), ('Fix bug'), ('Review PR');

UPDATE tasks SET done = 1 WHERE id = 2
  RETURNING id, title,
    CASE WHEN done THEN 'completed' ELSE 'pending' END AS status;
-- 2|Fix bug|completed
</code></pre>
<pre><code class="language-sql">-- Confirm which rows were deleted
CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  active INTEGER DEFAULT 1
);

INSERT INTO users (name, email)
  VALUES ('Alice', 'alice@example.com'),
         ('Bob', 'bob@example.com'),
         ('Charlie', 'charlie@example.com');

DELETE FROM users WHERE active = 1
  RETURNING id, name, email;
-- 1|Alice|alice@example.com
-- 2|Bob|bob@example.com
-- 3|Charlie|charlie@example.com
</code></pre>
<pre><code class="language-sql">-- Use function expressions in DELETE RETURNING
CREATE TABLE logs (
  id INTEGER PRIMARY KEY,
  message TEXT NOT NULL,
  level TEXT NOT NULL
);

INSERT INTO logs (message, level)
  VALUES ('User login', 'info'), ('Disk full', 'error'), ('Timeout', 'warn');

DELETE FROM logs WHERE level = 'error'
  RETURNING id, message, upper(level) AS level;
-- 2|Disk full|ERROR
</code></pre>
<pre><code class="language-sql">-- RETURNING with UPSERT: insert path
CREATE TABLE settings (key TEXT PRIMARY KEY, value TEXT NOT NULL);

INSERT INTO settings (key, value) VALUES ('theme', 'dark')
  ON CONFLICT(key) DO UPDATE SET value = excluded.value
  RETURNING key, value;
-- theme|dark
</code></pre>
<pre><code class="language-sql">-- RETURNING with UPSERT: update path (conflict triggers DO UPDATE)
CREATE TABLE settings (key TEXT PRIMARY KEY, value TEXT NOT NULL);
INSERT INTO settings (key, value) VALUES ('theme', 'dark');

INSERT INTO settings (key, value) VALUES ('theme', 'light')
  ON CONFLICT(key) DO UPDATE SET value = excluded.value
  RETURNING key, value;
-- theme|light
</code></pre>
<pre><code class="language-sql">-- RETURNING with UPSERT: DO NOTHING returns no rows on conflict
CREATE TABLE settings (key TEXT PRIMARY KEY, value TEXT NOT NULL);
INSERT INTO settings (key, value) VALUES ('theme', 'dark');

INSERT INTO settings (key, value) VALUES ('theme', 'light')
  ON CONFLICT DO NOTHING
  RETURNING key, value;
-- (no rows returned)
</code></pre>
<pre><code class="language-sql">-- RETURNING with INSERT ... SELECT
CREATE TABLE source (id INTEGER, name TEXT, score INTEGER);
CREATE TABLE archive (name TEXT, score INTEGER);

INSERT INTO source VALUES (1, 'Alice', 95), (2, 'Bob', 82), (3, 'Charlie', 78);

INSERT INTO archive SELECT name, score FROM source WHERE score &gt;= 80
  RETURNING *;
-- Alice|95
-- Bob|82
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="create-table"><a class="header" href="#create-table">CREATE TABLE</a></h1>
<h2 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h2>
<pre><code class="language-sql">CREATE TABLE [IF NOT EXISTS] table-name (
  column-def [, ...]
  [, table-constraint [, ...]]
) [STRICT]
</code></pre>
<p>Where <code>column-def</code> is:</p>
<pre><code class="language-sql">column-name [type-name] [column-constraint ...]
</code></pre>
<p>And <code>column-constraint</code> is one of:</p>
<pre><code class="language-sql">PRIMARY KEY [ASC | DESC] [AUTOINCREMENT] [conflict-clause]
NOT NULL [conflict-clause]
UNIQUE [conflict-clause]
CHECK (expr)
DEFAULT {value | (expr)}
COLLATE {BINARY | NOCASE | RTRIM}
REFERENCES foreign-table (foreign-column [, ...]) [foreign-key-action ...]
[CONSTRAINT constraint-name] column-constraint
</code></pre>
<p>And <code>table-constraint</code> is one of:</p>
<pre><code class="language-sql">PRIMARY KEY (column-name [, ...]) [conflict-clause]
UNIQUE (column-name [, ...]) [conflict-clause]
CHECK (expr)
FOREIGN KEY (column-name [, ...]) REFERENCES foreign-table (foreign-column [, ...]) [foreign-key-action ...]
</code></pre>
<p>And <code>conflict-clause</code> is:</p>
<pre><code class="language-sql">ON CONFLICT {ROLLBACK | ABORT | FAIL | IGNORE | REPLACE}
</code></pre>
<h2 id="description-12"><a class="header" href="#description-12">Description</a></h2>
<p>The <code>CREATE TABLE</code> statement creates a new table in the database. Each table has a name, a list of column definitions, and optional table-level constraints. Table names beginning with <code>sqlite_</code> are reserved for internal use and cannot be created by user SQL.</p>
<p>Every ordinary table in Turso has an implicit 64-bit signed integer key called the <code>rowid</code>. The rowid uniquely identifies each row within the table and provides fast lookup. You can access it using the names <code>rowid</code>, <code>_rowid_</code>, or <code>oid</code>, unless one of those names is used as an explicit column name.</p>
<h2 id="clauses-9"><a class="header" href="#clauses-9">Clauses</a></h2>
<h3 id="if-not-exists"><a class="header" href="#if-not-exists">IF NOT EXISTS</a></h3>
<p>When <code>IF NOT EXISTS</code> is specified, the statement is a no-op if a table with the same name already exists. Without this clause, attempting to create a table with an existing name produces an error.</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT);
</code></pre>
<h3 id="column-definitions"><a class="header" href="#column-definitions">Column Definitions</a></h3>
<p>Each column definition specifies a column name and an optional declared type. The declared type determines the column’s <strong>type affinity</strong>, which influences how values are coerced on insertion. See <a href="#type-conversions">Type Conversions</a> for the full affinity rules.</p>
<p>Turso uses dynamic typing. A column’s declared type does not restrict what values can be stored in it (unless the table uses <code>STRICT</code> mode). Any column can hold any storage class: NULL, INTEGER, REAL, TEXT, or BLOB.</p>
<h3 id="default"><a class="header" href="#default">DEFAULT</a></h3>
<p>The <code>DEFAULT</code> clause specifies a value to use when an <code>INSERT</code> statement omits a column. If no <code>DEFAULT</code> clause is specified, the default value is <code>NULL</code>.</p>
<p>The default value can be:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Form</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>NULL</code></td><td>Null value.</td></tr>
<tr><td>Signed number</td><td>A literal integer or real number, optionally with a <code>+</code> or <code>-</code> prefix.</td></tr>
<tr><td>String literal</td><td>A single-quoted string.</td></tr>
<tr><td><code>TRUE</code> / <code>FALSE</code></td><td>Boolean literals (stored as 1 and 0).</td></tr>
<tr><td><code>CURRENT_TIME</code></td><td>Current time as <code>HH:MM:SS</code>.</td></tr>
<tr><td><code>CURRENT_DATE</code></td><td>Current date as <code>YYYY-MM-DD</code>.</td></tr>
<tr><td><code>CURRENT_TIMESTAMP</code></td><td>Current date and time as <code>YYYY-MM-DD HH:MM:SS</code>.</td></tr>
<tr><td><code>(expr)</code></td><td>An expression in parentheses, evaluated at insert time.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL DEFAULT 'Unknown',
  price REAL DEFAULT 0.0,
  in_stock INTEGER DEFAULT TRUE,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
</code></pre>
<h3 id="primary-key"><a class="header" href="#primary-key">PRIMARY KEY</a></h3>
<p>Each table may have at most one primary key. A primary key can be declared as a column constraint (single-column) or as a table constraint (composite).</p>
<p><strong>Single-column primary key:</strong></p>
<pre><code class="language-sql">CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);
</code></pre>
<p><strong>Composite primary key (table constraint):</strong></p>
<pre><code class="language-sql">CREATE TABLE enrollment (
  student_id INTEGER,
  course_id INTEGER,
  grade TEXT,
  PRIMARY KEY (student_id, course_id)
);
</code></pre>
<p>Attempting to insert a duplicate primary key value produces a constraint violation error.</p>
<h4 id="integer-primary-key-and-the-rowid"><a class="header" href="#integer-primary-key-and-the-rowid">INTEGER PRIMARY KEY and the Rowid</a></h4>
<p>When a single column is declared with the exact type name <code>INTEGER</code> and is the <code>PRIMARY KEY</code>, that column becomes an alias for the rowid. This is a special case:</p>
<ul>
<li>The type name must be exactly <code>INTEGER</code> – not <code>INT</code>, <code>BIGINT</code>, <code>SMALLINT</code>, or any other variation.</li>
<li>The column can only contain integer values (or NULL, which is auto-assigned a rowid).</li>
<li>Inserting <code>NULL</code> into an <code>INTEGER PRIMARY KEY</code> column automatically assigns the next available rowid.</li>
</ul>
<pre><code class="language-sql">CREATE TABLE events (
  id INTEGER PRIMARY KEY,
  description TEXT
);
INSERT INTO events (description) VALUES ('Server started');
-- id is automatically assigned (e.g., 1)
INSERT INTO events (id, description) VALUES (NULL, 'User login');
-- id is automatically assigned (e.g., 2)
</code></pre>
<h3 id="autoincrement"><a class="header" href="#autoincrement">AUTOINCREMENT</a></h3>
<p>The <code>AUTOINCREMENT</code> keyword can only be used with <code>INTEGER PRIMARY KEY</code>. It modifies the automatic rowid assignment to guarantee that automatically-assigned rowids are never reused, even after rows are deleted.</p>
<p>Without <code>AUTOINCREMENT</code>, Turso reuses deleted rowid values. With <code>AUTOINCREMENT</code>, Turso tracks the largest rowid ever inserted in the internal <code>sqlite_sequence</code> table, and new auto-assigned rowids are always greater than any previously used value.</p>
<pre><code class="language-sql">CREATE TABLE audit_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  action TEXT NOT NULL
);
INSERT INTO audit_log (action) VALUES ('create');
INSERT INTO audit_log (action) VALUES ('update');
DELETE FROM audit_log WHERE id = 2;
INSERT INTO audit_log (action) VALUES ('delete');
-- The new row gets id=3, not id=2
</code></pre>
<p><code>AUTOINCREMENT</code> has a small performance cost because it requires reading and writing the <code>sqlite_sequence</code> table on each insert. Use it only when strictly monotonically increasing rowids are required.</p>
<p>If the maximum rowid value (9223372036854775807) has been used, inserting a new row with <code>AUTOINCREMENT</code> produces an error rather than attempting to find an unused rowid.</p>
<h3 id="not-null"><a class="header" href="#not-null">NOT NULL</a></h3>
<p>The <code>NOT NULL</code> constraint prevents a column from containing NULL values. Attempting to insert or update a NULL into a <code>NOT NULL</code> column produces a constraint violation error.</p>
<pre><code class="language-sql">CREATE TABLE contacts (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  phone TEXT
);
</code></pre>
<h3 id="unique"><a class="header" href="#unique">UNIQUE</a></h3>
<p>The <code>UNIQUE</code> constraint ensures that all values in a column (or combination of columns) are distinct. Multiple <code>UNIQUE</code> constraints can appear on the same table.</p>
<pre><code class="language-sql">CREATE TABLE accounts (
  id INTEGER PRIMARY KEY,
  username TEXT UNIQUE,
  email TEXT UNIQUE
);
</code></pre>
<p>A <code>UNIQUE</code> table constraint can span multiple columns:</p>
<pre><code class="language-sql">CREATE TABLE assignments (
  employee_id INTEGER,
  project_id INTEGER,
  role TEXT,
  UNIQUE (employee_id, project_id)
);
</code></pre>
<p>Note: NULL values are considered distinct from each other for <code>UNIQUE</code> constraint purposes. Multiple rows may have NULL in a <code>UNIQUE</code> column without violating the constraint.</p>
<h3 id="check"><a class="header" href="#check">CHECK</a></h3>
<p>The <code>CHECK</code> constraint specifies an expression that must evaluate to a non-zero (true) value for every row. If the expression evaluates to zero, the insert or update is rejected. NULL values pass <code>CHECK</code> constraints (NULL is neither true nor false).</p>
<p><code>CHECK</code> can be used as a column constraint or a table constraint:</p>
<pre><code class="language-sql">CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  age INTEGER CHECK (age &gt;= 18),
  salary INTEGER CHECK (salary &gt; 0),
  CHECK (age &lt;= 120)
);
</code></pre>
<p><code>CHECK</code> expressions may reference multiple columns, use functions, and include operators like <code>IN</code>, <code>BETWEEN</code>, <code>LIKE</code>, and <code>CASE</code>:</p>
<pre><code class="language-sql">CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  status TEXT CHECK (status IN ('pending', 'active', 'shipped', 'delivered')),
  quantity INTEGER,
  unit_price INTEGER,
  total INTEGER,
  CHECK (total = quantity * unit_price)
);
</code></pre>
<p><code>CHECK</code> expressions cannot contain subqueries, aggregate functions, or bind parameters. Referencing a non-existent column in a <code>CHECK</code> expression produces an error at table creation time.</p>
<h3 id="collate"><a class="header" href="#collate">COLLATE</a></h3>
<p>The <code>COLLATE</code> clause on a column definition sets the default collation sequence for that column. This affects comparisons, sorting, and <code>UNIQUE</code>/<code>PRIMARY KEY</code> constraints.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Collation</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>BINARY</code></td><td>Compares bytes directly (default).</td></tr>
<tr><td><code>NOCASE</code></td><td>Case-insensitive comparison for ASCII characters.</td></tr>
<tr><td><code>RTRIM</code></td><td>Like <code>BINARY</code>, but trailing spaces are ignored.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">CREATE TABLE tags (
  id INTEGER PRIMARY KEY,
  name TEXT COLLATE NOCASE UNIQUE
);
</code></pre>
<h3 id="foreign-key"><a class="header" href="#foreign-key">FOREIGN KEY</a></h3>
<p>Foreign key constraints enforce referential integrity between tables. A foreign key in a child table references a column (or columns) in a parent table, ensuring that every value in the child column exists in the parent column.</p>
<p>Foreign key enforcement must be enabled with <code>PRAGMA foreign_keys = ON</code> (it is off by default).</p>
<p><strong>Column-level syntax:</strong></p>
<pre><code class="language-sql">CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer_id INTEGER REFERENCES customers (id)
);
</code></pre>
<p><strong>Table-level syntax:</strong></p>
<pre><code class="language-sql">CREATE TABLE order_items (
  id INTEGER PRIMARY KEY,
  order_id INTEGER,
  product_id INTEGER,
  FOREIGN KEY (order_id) REFERENCES orders (id),
  FOREIGN KEY (product_id) REFERENCES products (id)
);
</code></pre>
<p><strong>Foreign key actions</strong> specify what happens when the referenced row in the parent table is deleted or updated:</p>
<pre><code class="language-sql">FOREIGN KEY (column) REFERENCES parent (column)
  [ON DELETE {SET NULL | CASCADE | RESTRICT | NO ACTION}]
  [ON UPDATE {SET NULL | CASCADE | RESTRICT | NO ACTION}]
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Action</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>NO ACTION</code></td><td>Reject the change if child rows exist (default).</td></tr>
<tr><td><code>RESTRICT</code></td><td>Same as <code>NO ACTION</code>, but checked immediately rather than deferred.</td></tr>
<tr><td><code>CASCADE</code></td><td>Delete or update the child rows to match the parent change.</td></tr>
<tr><td><code>SET NULL</code></td><td>Set the child foreign key column(s) to NULL.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">PRAGMA foreign_keys = ON;
CREATE TABLE departments (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE staff (
  id INTEGER PRIMARY KEY,
  dept_id INTEGER REFERENCES departments (id) ON DELETE CASCADE
);
</code></pre>
<h3 id="conflict-clauses"><a class="header" href="#conflict-clauses">Conflict Clauses</a></h3>
<p>The <code>PRIMARY KEY</code>, <code>NOT NULL</code>, and <code>UNIQUE</code> constraints accept an optional <code>ON CONFLICT</code> clause that specifies how constraint violations are handled:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Algorithm</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>ABORT</code></td><td>Abort the current statement and roll back its changes (default).</td></tr>
<tr><td><code>ROLLBACK</code></td><td>Abort the current statement and roll back the entire transaction.</td></tr>
<tr><td><code>FAIL</code></td><td>Abort the current statement but keep changes from earlier rows.</td></tr>
<tr><td><code>IGNORE</code></td><td>Skip the row that caused the violation and continue.</td></tr>
<tr><td><code>REPLACE</code></td><td>For <code>UNIQUE</code>/<code>PRIMARY KEY</code>: delete the conflicting row, then insert. For <code>NOT NULL</code>: replace the NULL with the column’s default value.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">CREATE TABLE settings (
  key TEXT PRIMARY KEY ON CONFLICT REPLACE,
  value TEXT NOT NULL
);
</code></pre>
<p>Note: <code>CHECK</code> constraints do not accept an <code>ON CONFLICT</code> clause in the column definition. The conflict resolution for <code>CHECK</code> violations is always <code>ABORT</code> by default, but can be overridden per-statement using <code>INSERT OR IGNORE</code>, <code>INSERT OR REPLACE</code>, etc.</p>
<h3 id="strict"><a class="header" href="#strict">STRICT</a></h3>
<p>The <code>STRICT</code> keyword at the end of the column list enables strict type checking. In a <code>STRICT</code> table, every column must have a declared type, and the type must be one of: <code>INTEGER</code>, <code>REAL</code>, <code>TEXT</code>, <code>BLOB</code>, or <code>ANY</code>.</p>
<p>When inserting or updating values, Turso rejects values that do not match the declared type (with some coercion: numeric strings are accepted for <code>INTEGER</code> and <code>REAL</code> columns). Columns without a <code>NOT NULL</code> constraint still accept <code>NULL</code> values.</p>
<pre><code class="language-sql">CREATE TABLE measurements (
  id INTEGER PRIMARY KEY,
  sensor_name TEXT,
  value REAL,
  recorded_at TEXT
) STRICT;
</code></pre>
<h2 id="examples-12"><a class="header" href="#examples-12">Examples</a></h2>
<h3 id="basic-table-with-constraints"><a class="header" href="#basic-table-with-constraints">Basic Table with Constraints</a></h3>
<pre><code class="language-sql">CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  username TEXT NOT NULL UNIQUE,
  email TEXT NOT NULL UNIQUE,
  display_name TEXT DEFAULT 'Anonymous',
  age INTEGER CHECK (age &gt;= 13)
);

INSERT INTO users (id, username, email, age)
VALUES (1, 'alice', 'alice@example.com', 30);
SELECT * FROM users;
-- 1|alice|alice@example.com|Anonymous|30
</code></pre>
<h3 id="composite-primary-key"><a class="header" href="#composite-primary-key">Composite Primary Key</a></h3>
<pre><code class="language-sql">CREATE TABLE enrollment (
  student_id INTEGER,
  course_id INTEGER,
  enrolled_at TEXT DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (student_id, course_id)
);

INSERT INTO enrollment (student_id, course_id) VALUES (1, 101);
INSERT INTO enrollment (student_id, course_id) VALUES (1, 102);
INSERT INTO enrollment (student_id, course_id) VALUES (2, 101);

SELECT student_id, course_id FROM enrollment ORDER BY student_id, course_id;
-- 1|101
-- 1|102
-- 2|101
</code></pre>
<h3 id="autoincrement-1"><a class="header" href="#autoincrement-1">AUTOINCREMENT</a></h3>
<pre><code class="language-sql">CREATE TABLE audit_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  action TEXT NOT NULL
);

INSERT INTO audit_log (action) VALUES ('user.login');
INSERT INTO audit_log (action) VALUES ('user.logout');
SELECT * FROM audit_log;
-- 1|user.login
-- 2|user.logout
</code></pre>
<h3 id="check-constraints-with-functions"><a class="header" href="#check-constraints-with-functions">CHECK Constraints with Functions</a></h3>
<pre><code class="language-sql">CREATE TABLE accounts (
  id INTEGER PRIMARY KEY,
  username TEXT CHECK (length(username) &gt;= 3 AND length(username) &lt;= 20),
  email TEXT CHECK (email LIKE '%@%.%')
);

INSERT INTO accounts VALUES (1, 'alice', 'alice@example.com');
SELECT * FROM accounts;
-- 1|alice|alice@example.com
</code></pre>
<h3 id="foreign-keys-with-cascade"><a class="header" href="#foreign-keys-with-cascade">Foreign Keys with CASCADE</a></h3>
<pre><code class="language-sql">PRAGMA foreign_keys = ON;

CREATE TABLE departments (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  dept_id INTEGER REFERENCES departments (id) ON DELETE CASCADE
);

INSERT INTO departments VALUES (1, 'Engineering'), (2, 'Sales');
INSERT INTO employees VALUES (1, 'Alice', 1), (2, 'Bob', 1), (3, 'Carol', 2);

DELETE FROM departments WHERE id = 1;
SELECT * FROM employees;
-- 3|Carol|2
</code></pre>
<h3 id="strict-table"><a class="header" href="#strict-table">STRICT Table</a></h3>
<pre><code class="language-sql">CREATE TABLE inventory (
  id INTEGER PRIMARY KEY,
  item_name TEXT,
  quantity INTEGER
) STRICT;

INSERT INTO inventory VALUES (1, 'Bolts', 500);
SELECT * FROM inventory;
-- 1|Bolts|500
</code></pre>
<h3 id="default-values-with-expressions"><a class="header" href="#default-values-with-expressions">Default Values with Expressions</a></h3>
<pre><code class="language-sql">CREATE TABLE tasks (
  id INTEGER PRIMARY KEY,
  title TEXT NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'active', 'done')),
  priority INTEGER DEFAULT (1 + 1)
);

INSERT INTO tasks (id, title) VALUES (1, 'Review pull request');
SELECT * FROM tasks;
-- 1|Review pull request|pending|2
</code></pre>
<h3 id="if-not-exists-1"><a class="header" href="#if-not-exists-1">IF NOT EXISTS</a></h3>
<pre><code class="language-sql">CREATE TABLE config (key TEXT PRIMARY KEY, value TEXT);
CREATE TABLE IF NOT EXISTS config (key TEXT PRIMARY KEY, value TEXT);
-- No error on the second statement
</code></pre>
<h3 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h3>
<pre><code class="language-sql">CREATE TABLE kv_store (
  key TEXT PRIMARY KEY ON CONFLICT REPLACE,
  value TEXT NOT NULL
);

INSERT INTO kv_store VALUES ('theme', 'light');
INSERT INTO kv_store VALUES ('theme', 'dark');

SELECT * FROM kv_store;
-- dark
</code></pre>
<h2 id="compatibility-9"><a class="header" href="#compatibility-9">Compatibility</a></h2>
<ul>
<li><strong>CREATE TABLE AS SELECT</strong> is not supported. Use <code>CREATE TABLE</code> followed by <code>INSERT ... SELECT</code> instead.</li>
<li><strong>TEMPORARY tables</strong> (<code>CREATE TEMP TABLE</code>) are not supported.</li>
<li><strong>WITHOUT ROWID tables</strong> are not supported.</li>
<li><strong>STRICT tables</strong> are experimental and partially supported.</li>
<li><strong>SET DEFAULT</strong> as a foreign key action is not supported; use <code>SET NULL</code> or <code>CASCADE</code> instead.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="create-index"><a class="header" href="#create-index">CREATE INDEX</a></h1>
<h2 id="syntax-13"><a class="header" href="#syntax-13">Syntax</a></h2>
<pre><code class="language-sql">CREATE [UNIQUE] INDEX [IF NOT EXISTS] index-name
  ON table-name (indexed-column [, ...])
  [WHERE expr]
</code></pre>
<p>Where <code>indexed-column</code> is:</p>
<pre><code class="language-sql">{column-name | (expr)} [COLLATE collation-name] [ASC | DESC]
</code></pre>
<p>To remove an index:</p>
<pre><code class="language-sql">DROP INDEX [IF EXISTS] index-name
</code></pre>
<h2 id="description-13"><a class="header" href="#description-13">Description</a></h2>
<p>The <code>CREATE INDEX</code> statement creates a new index on one or more columns of an existing table. Indexes speed up queries that filter, sort, or join on the indexed columns, at the cost of additional storage and slightly slower writes.</p>
<p>An index does not change the logical content of a table. Queries produce the same results whether or not an index exists. Turso automatically decides whether to use an available index when executing a query. You can use <a href="#explain">EXPLAIN</a> to see whether a query plan uses a particular index.</p>
<p>The <code>DROP INDEX</code> statement removes an index from the database. Dropping an index has no effect on the table data.</p>
<h2 id="clauses-10"><a class="header" href="#clauses-10">Clauses</a></h2>
<h3 id="unique-1"><a class="header" href="#unique-1">UNIQUE</a></h3>
<p>When the <code>UNIQUE</code> keyword appears between <code>CREATE</code> and <code>INDEX</code>, the index enforces a uniqueness constraint on the indexed columns. Any attempt to insert or update a row that would create a duplicate entry in the indexed columns produces a <code>UNIQUE constraint failed</code> error.</p>
<p>NULL values are considered distinct from each other for uniqueness purposes. Multiple rows may contain NULL in a <code>UNIQUE</code> index column without violating the constraint.</p>
<pre><code class="language-sql">CREATE UNIQUE INDEX idx_users_email ON users(email);
-- Two rows with email = 'alice@example.com' would be rejected.
-- Two rows with email = NULL are allowed.
</code></pre>
<h3 id="if-not-exists-2"><a class="header" href="#if-not-exists-2">IF NOT EXISTS</a></h3>
<p>When <code>IF NOT EXISTS</code> is specified, the statement is a no-op if an index with the same name already exists. Without this clause, attempting to create an index whose name is already in use produces an error.</p>
<pre><code class="language-sql">CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);
-- Safe to run repeatedly without error.
</code></pre>
<h3 id="if-exists-drop-index"><a class="header" href="#if-exists-drop-index">IF EXISTS (DROP INDEX)</a></h3>
<p>When <code>IF EXISTS</code> is included in a <code>DROP INDEX</code> statement, no error is raised if the named index does not exist. Without this clause, dropping a nonexistent index produces an error.</p>
<pre><code class="language-sql">DROP INDEX IF EXISTS idx_old_report;
</code></pre>
<h3 id="indexed-columns"><a class="header" href="#indexed-columns">Indexed Columns</a></h3>
<p>Each indexed column entry in the column list is either a column name or a parenthesized expression. Multiple columns or expressions can be listed, separated by commas, to create a composite (multi-column) index.</p>
<p>The order of columns in a composite index matters. An index on <code>(state, city)</code> is most useful for queries that filter on <code>state</code>, or on both <code>state</code> and <code>city</code>, but provides little benefit for queries that filter only on <code>city</code>.</p>
<h3 id="collate-1"><a class="header" href="#collate-1">COLLATE</a></h3>
<p>Each indexed column or expression may include a <code>COLLATE</code> clause specifying the collation sequence used for text comparisons within the index. If omitted, the collation defaults to the one defined on the column in <code>CREATE TABLE</code>, or <code>BINARY</code> if none was specified.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Collation</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>BINARY</code></td><td>Compares bytes directly (default).</td></tr>
<tr><td><code>NOCASE</code></td><td>Case-insensitive comparison for ASCII characters.</td></tr>
<tr><td><code>RTRIM</code></td><td>Like <code>BINARY</code>, but trailing spaces are ignored.</td></tr>
</tbody>
</table>
</div>
<p>For a query to use an index, the collation in the query’s comparison must match the collation of the index. If a column is defined as <code>COLLATE NOCASE</code> but the index uses <code>COLLATE BINARY</code>, queries that rely on case-insensitive matching will not use that index.</p>
<pre><code class="language-sql">CREATE INDEX idx_contacts_name ON contacts(last_name COLLATE NOCASE);
</code></pre>
<h3 id="asc--desc"><a class="header" href="#asc--desc">ASC / DESC</a></h3>
<p>Each indexed column or expression may be followed by <code>ASC</code> (ascending, the default) or <code>DESC</code> (descending) to specify the sort order stored in the index. Descending indexes are useful for queries that sort in descending order, allowing the index to be scanned in its natural order rather than reversed.</p>
<pre><code class="language-sql">CREATE INDEX idx_transactions_recent ON transactions(account_id, created_at DESC);
</code></pre>
<h3 id="where-partial-indexes"><a class="header" href="#where-partial-indexes">WHERE (Partial Indexes)</a></h3>
<p>When a <code>WHERE</code> clause is appended to <code>CREATE INDEX</code>, the result is a partial index. Only rows that satisfy the <code>WHERE</code> expression are included in the index. This reduces index size and write overhead for tables where queries consistently filter on a known condition.</p>
<p>The <code>WHERE</code> expression in a partial index has the following restrictions:</p>
<ul>
<li>It may not contain subqueries.</li>
<li>It may not use functions whose results can change (such as <code>random()</code>).</li>
<li>It may only reference columns of the indexed table.</li>
</ul>
<p>For Turso to use a partial index when executing a query, the query’s <code>WHERE</code> clause must imply the index’s <code>WHERE</code> clause. In the simplest case, the query includes the same condition as the index.</p>
<pre><code class="language-sql">CREATE INDEX idx_orders_pending ON orders(customer_id)
  WHERE status = 'pending';
-- Only rows with status = 'pending' are indexed.
</code></pre>
<h3 id="expression-indexes"><a class="header" href="#expression-indexes">Expression Indexes</a></h3>
<p>Instead of a plain column name, an indexed column entry may be a parenthesized expression. This is useful for indexing computed values, such as the lowercase version of a text column.</p>
<p>Expression indexes have the following restrictions:</p>
<ul>
<li>The expression may not reference other tables.</li>
<li>The expression may not contain subqueries.</li>
<li>The expression may only use deterministic functions (not <code>random()</code>, <code>last_insert_rowid()</code>, etc.).</li>
</ul>
<pre><code class="language-sql">CREATE INDEX idx_users_email_lower ON users(lower(email));
-- Speeds up queries like: SELECT * FROM users WHERE lower(email) = 'alice@example.com';
</code></pre>
<h2 id="examples-13"><a class="header" href="#examples-13">Examples</a></h2>
<h3 id="basic-single-column-index"><a class="header" href="#basic-single-column-index">Basic single-column index</a></h3>
<pre><code class="language-sql">CREATE TABLE employees (
  id INTEGER PRIMARY KEY,
  name TEXT,
  department TEXT,
  salary REAL
);

CREATE INDEX idx_employees_name ON employees(name);
</code></pre>
<h3 id="unique-index"><a class="header" href="#unique-index">Unique index</a></h3>
<pre><code class="language-sql">CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  email TEXT NOT NULL
);

CREATE UNIQUE INDEX idx_users_email ON users(email);

INSERT INTO users VALUES (1, 'alice@example.com');
INSERT INTO users VALUES (2, 'bob@example.com');
-- INSERT INTO users VALUES (3, 'alice@example.com');
-- Error: UNIQUE constraint failed: users.email
</code></pre>
<h3 id="multi-column-index"><a class="header" href="#multi-column-index">Multi-column index</a></h3>
<pre><code class="language-sql">CREATE TABLE shipments (
  id INTEGER PRIMARY KEY,
  customer_id INTEGER,
  city TEXT,
  state TEXT,
  zip TEXT
);

CREATE INDEX idx_shipments_location ON shipments(state, city, zip);
-- Useful for queries that filter by state, or by state + city, or by all three.
</code></pre>
<h3 id="index-with-asc-and-desc"><a class="header" href="#index-with-asc-and-desc">Index with ASC and DESC</a></h3>
<pre><code class="language-sql">CREATE TABLE transactions (
  id INTEGER PRIMARY KEY,
  account_id INTEGER,
  created_at TEXT,
  amount REAL
);

CREATE INDEX idx_transactions_recent ON transactions(account_id, created_at DESC);

INSERT INTO transactions VALUES (1, 100, '2025-01-15', 250.00);
INSERT INTO transactions VALUES (2, 100, '2025-03-20', 75.00);
INSERT INTO transactions VALUES (3, 100, '2025-06-01', 300.00);

-- The index stores rows per account with the most recent date first.
SELECT created_at, amount FROM transactions
  WHERE account_id = 100
  ORDER BY created_at DESC;
-- 2025-06-01|300.0
-- 2025-03-20|75.0
-- 2025-01-15|250.0
</code></pre>
<h3 id="partial-index"><a class="header" href="#partial-index">Partial index</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer_id INTEGER,
  status TEXT,
  amount REAL
);

CREATE INDEX idx_orders_pending ON orders(customer_id, amount)
  WHERE status = 'pending';

INSERT INTO orders VALUES (1, 10, 'pending', 99.99);
INSERT INTO orders VALUES (2, 10, 'shipped', 149.99);
INSERT INTO orders VALUES (3, 20, 'pending', 49.99);

-- This query can use the partial index because its WHERE clause
-- includes the index's condition.
SELECT id, customer_id, amount FROM orders
  WHERE status = 'pending'
  ORDER BY amount DESC;
-- 1|10|99.99
-- 3|20|49.99
</code></pre>
<h3 id="expression-index"><a class="header" href="#expression-index">Expression index</a></h3>
<pre><code class="language-sql">CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  first_name TEXT,
  last_name TEXT,
  email TEXT
);

CREATE INDEX idx_users_email_lower ON users(lower(email));

INSERT INTO users VALUES (1, 'Alice', 'Smith', 'Alice@Example.COM');
INSERT INTO users VALUES (2, 'Bob', 'Jones', 'bob@example.com');

-- The expression index speeds up case-insensitive email lookups.
SELECT first_name, email FROM users
  WHERE lower(email) = 'alice@example.com';
-- Alice|Alice@Example.COM
</code></pre>
<h3 id="collation-in-an-index"><a class="header" href="#collation-in-an-index">Collation in an index</a></h3>
<pre><code class="language-sql">CREATE TABLE contacts (
  id INTEGER PRIMARY KEY,
  first_name TEXT,
  last_name TEXT
);

CREATE INDEX idx_contacts_fullname
  ON contacts(first_name COLLATE NOCASE, last_name COLLATE NOCASE);
-- Queries using case-insensitive comparisons on these columns can use this index.
</code></pre>
<h3 id="if-not-exists-1-1"><a class="header" href="#if-not-exists-1-1">IF NOT EXISTS</a></h3>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  category TEXT,
  price REAL
);

CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);
-- Running the same statement again does not produce an error.
CREATE INDEX IF NOT EXISTS idx_products_name ON products(name);
</code></pre>
<h3 id="dropping-an-index"><a class="header" href="#dropping-an-index">Dropping an index</a></h3>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price REAL
);

CREATE INDEX idx_products_name ON products(name);

-- Remove the index
DROP INDEX idx_products_name;

-- Safe to run even if the index does not exist
DROP INDEX IF EXISTS idx_products_name;
</code></pre>
<h3 id="null-values-in-a-unique-index"><a class="header" href="#null-values-in-a-unique-index">NULL values in a unique index</a></h3>
<pre><code class="language-sql">CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  email TEXT
);

CREATE UNIQUE INDEX idx_users_email ON users(email);

-- Multiple NULLs are allowed because NULL values are considered distinct.
INSERT INTO users VALUES (1, NULL);
INSERT INTO users VALUES (2, NULL);

SELECT * FROM users;
-- 1|
-- 2|
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="create-view"><a class="header" href="#create-view">CREATE VIEW</a></h1>
<h2 id="syntax-14"><a class="header" href="#syntax-14">Syntax</a></h2>
<pre><code class="language-sql">CREATE [TEMP | TEMPORARY] VIEW [IF NOT EXISTS] view-name
  AS select-stmt
</code></pre>
<pre><code class="language-sql">DROP VIEW [IF EXISTS] view-name
</code></pre>
<h2 id="description-14"><a class="header" href="#description-14">Description</a></h2>
<p>The CREATE VIEW statement assigns a name to a pre-packaged SELECT statement.
Once created, a view can be used anywhere a table name is accepted in the FROM
clause of a SELECT: in simple queries, JOINs, subqueries, and even in the
definitions of other views.</p>
<p>Views are read-only. You cannot use INSERT, UPDATE, or DELETE on a view. A view
does not store data; every time it is referenced in a query, Turso expands it
into the underlying SELECT and executes it against the current table data. This
means the results of a view always reflect the latest state of the base tables.</p>
<p>The DROP VIEW statement removes a view definition from the database. It has no
effect on the underlying tables or their data.</p>
<h2 id="clauses-11"><a class="header" href="#clauses-11">Clauses</a></h2>
<h3 id="as-select-stmt"><a class="header" href="#as-select-stmt">AS select-stmt</a></h3>
<p>The AS keyword is followed by any valid SELECT statement. This SELECT defines
what the view returns when queried. The column names of the view are derived
from the result columns of the SELECT. Use the <code>AS</code> alias syntax in the SELECT
to give view columns well-defined names, particularly when the result includes
expressions or function calls.</p>
<pre><code class="language-sql">-- Without aliases, computed columns get auto-generated names
CREATE VIEW order_stats AS
  SELECT customer_id, COUNT(*), SUM(amount)
  FROM orders
  GROUP BY customer_id;

-- With aliases, column names are explicit and predictable
CREATE VIEW order_stats AS
  SELECT customer_id,
         COUNT(*) AS order_count,
         SUM(amount) AS total_spent
  FROM orders
  GROUP BY customer_id;
</code></pre>
<h3 id="temp--temporary"><a class="header" href="#temp--temporary">TEMP / TEMPORARY</a></h3>
<p>If the <code>TEMP</code> or <code>TEMPORARY</code> keyword appears between <code>CREATE</code> and <code>VIEW</code>, the
view is only visible to the current database connection and is automatically
deleted when the connection is closed. Temporary views are useful for
intermediate results within a session.</p>
<pre><code class="language-sql">CREATE TEMP VIEW recent_orders AS
  SELECT * FROM orders WHERE created_at &gt; '2024-01-01';
</code></pre>
<h3 id="if-not-exists-3"><a class="header" href="#if-not-exists-3">IF NOT EXISTS</a></h3>
<p>When <code>IF NOT EXISTS</code> is included, the statement does not produce a fatal error
if a view with the same name already exists. Without this clause, attempting to
create a view that already exists raises an error.</p>
<h3 id="if-exists-drop-view"><a class="header" href="#if-exists-drop-view">IF EXISTS (DROP VIEW)</a></h3>
<p>When <code>IF EXISTS</code> is included in a DROP VIEW statement, no error is raised if
the named view does not exist. Without this clause, dropping a nonexistent view
produces an error.</p>
<pre><code class="language-sql">-- Safe to run even if the view does not exist
DROP VIEW IF EXISTS old_report;
</code></pre>
<h2 id="examples-14"><a class="header" href="#examples-14">Examples</a></h2>
<h3 id="basic-view"><a class="header" href="#basic-view">Basic view</a></h3>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price REAL,
  category TEXT
);

INSERT INTO products VALUES (1, 'Laptop', 999.99, 'Electronics');
INSERT INTO products VALUES (2, 'Headphones', 49.99, 'Electronics');
INSERT INTO products VALUES (3, 'Notebook', 5.99, 'Office');
INSERT INTO products VALUES (4, 'Pen', 1.99, 'Office');

-- Create a view that filters to one category
CREATE VIEW electronics AS
  SELECT id, name, price
  FROM products
  WHERE category = 'Electronics';

SELECT * FROM electronics;
-- 1|Laptop|999.99
-- 2|Headphones|49.99
</code></pre>
<h3 id="view-with-computed-columns"><a class="header" href="#view-with-computed-columns">View with computed columns</a></h3>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price REAL,
  quantity INTEGER
);

INSERT INTO products VALUES (1, 'Laptop', 999.99, 5);
INSERT INTO products VALUES (2, 'Mouse', 29.99, 50);

CREATE VIEW inventory_value AS
  SELECT name, price, quantity, price * quantity AS total_value
  FROM products;

SELECT * FROM inventory_value;
-- Laptop|999.99|5|4999.95
-- Mouse|29.99|50|1499.5
</code></pre>
<h3 id="view-with-aggregation"><a class="header" href="#view-with-aggregation">View with aggregation</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer_id INTEGER,
  product TEXT,
  amount REAL
);

INSERT INTO orders VALUES (1, 10, 'Laptop', 999.99);
INSERT INTO orders VALUES (2, 10, 'Mouse', 29.99);
INSERT INTO orders VALUES (3, 20, 'Keyboard', 79.99);
INSERT INTO orders VALUES (4, 20, 'Monitor', 399.99);
INSERT INTO orders VALUES (5, 20, 'Cable', 9.99);

CREATE VIEW customer_totals AS
  SELECT customer_id,
         COUNT(*) AS order_count,
         SUM(amount) AS total_spent
  FROM orders
  GROUP BY customer_id;

SELECT * FROM customer_totals;
-- 10|2|1029.98
-- 20|3|489.97
</code></pre>
<h3 id="view-with-a-join"><a class="header" href="#view-with-a-join">View with a JOIN</a></h3>
<pre><code class="language-sql">CREATE TABLE customers (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE orders (id INTEGER PRIMARY KEY, customer_id INTEGER, amount REAL);

INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
INSERT INTO orders VALUES (1, 1, 100.00);
INSERT INTO orders VALUES (2, 1, 200.00);
INSERT INTO orders VALUES (3, 2, 150.00);

CREATE VIEW order_details AS
  SELECT c.name, o.amount
  FROM customers c
  JOIN orders o ON c.id = o.customer_id;

SELECT * FROM order_details;
-- Alice|100.0
-- Alice|200.0
-- Bob|150.0
</code></pre>
<h3 id="querying-a-view-with-additional-clauses"><a class="header" href="#querying-a-view-with-additional-clauses">Querying a view with additional clauses</a></h3>
<p>A view can be used just like a table in a SELECT. You can apply WHERE, ORDER
BY, LIMIT, and any other clause on top of it.</p>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price REAL,
  category TEXT
);

INSERT INTO products VALUES (1, 'Laptop', 999.99, 'Electronics');
INSERT INTO products VALUES (2, 'Mouse', 29.99, 'Electronics');
INSERT INTO products VALUES (3, 'Notebook', 5.99, 'Office');

CREATE VIEW electronics AS
  SELECT id, name, price
  FROM products
  WHERE category = 'Electronics';

-- Filter the view further
SELECT * FROM electronics WHERE price &gt; 50;
-- 1|Laptop|999.99

-- Sort the view results
SELECT * FROM electronics ORDER BY price DESC;
-- 1|Laptop|999.99
-- 2|Mouse|29.99
</code></pre>
<h3 id="joining-a-table-with-a-view"><a class="header" href="#joining-a-table-with-a-view">Joining a table with a view</a></h3>
<pre><code class="language-sql">CREATE TABLE customers (id INTEGER PRIMARY KEY, name TEXT);
CREATE TABLE orders (id INTEGER PRIMARY KEY, customer_id INTEGER, amount REAL);

INSERT INTO customers VALUES (1, 'Alice');
INSERT INTO customers VALUES (2, 'Bob');
INSERT INTO orders VALUES (1, 1, 100.00);
INSERT INTO orders VALUES (2, 1, 200.00);
INSERT INTO orders VALUES (3, 2, 150.00);

CREATE VIEW customer_totals AS
  SELECT customer_id, SUM(amount) AS total
  FROM orders
  GROUP BY customer_id;

SELECT c.name, ct.total
  FROM customers c
  JOIN customer_totals ct ON c.id = ct.customer_id
  ORDER BY ct.total DESC;
-- Alice|300.0
-- Bob|150.0
</code></pre>
<h3 id="view-referencing-another-view"><a class="header" href="#view-referencing-another-view">View referencing another view</a></h3>
<p>Views can be built on top of other views.</p>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price REAL,
  category TEXT
);

INSERT INTO products VALUES (1, 'Laptop', 999.99, 'Electronics');
INSERT INTO products VALUES (2, 'Mouse', 29.99, 'Electronics');
INSERT INTO products VALUES (3, 'Notebook', 5.99, 'Office');

CREATE VIEW electronics AS
  SELECT id, name, price
  FROM products
  WHERE category = 'Electronics';

CREATE VIEW expensive_electronics AS
  SELECT * FROM electronics WHERE price &gt; 100;

SELECT * FROM expensive_electronics;
-- 1|Laptop|999.99
</code></pre>
<h3 id="using-a-view-in-a-subquery"><a class="header" href="#using-a-view-in-a-subquery">Using a view in a subquery</a></h3>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  price REAL,
  category TEXT
);

INSERT INTO products VALUES (1, 'Laptop', 999.99, 'Electronics');
INSERT INTO products VALUES (2, 'Mouse', 29.99, 'Electronics');
INSERT INTO products VALUES (3, 'Notebook', 5.99, 'Office');

CREATE VIEW electronics AS
  SELECT id, name, price
  FROM products
  WHERE category = 'Electronics';

SELECT name FROM products WHERE id IN (SELECT id FROM electronics);
-- Laptop
-- Mouse
</code></pre>
<h3 id="temporary-view"><a class="header" href="#temporary-view">Temporary view</a></h3>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL);

INSERT INTO products VALUES (1, 'Laptop', 999.99);
INSERT INTO products VALUES (2, 'Pen', 1.99);

CREATE TEMP VIEW cheap_products AS
  SELECT id, name, price
  FROM products
  WHERE price &lt; 100;

SELECT * FROM cheap_products;
-- 2|Pen|1.99
</code></pre>
<h3 id="dropping-a-view"><a class="header" href="#dropping-a-view">Dropping a view</a></h3>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT);
CREATE VIEW all_products AS SELECT * FROM products;

-- Drop the view
DROP VIEW all_products;

-- Safe to run even if the view does not exist
DROP VIEW IF EXISTS all_products;
</code></pre>
<h3 id="views-are-read-only"><a class="header" href="#views-are-read-only">Views are read-only</a></h3>
<p>Attempting to INSERT, UPDATE, or DELETE against a view produces an error.</p>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL);
INSERT INTO products VALUES (1, 'Laptop', 999.99);

CREATE VIEW all_products AS SELECT * FROM products;

-- All of the following produce errors:
-- INSERT INTO all_products VALUES (2, 'Mouse', 29.99);
-- UPDATE all_products SET price = 500 WHERE id = 1;
-- DELETE FROM all_products WHERE id = 1;
</code></pre>
<h2 id="compatibility-10"><a class="header" href="#compatibility-10">Compatibility</a></h2>
<p>Turso supports CREATE VIEW with the same syntax as SQLite, with the following
notes:</p>
<ul>
<li>
<p><strong>Column name list</strong>: The parenthesized column name list after the view name
(e.g., <code>CREATE VIEW v(a, b) AS SELECT ...</code>) is parsed but the specified
column names are not applied to the view output. Use <code>AS</code> aliases in the
SELECT statement instead to control column names.</p>
</li>
<li>
<p><strong>IF NOT EXISTS</strong>: The <code>IF NOT EXISTS</code> clause is accepted by the parser. When
a view with the same name already exists, a diagnostic message is emitted but
execution continues.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="create-trigger"><a class="header" href="#create-trigger">CREATE TRIGGER</a></h1>
<h2 id="syntax-15"><a class="header" href="#syntax-15">Syntax</a></h2>
<pre><code class="language-sql">CREATE TRIGGER [IF NOT EXISTS] trigger-name
  [BEFORE | AFTER] {DELETE | INSERT | UPDATE [OF column-name [, ...]]}
  ON table-name
  [FOR EACH ROW]
  [WHEN expr]
BEGIN
  statement; [statement; ...]
END;
</code></pre>
<h2 id="description-15"><a class="header" href="#description-15">Description</a></h2>
<p>The <code>CREATE TRIGGER</code> statement defines a trigger – a set of SQL statements that automatically execute in response to <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> operations on a specified table. Triggers are useful for enforcing business rules, maintaining audit logs, synchronizing related tables, and computing derived values.</p>
<p>Turso supports <code>BEFORE</code> and <code>AFTER</code> triggers on tables. Each trigger fires once per affected row (FOR EACH ROW semantics). The trigger body can contain one or more <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, or <code>SELECT</code> statements, which execute as part of the same transaction as the triggering statement.</p>
<p>Triggers require the <code>--experimental-triggers</code> flag when starting the Turso CLI.</p>
<h2 id="clauses-12"><a class="header" href="#clauses-12">Clauses</a></h2>
<h3 id="trigger-timing"><a class="header" href="#trigger-timing">Trigger Timing</a></h3>
<p>The optional timing keyword controls when the trigger body executes relative to the triggering operation.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Timing</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>BEFORE</code></td><td>Executes before the row is modified. Default if no timing is specified.</td></tr>
<tr><td><code>AFTER</code></td><td>Executes after the row has been modified.</td></tr>
</tbody>
</table>
</div>
<p>When no timing keyword is provided, <code>BEFORE</code> is used by default.</p>
<h3 id="trigger-event"><a class="header" href="#trigger-event">Trigger Event</a></h3>
<p>The event determines which data modification operation causes the trigger to fire.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Event</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>INSERT</code></td><td>Fires when a new row is inserted into the table.</td></tr>
<tr><td><code>UPDATE</code></td><td>Fires when any column of a row is updated.</td></tr>
<tr><td><code>UPDATE OF column-name [, ...]</code></td><td>Fires only when one of the specified columns appears in the <code>SET</code> clause of an <code>UPDATE</code> statement.</td></tr>
<tr><td><code>DELETE</code></td><td>Fires when a row is deleted from the table.</td></tr>
</tbody>
</table>
</div>
<p>For <code>UPDATE OF</code>, the trigger fires based on which columns appear in the <code>SET</code> clause, not on whether the column value actually changes. Column names that do not exist in the table are silently ignored.</p>
<h3 id="for-each-row"><a class="header" href="#for-each-row">FOR EACH ROW</a></h3>
<p>Turso supports only row-level triggers. The <code>FOR EACH ROW</code> clause is optional and has no effect – row-level semantics are always used. The trigger body executes once for each row affected by the triggering statement.</p>
<h3 id="when"><a class="header" href="#when">WHEN</a></h3>
<p>The optional <code>WHEN</code> clause provides a condition that is evaluated for each row. If the condition evaluates to false or NULL, the trigger body is skipped for that row. The <code>WHEN</code> expression can reference <code>NEW</code> and <code>OLD</code> row values (see below).</p>
<h3 id="new-and-old-references"><a class="header" href="#new-and-old-references">NEW and OLD References</a></h3>
<p>Inside a trigger body and <code>WHEN</code> clause, the special table references <code>NEW</code> and <code>OLD</code> provide access to the row values being modified.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Event</th><th><code>NEW</code></th><th><code>OLD</code></th></tr>
</thead>
<tbody>
<tr><td><code>INSERT</code></td><td>The row being inserted.</td><td>Not available.</td></tr>
<tr><td><code>UPDATE</code></td><td>The row after the update.</td><td>The row before the update.</td></tr>
<tr><td><code>DELETE</code></td><td>Not available.</td><td>The row being deleted.</td></tr>
</tbody>
</table>
</div>
<p>Use dot notation to reference individual columns: <code>NEW.column_name</code> or <code>OLD.column_name</code>. Both <code>NEW.rowid</code> and named rowid aliases (e.g., <code>NEW.id</code> for an <code>INTEGER PRIMARY KEY</code> column) are supported.</p>
<h3 id="if-not-exists-4"><a class="header" href="#if-not-exists-4">IF NOT EXISTS</a></h3>
<p>When <code>IF NOT EXISTS</code> is included, Turso silently does nothing if a trigger with the same name already exists. Without this clause, attempting to create a trigger whose name is already in use results in an error.</p>
<h3 id="trigger-body"><a class="header" href="#trigger-body">Trigger Body</a></h3>
<p>The trigger body is enclosed between <code>BEGIN</code> and <code>END</code> and contains one or more SQL statements, each terminated by a semicolon. The supported statement types are:</p>
<ul>
<li><code>INSERT</code></li>
<li><code>UPDATE</code></li>
<li><code>DELETE</code></li>
<li><code>SELECT</code></li>
</ul>
<p>All statements in the trigger body execute within the same transaction as the triggering statement. If any statement in the trigger body fails, the entire triggering operation is rolled back.</p>
<h2 id="trigger-execution-order"><a class="header" href="#trigger-execution-order">Trigger Execution Order</a></h2>
<p>When multiple triggers are defined on the same table for the same event and timing, they fire in reverse order of creation (last created fires first).</p>
<h2 id="nested-and-recursive-triggers"><a class="header" href="#nested-and-recursive-triggers">Nested and Recursive Triggers</a></h2>
<p>A trigger’s body can cause other triggers to fire. For example, an <code>AFTER INSERT</code> trigger on table A that inserts into table B will fire any insert triggers on table B.</p>
<p>Triggers can also be recursive – a trigger can modify the same table that caused it to fire. However, recursive triggers do not fire recursively by default; a trigger that fires once will not fire itself again in the same chain. This means a recursive <code>AFTER INSERT</code> trigger that inserts into the same table will execute at most one additional level.</p>
<h2 id="trigger-lifecycle"><a class="header" href="#trigger-lifecycle">Trigger Lifecycle</a></h2>
<p>Triggers are automatically dropped when the table they are attached to is dropped. To manually remove a trigger, use <code>DROP TRIGGER</code>:</p>
<pre><code class="language-sql">DROP TRIGGER [IF EXISTS] trigger-name;
</code></pre>
<h2 id="examples-15"><a class="header" href="#examples-15">Examples</a></h2>
<h3 id="audit-log-with-after-insert"><a class="header" href="#audit-log-with-after-insert">Audit Log with AFTER INSERT</a></h3>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL);
CREATE TABLE audit_log (id INTEGER PRIMARY KEY, action TEXT, product_name TEXT);

-- Log every new product insertion
CREATE TRIGGER log_product_insert AFTER INSERT ON products
BEGIN
  INSERT INTO audit_log (action, product_name) VALUES ('INSERT', NEW.name);
END;

INSERT INTO products (name, price) VALUES ('Laptop', 999.99);
INSERT INTO products (name, price) VALUES ('Mouse', 29.99);

SELECT * FROM audit_log;
-- 1|INSERT|Laptop
-- 2|INSERT|Mouse
</code></pre>
<h3 id="tracking-changes-with-old-and-new"><a class="header" href="#tracking-changes-with-old-and-new">Tracking Changes with OLD and NEW</a></h3>
<pre><code class="language-sql">CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, salary REAL);
CREATE TABLE salary_changes (id INTEGER PRIMARY KEY, old_salary REAL, new_salary REAL);

CREATE TRIGGER log_salary_update AFTER UPDATE ON employees
BEGIN
  INSERT INTO salary_changes (old_salary, new_salary)
    VALUES (OLD.salary, NEW.salary);
END;

INSERT INTO employees VALUES (1, 'Alice', 75000.0);
UPDATE employees SET salary = 80000.0 WHERE id = 1;

SELECT * FROM salary_changes;
-- 1|75000.0|80000.0
</code></pre>
<h3 id="archiving-deleted-rows-with-before-delete"><a class="header" href="#archiving-deleted-rows-with-before-delete">Archiving Deleted Rows with BEFORE DELETE</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (id INTEGER PRIMARY KEY, customer TEXT, total REAL);
CREATE TABLE deleted_orders (id INTEGER PRIMARY KEY, customer TEXT, total REAL);

CREATE TRIGGER archive_deleted_order BEFORE DELETE ON orders
BEGIN
  INSERT INTO deleted_orders (id, customer, total) VALUES (OLD.id, OLD.customer, OLD.total);
END;

INSERT INTO orders VALUES (1, 'Bob', 150.00);
INSERT INTO orders VALUES (2, 'Carol', 250.00);
DELETE FROM orders WHERE customer = 'Bob';

SELECT * FROM deleted_orders;
-- 1|Bob|150.0
</code></pre>
<h3 id="conditional-trigger-with-when-clause"><a class="header" href="#conditional-trigger-with-when-clause">Conditional Trigger with WHEN Clause</a></h3>
<pre><code class="language-sql">CREATE TABLE sensor_readings (id INTEGER PRIMARY KEY, value INTEGER);
CREATE TABLE alerts (id INTEGER PRIMARY KEY, reading_id INTEGER);

-- Only log an alert when the reading exceeds a threshold
CREATE TRIGGER high_value_alert AFTER INSERT ON sensor_readings
WHEN NEW.value &gt; 100
BEGIN
  INSERT INTO alerts (reading_id) VALUES (NEW.id);
END;

INSERT INTO sensor_readings VALUES (1, 50);
INSERT INTO sensor_readings VALUES (2, 150);
INSERT INTO sensor_readings VALUES (3, 75);

SELECT * FROM alerts;
-- 1|2
</code></pre>
<h3 id="update-of-specific-columns"><a class="header" href="#update-of-specific-columns">UPDATE OF Specific Columns</a></h3>
<pre><code class="language-sql">CREATE TABLE accounts (id INTEGER PRIMARY KEY, email TEXT, password_hash TEXT);
CREATE TABLE security_log (id INTEGER PRIMARY KEY, msg TEXT);

-- Only fire when the password column is updated
CREATE TRIGGER log_password_change AFTER UPDATE OF password_hash ON accounts
BEGIN
  INSERT INTO security_log (msg) VALUES ('password changed for account ' || NEW.id);
END;

INSERT INTO accounts VALUES (1, 'alice@example.com', 'hash1');
UPDATE accounts SET email = 'alice-new@example.com' WHERE id = 1;
UPDATE accounts SET password_hash = 'hash2' WHERE id = 1;

SELECT * FROM security_log;
-- 1|password changed for account 1
</code></pre>
<h3 id="multiple-statements-in-trigger-body"><a class="header" href="#multiple-statements-in-trigger-body">Multiple Statements in Trigger Body</a></h3>
<pre><code class="language-sql">CREATE TABLE inventory (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER);
CREATE TABLE restock_log (id INTEGER PRIMARY KEY, product TEXT);
CREATE TABLE quantity_log (id INTEGER PRIMARY KEY, product TEXT, qty INTEGER);

CREATE TRIGGER track_inventory AFTER INSERT ON inventory
BEGIN
  INSERT INTO restock_log (product) VALUES (NEW.product);
  INSERT INTO quantity_log (product, qty) VALUES (NEW.product, NEW.quantity);
END;

INSERT INTO inventory VALUES (1, 'Widget', 100);

SELECT * FROM restock_log;
-- 1|Widget
SELECT * FROM quantity_log;
-- 1|Widget|100
</code></pre>
<h3 id="cascading-triggers-across-tables"><a class="header" href="#cascading-triggers-across-tables">Cascading Triggers Across Tables</a></h3>
<pre><code class="language-sql">CREATE TABLE departments (id INTEGER PRIMARY KEY, budget INTEGER);
CREATE TABLE projects (id INTEGER PRIMARY KEY, dept_id INTEGER, cost INTEGER);
CREATE TABLE notifications (id INTEGER PRIMARY KEY, msg TEXT);

INSERT INTO departments VALUES (1, 50000);

-- When a project is added, update department budget
CREATE TRIGGER deduct_budget AFTER INSERT ON projects
BEGIN
  UPDATE departments SET budget = budget - NEW.cost WHERE id = NEW.dept_id;
END;

-- When budget changes, log a notification
CREATE TRIGGER budget_notification AFTER UPDATE ON departments
BEGIN
  INSERT INTO notifications (msg) VALUES ('budget updated: ' || NEW.budget);
END;

INSERT INTO projects VALUES (1, 1, 10000);

SELECT * FROM departments;
-- 1|40000
SELECT * FROM notifications;
-- 1|budget updated: 40000
</code></pre>
<h3 id="complex-when-clause"><a class="header" href="#complex-when-clause">Complex WHEN Clause</a></h3>
<pre><code class="language-sql">CREATE TABLE transactions (id INTEGER PRIMARY KEY, amount INTEGER, status TEXT DEFAULT 'pending');

-- Automatically mark large transactions as requiring review
CREATE TRIGGER flag_large_transactions AFTER INSERT ON transactions
WHEN NEW.amount &gt; 500 AND NEW.amount &lt; 10000
BEGIN
  UPDATE transactions SET status = 'review' WHERE id = NEW.id;
END;

INSERT INTO transactions (id, amount) VALUES (1, 100);
INSERT INTO transactions (id, amount) VALUES (2, 750);
INSERT INTO transactions (id, amount) VALUES (3, 50000);

SELECT * FROM transactions ORDER BY id;
-- 1|100|pending
-- 2|750|review
-- 3|50000|pending
</code></pre>
<h3 id="if-not-exists-1-2"><a class="header" href="#if-not-exists-1-2">IF NOT EXISTS</a></h3>
<pre><code class="language-sql">CREATE TABLE events (id INTEGER PRIMARY KEY, name TEXT);

CREATE TRIGGER IF NOT EXISTS log_event BEFORE INSERT ON events
BEGIN
  SELECT 1;
END;

-- This does not produce an error because of IF NOT EXISTS
CREATE TRIGGER IF NOT EXISTS log_event BEFORE INSERT ON events
BEGIN
  SELECT 1;
END;

SELECT name FROM sqlite_schema WHERE type = 'trigger' AND name = 'log_event';
-- log_event
</code></pre>
<h2 id="compatibility-11"><a class="header" href="#compatibility-11">Compatibility</a></h2>
<ul>
<li>Triggers are an experimental feature and require the <code>--experimental-triggers</code> flag.</li>
<li><code>INSTEAD OF</code> triggers (used with views) are not yet supported.</li>
<li><code>TEMPORARY</code> triggers are not yet supported.</li>
<li>The <code>RAISE()</code> function is not supported within trigger bodies.</li>
<li>Recursive triggers are limited to a single additional level of recursion by default.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="alter-table"><a class="header" href="#alter-table">ALTER TABLE</a></h1>
<h2 id="syntax-16"><a class="header" href="#syntax-16">Syntax</a></h2>
<pre><code class="language-sql">ALTER TABLE table-name RENAME TO new-table-name
</code></pre>
<pre><code class="language-sql">ALTER TABLE table-name RENAME [COLUMN] column-name TO new-column-name
</code></pre>
<pre><code class="language-sql">ALTER TABLE table-name ADD [COLUMN] column-def
</code></pre>
<pre><code class="language-sql">ALTER TABLE table-name DROP [COLUMN] column-name
</code></pre>
<pre><code class="language-sql">ALTER TABLE table-name ALTER COLUMN column-name TO column-def
</code></pre>
<h2 id="description-16"><a class="header" href="#description-16">Description</a></h2>
<p>The <code>ALTER TABLE</code> statement modifies the schema of an existing table. Turso supports five operations: renaming a table, renaming a column, adding a column, dropping a column, and altering a column definition. Unlike <code>CREATE TABLE</code>, <code>ALTER TABLE</code> works on tables that already exist and may already contain data.</p>
<p>Each operation modifies the table’s schema entry in <code>sqlite_schema</code>. Renaming and adding columns are fast operations whose execution time is independent of the number of rows. Dropping a column rewrites the table data and is proportional to table size.</p>
<p>System tables (those with names beginning with <code>sqlite_</code>) cannot be altered.</p>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<h3 id="rename-to"><a class="header" href="#rename-to">RENAME TO</a></h3>
<p>Renames the table from <code>table-name</code> to <code>new-table-name</code>. The new name must not collide with any existing table, view, or index name. The table cannot be moved between attached databases – it is only renamed within its current database.</p>
<p>References to the table in triggers, views, and foreign key constraints are automatically updated to use the new name, including self-referencing foreign keys.</p>
<pre><code class="language-sql">CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT);
ALTER TABLE employees RENAME TO staff;
SELECT name FROM sqlite_schema WHERE type = 'table';
-- staff
</code></pre>
<h3 id="rename-column"><a class="header" href="#rename-column">RENAME COLUMN</a></h3>
<p>Renames an existing column from <code>column-name</code> to <code>new-column-name</code>. The <code>COLUMN</code> keyword is optional. All references to the column in indexes, triggers, views, and foreign key constraints (both child and parent sides) are automatically updated.</p>
<p>If the rename would introduce a semantic ambiguity in a trigger or view, the operation fails and no changes are applied.</p>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, product_name TEXT NOT NULL, price REAL);
ALTER TABLE products RENAME COLUMN product_name TO name;
SELECT sql FROM sqlite_schema WHERE name = 'products';
-- CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT NOT NULL, price REAL)
</code></pre>
<p>Renaming a column that participates in a foreign key constraint updates both sides of the relationship:</p>
<pre><code class="language-sql">PRAGMA foreign_keys = ON;
CREATE TABLE orders (order_id INTEGER PRIMARY KEY, date TEXT);
CREATE TABLE items (item_id INTEGER PRIMARY KEY, oid INTEGER,
  FOREIGN KEY (oid) REFERENCES orders(order_id));

ALTER TABLE orders RENAME COLUMN order_id TO ord_id;

SELECT sql FROM sqlite_schema WHERE name = 'items';
-- CREATE TABLE items (item_id INTEGER PRIMARY KEY, oid INTEGER, FOREIGN KEY (oid) REFERENCES orders (ord_id))
</code></pre>
<h3 id="add-column"><a class="header" href="#add-column">ADD COLUMN</a></h3>
<p>Appends a new column to the end of the table’s column list. The <code>COLUMN</code> keyword is optional. The <code>column-def</code> follows the same syntax as a column definition in <code>CREATE TABLE</code>, including an optional type name, <code>DEFAULT</code>, <code>NOT NULL</code>, <code>CHECK</code>, <code>COLLATE</code>, and <code>REFERENCES</code> clauses.</p>
<pre><code class="language-sql">CREATE TABLE orders (id INTEGER PRIMARY KEY, customer_id INTEGER);
ALTER TABLE orders ADD COLUMN total_amount REAL DEFAULT 0.0;
ALTER TABLE orders ADD COLUMN status TEXT DEFAULT 'pending';
SELECT sql FROM sqlite_schema WHERE name = 'orders';
-- CREATE TABLE orders (id INTEGER PRIMARY KEY, customer_id INTEGER, total_amount REAL DEFAULT 0.0, status TEXT DEFAULT 'pending')
</code></pre>
<h4 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h4>
<p>The new column may not have:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Restriction</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>PRIMARY KEY</code> or <code>UNIQUE</code> constraint</td><td>Would require rewriting existing data and indexes.</td></tr>
<tr><td>A non-constant default expression</td><td>The default must be a literal, a signed literal, or a parenthesized constant. Expressions like <code>(NULL + 5)</code> are rejected.</td></tr>
<tr><td><code>NOT NULL</code> without a non-null default (when the table has rows)</td><td>Existing rows would have NULL for the new column, violating the constraint.</td></tr>
<tr><td><code>CURRENT_TIME</code>, <code>CURRENT_DATE</code>, or <code>CURRENT_TIMESTAMP</code> as default (when the table has rows)</td><td>These are non-deterministic and cannot be used to backfill existing rows.</td></tr>
<tr><td><code>GENERATED ALWAYS ... STORED</code> or <code>AS (expr)</code></td><td>Adding generated columns via <code>ALTER TABLE</code> is not supported.</td></tr>
</tbody>
</table>
</div>
<p>A <code>NOT NULL</code> column without a default value is permitted if the table is empty:</p>
<pre><code class="language-sql">CREATE TABLE contacts (id INTEGER PRIMARY KEY);
ALTER TABLE contacts ADD name TEXT NOT NULL;
SELECT sql FROM sqlite_schema WHERE type = 'table' AND name = 'contacts';
-- CREATE TABLE contacts (id INTEGER PRIMARY KEY, name TEXT NOT NULL)
</code></pre>
<p>A <code>NOT NULL</code> column with a non-null default succeeds even on tables with existing rows:</p>
<pre><code class="language-sql">CREATE TABLE tasks (id INTEGER PRIMARY KEY);
INSERT INTO tasks VALUES (1);
ALTER TABLE tasks ADD priority INTEGER NOT NULL DEFAULT 5;
INSERT INTO tasks (id) VALUES (2);
SELECT * FROM tasks ORDER BY id;
-- 1|5
-- 2|5
</code></pre>
<p>Adding a column with a foreign key reference is supported and updates the schema to include a table-level <code>FOREIGN KEY</code> clause:</p>
<pre><code class="language-sql">CREATE TABLE departments (id INTEGER PRIMARY KEY);
CREATE TABLE staff (id INTEGER PRIMARY KEY);
ALTER TABLE staff ADD COLUMN dept_id REFERENCES departments(id);
SELECT sql FROM sqlite_schema WHERE name = 'staff';
-- CREATE TABLE staff (id INTEGER PRIMARY KEY, dept_id, FOREIGN KEY (dept_id) REFERENCES departments(id))
</code></pre>
<p>Duplicate column names are rejected (case-insensitive):</p>
<pre><code class="language-sql">CREATE TABLE items (name TEXT);
ALTER TABLE items ADD COLUMN name TEXT;
-- Error: duplicate column name
</code></pre>
<h3 id="drop-column"><a class="header" href="#drop-column">DROP COLUMN</a></h3>
<p>Removes a column from the table and rewrites the table data to exclude the dropped column’s values. The <code>COLUMN</code> keyword is optional.</p>
<pre><code class="language-sql">CREATE TABLE customers (id INTEGER PRIMARY KEY, name TEXT, email TEXT, phone TEXT);
INSERT INTO customers VALUES (1, 'Alice', 'alice@example.com', '555-0100');
ALTER TABLE customers DROP COLUMN phone;
SELECT * FROM customers;
-- 1|Alice|alice@example.com
</code></pre>
<h4 id="restrictions-1"><a class="header" href="#restrictions-1">Restrictions</a></h4>
<p>A column cannot be dropped if it:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Restriction</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Is a <code>PRIMARY KEY</code> or part of one</td><td>The primary key is essential to the table’s identity.</td></tr>
<tr><td>Has a <code>UNIQUE</code> constraint</td><td>A unique index depends on the column.</td></tr>
<tr><td>Is referenced by an index</td><td>The index would become invalid.</td></tr>
<tr><td>Is referenced by a table-level <code>CHECK</code> constraint</td><td>The CHECK expression would reference a missing column.</td></tr>
<tr><td>Is used in a generated column expression</td><td>The generated column would become invalid.</td></tr>
</tbody>
</table>
</div>
<p>A column-level <code>CHECK</code> constraint attached to the dropped column is removed along with the column:</p>
<pre><code class="language-sql">CREATE TABLE metrics (
  id INTEGER PRIMARY KEY,
  value REAL CHECK (value BETWEEN 0.0 AND 1000.0),
  label TEXT NOT NULL
);
INSERT INTO metrics VALUES (1, 500.0, 'temperature');
ALTER TABLE metrics DROP COLUMN value;
INSERT INTO metrics VALUES (2, 'humidity');
SELECT * FROM metrics;
-- 1|temperature
-- 2|humidity
</code></pre>
<h3 id="alter-column"><a class="header" href="#alter-column">ALTER COLUMN</a></h3>
<p><em>This is a Turso extension not present in SQLite.</em></p>
<p>The <code>ALTER COLUMN</code> operation changes a column’s name and definition in a single statement. The <code>column-def</code> after <code>TO</code> is a full column definition (name, type, and constraints), replacing the old column definition entirely. Data in existing rows is preserved.</p>
<pre><code class="language-sql">CREATE TABLE sensors (id INTEGER PRIMARY KEY, reading INTEGER);
CREATE INDEX idx_reading ON sensors (reading);
ALTER TABLE sensors ALTER COLUMN reading TO measurement BLOB;
SELECT sql FROM sqlite_schema;
-- CREATE TABLE sensors (id INTEGER PRIMARY KEY, measurement BLOB)
-- CREATE INDEX idx_reading ON sensors (measurement)
</code></pre>
<p>The new column definition may not include <code>PRIMARY KEY</code> or <code>UNIQUE</code> constraints:</p>
<pre><code class="language-sql">CREATE TABLE config (key TEXT, value TEXT);
ALTER TABLE config ALTER COLUMN value TO value PRIMARY KEY;
-- Error: cannot add PRIMARY KEY via ALTER COLUMN
</code></pre>
<p>The new definition may specify a generated column expression, as long as at least one non-generated column remains in the table:</p>
<pre><code class="language-sql">CREATE TABLE items (name TEXT, price REAL);
ALTER TABLE items ALTER COLUMN price TO computed_price AS (123);
SELECT sql FROM sqlite_schema WHERE name = 'items';
-- CREATE TABLE items (name TEXT, computed_price AS (123))
</code></pre>
<h2 id="examples-16"><a class="header" href="#examples-16">Examples</a></h2>
<h3 id="evolving-a-schema"><a class="header" href="#evolving-a-schema">Evolving a Schema</a></h3>
<p>A common workflow is creating a table and then adding columns as requirements change:</p>
<pre><code class="language-sql">CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT NOT NULL);
INSERT INTO users VALUES (1, 'alice'), (2, 'bob');

ALTER TABLE users ADD email TEXT DEFAULT 'unknown';
ALTER TABLE users ADD created_at TEXT DEFAULT CURRENT_TIMESTAMP;

SELECT id, username, email FROM users ORDER BY id;
-- 1|alice|unknown
-- 2|bob|unknown
</code></pre>
<h3 id="renaming-for-clarity"><a class="header" href="#renaming-for-clarity">Renaming for Clarity</a></h3>
<pre><code class="language-sql">CREATE TABLE t (a INTEGER, b TEXT, c REAL);
CREATE INDEX idx_t_a ON t (a);

ALTER TABLE t RENAME COLUMN a TO user_id;
ALTER TABLE t RENAME COLUMN b TO user_name;
ALTER TABLE t RENAME COLUMN c TO balance;
ALTER TABLE t RENAME TO accounts;

SELECT sql FROM sqlite_schema ORDER BY type;
-- CREATE INDEX idx_t_a ON accounts (user_id)
-- CREATE TABLE accounts (user_id INTEGER, user_name TEXT, balance REAL)
</code></pre>
<h3 id="dropping-unused-columns"><a class="header" href="#dropping-unused-columns">Dropping Unused Columns</a></h3>
<pre><code class="language-sql">CREATE TABLE logs (id INTEGER PRIMARY KEY, message TEXT, debug_info TEXT);
INSERT INTO logs VALUES (1, 'Server started', 'verbose debug data');
INSERT INTO logs VALUES (2, 'User login', 'session details');

ALTER TABLE logs DROP COLUMN debug_info;
SELECT * FROM logs;
-- 1|Server started
-- 2|User login
</code></pre>
<h3 id="foreign-key-updates-after-rename"><a class="header" href="#foreign-key-updates-after-rename">Foreign Key Updates After Rename</a></h3>
<p>When a parent table is renamed, foreign key references in child tables are updated automatically:</p>
<pre><code class="language-sql">PRAGMA foreign_keys = ON;
CREATE TABLE categories (id INTEGER PRIMARY KEY);
CREATE TABLE products (id INTEGER PRIMARY KEY, cat_id INTEGER,
  FOREIGN KEY (cat_id) REFERENCES categories(id));

ALTER TABLE categories RENAME TO product_categories;

SELECT sql FROM sqlite_schema WHERE name = 'products';
-- CREATE TABLE products (id INTEGER PRIMARY KEY, cat_id INTEGER, FOREIGN KEY (cat_id) REFERENCES product_categories (id))
</code></pre>
<h2 id="compatibility-12"><a class="header" href="#compatibility-12">Compatibility</a></h2>
<ul>
<li><strong>ALTER COLUMN</strong> is a Turso extension. This operation is not available in SQLite. It allows changing a column’s name, type, and constraints in a single statement.</li>
<li><strong>Adding generated columns</strong> via <code>ALTER TABLE ADD COLUMN</code> is not supported. Use <code>ALTER COLUMN</code> to convert an existing column to a generated column, or recreate the table.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="drop"><a class="header" href="#drop">DROP</a></h1>
<h2 id="syntax-17"><a class="header" href="#syntax-17">Syntax</a></h2>
<pre><code class="language-sql">DROP TABLE [IF EXISTS] table-name
DROP INDEX [IF EXISTS] index-name
DROP VIEW [IF EXISTS] view-name
DROP TRIGGER [IF EXISTS] trigger-name
</code></pre>
<h2 id="description-17"><a class="header" href="#description-17">Description</a></h2>
<p>The DROP statement removes a database object (table, index, view, or trigger) from the database. The object and all its associated data are permanently deleted. This action cannot be undone.</p>
<p>If the <code>IF EXISTS</code> clause is included, the statement is a no-op when the named object does not exist. Without <code>IF EXISTS</code>, attempting to drop a nonexistent object raises an error.</p>
<h2 id="drop-table"><a class="header" href="#drop-table">DROP TABLE</a></h2>
<p>Removes a table and all of its data, indexes, and triggers from the database.</p>
<pre><code class="language-sql">-- Remove a table
DROP TABLE users;

-- Remove a table only if it exists (no error if missing)
DROP TABLE IF EXISTS users;
</code></pre>
<p>When a table is dropped:</p>
<ul>
<li>All rows in the table are deleted.</li>
<li>All indexes associated with the table are removed.</li>
<li>All triggers associated with the table are removed.</li>
<li>Foreign key references to the table are not automatically updated. If other tables have foreign key constraints pointing to the dropped table, those constraints become orphaned.</li>
</ul>
<h2 id="drop-index"><a class="header" href="#drop-index">DROP INDEX</a></h2>
<p>Removes an index from the database. The underlying table data is not affected.</p>
<pre><code class="language-sql">-- Remove an index
DROP INDEX idx_users_email;

-- Remove an index only if it exists
DROP INDEX IF EXISTS idx_users_email;
</code></pre>
<p>Dropping an index does not affect the data in the table — it only removes the index structure. Queries that previously used the index will still work, but may run slower without it.</p>
<h2 id="drop-view"><a class="header" href="#drop-view">DROP VIEW</a></h2>
<p>Removes a view definition from the database. Since views do not store data, no data is deleted.</p>
<pre><code class="language-sql">-- Remove a view
DROP VIEW active_users;

-- Remove a view only if it exists
DROP VIEW IF EXISTS active_users;
</code></pre>
<h2 id="drop-trigger"><a class="header" href="#drop-trigger">DROP TRIGGER</a></h2>
<p>Removes a trigger from the database.</p>
<pre><code class="language-sql">-- Remove a trigger
DROP TRIGGER audit_insert;

-- Remove a trigger only if it exists
DROP TRIGGER IF EXISTS audit_insert;
</code></pre>
<h2 id="examples-17"><a class="header" href="#examples-17">Examples</a></h2>
<pre><code class="language-sql">-- Create a table with an index, then drop both
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  price REAL
);
CREATE INDEX idx_products_name ON products(name);

-- Drop the index first, then the table
DROP INDEX idx_products_name;
DROP TABLE products;
</code></pre>
<pre><code class="language-sql">-- Safely clean up objects that may or may not exist
DROP VIEW IF EXISTS sales_summary;
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS customers;
</code></pre>
<pre><code class="language-sql">-- Drop and recreate a table (reset)
DROP TABLE IF EXISTS temp_results;
CREATE TABLE temp_results (id INTEGER PRIMARY KEY, value TEXT);
</code></pre>
<h2 id="compatibility-13"><a class="header" href="#compatibility-13">Compatibility</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>DROP TABLE</td><td>Supported</td></tr>
<tr><td>DROP INDEX</td><td>Supported</td></tr>
<tr><td>DROP VIEW</td><td>Supported</td></tr>
<tr><td>DROP TRIGGER</td><td>Requires <code>--experimental-triggers</code> flag</td></tr>
<tr><td>IF EXISTS</td><td>Supported</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<h2 id="syntax-18"><a class="header" href="#syntax-18">Syntax</a></h2>
<pre><code class="language-sql">BEGIN [DEFERRED | IMMEDIATE | EXCLUSIVE] [TRANSACTION]

COMMIT [TRANSACTION]

END [TRANSACTION]

ROLLBACK [TRANSACTION]
</code></pre>
<h2 id="description-18"><a class="header" href="#description-18">Description</a></h2>
<p>A transaction is a sequence of SQL statements that are executed as a single
atomic unit. Either all statements in the transaction complete successfully and
their changes are made permanent, or none of them take effect. Transactions
guarantee that the database moves from one consistent state to another, even in
the presence of errors or unexpected termination.</p>
<p>Turso supports three commands for explicit transaction control: <code>BEGIN</code> starts a
new transaction, <code>COMMIT</code> (or its alias <code>END</code>) makes all changes within the
transaction permanent, and <code>ROLLBACK</code> discards all changes made since the
transaction began.</p>
<p>Transactions in Turso do not nest. Issuing <code>BEGIN</code> while a transaction is
already active will produce an error. For the same reason, issuing <code>COMMIT</code> or
<code>ROLLBACK</code> outside of a transaction will also produce an error.</p>
<h2 id="autocommit-mode"><a class="header" href="#autocommit-mode">Autocommit Mode</a></h2>
<p>When no explicit transaction is active, Turso operates in <strong>autocommit mode</strong>.
In this mode every individual SQL statement that reads from or writes to the
database is automatically wrapped in its own implicit transaction. The implicit
transaction is committed as soon as the statement finishes executing.</p>
<p>This means a single <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement executed outside
of an explicit transaction is atomic by itself – it either fully succeeds or
has no effect. However, if you need multiple statements to succeed or fail
together, you must wrap them in an explicit <code>BEGIN</code> … <code>COMMIT</code> block.</p>
<pre><code class="language-sql">-- Autocommit mode: each statement is its own transaction
CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, qty INTEGER);
INSERT INTO orders VALUES (1, 'Widget', 10);
INSERT INTO orders VALUES (2, 'Gadget', 5);
-- Both rows are committed independently
</code></pre>
<h2 id="transaction-types"><a class="header" href="#transaction-types">Transaction Types</a></h2>
<p>The <code>BEGIN</code> statement accepts an optional keyword that controls when the
transaction acquires its lock on the database.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td>DEFERRED</td><td>The default. The transaction does not acquire any lock until the database is first accessed. A read statement starts a read transaction; a write statement starts a write transaction.</td></tr>
<tr><td>IMMEDIATE</td><td>A write lock is acquired immediately when <code>BEGIN IMMEDIATE</code> is executed, without waiting for the first write statement. This guarantees that no other connection can write to the database while this transaction is open.</td></tr>
<tr><td>EXCLUSIVE</td><td>Behaves the same as IMMEDIATE under WAL mode, which is the journaling mode used by Turso. A write lock is acquired immediately.</td></tr>
</tbody>
</table>
</div>
<p>When the transaction type is omitted, <code>DEFERRED</code> is assumed.</p>
<h3 id="deferred"><a class="header" href="#deferred">DEFERRED</a></h3>
<p>A deferred transaction does not acquire any database lock when <code>BEGIN</code> is
executed. The lock is acquired lazily the first time the database is actually
read from or written to within the transaction. If the first operation is a
<code>SELECT</code>, a read lock is acquired. If the first operation is an <code>INSERT</code>,
<code>UPDATE</code>, <code>DELETE</code>, or other write statement, a write lock is acquired.</p>
<pre><code class="language-sql">-- DEFERRED is the default; these two are equivalent
BEGIN TRANSACTION;
-- ...
COMMIT;

BEGIN DEFERRED TRANSACTION;
-- ...
COMMIT;
</code></pre>
<h3 id="immediate"><a class="header" href="#immediate">IMMEDIATE</a></h3>
<p>An immediate transaction acquires a write lock as soon as <code>BEGIN IMMEDIATE</code> is
executed. This is useful when you know the transaction will perform writes,
because it avoids a potential conflict that could occur if a deferred
transaction tries to upgrade from a read lock to a write lock after another
connection has already started writing.</p>
<pre><code class="language-sql">BEGIN IMMEDIATE TRANSACTION;
-- Write lock is held from this point
INSERT INTO orders (product, qty) VALUES ('Keyboard', 75);
COMMIT;
</code></pre>
<h3 id="exclusive"><a class="header" href="#exclusive">EXCLUSIVE</a></h3>
<p>Under WAL mode – the mode Turso uses – <code>EXCLUSIVE</code> behaves identically to
<code>IMMEDIATE</code>. Both acquire a write lock immediately. In other journaling modes
(not used by Turso), <code>EXCLUSIVE</code> would additionally prevent other connections
from reading the database, but this distinction does not apply here.</p>
<pre><code class="language-sql">BEGIN EXCLUSIVE;
INSERT INTO orders (product, qty) VALUES ('Mouse', 200);
END;
</code></pre>
<h2 id="commit-and-end"><a class="header" href="#commit-and-end">COMMIT and END</a></h2>
<p><code>COMMIT</code> makes all changes performed within the current transaction permanent.
<code>END</code> is an alias for <code>COMMIT</code>; they are interchangeable.</p>
<p>The optional <code>TRANSACTION</code> keyword after <code>COMMIT</code> or <code>END</code> is purely
decorative and has no effect on behavior.</p>
<pre><code class="language-sql">-- These are all equivalent
COMMIT;
COMMIT TRANSACTION;
END;
END TRANSACTION;
</code></pre>
<h2 id="rollback"><a class="header" href="#rollback">ROLLBACK</a></h2>
<p><code>ROLLBACK</code> discards all changes made within the current transaction. The
database is restored to the state it was in before <code>BEGIN</code> was executed.</p>
<p>The optional <code>TRANSACTION</code> keyword after <code>ROLLBACK</code> is purely decorative and
has no effect on behavior.</p>
<pre><code class="language-sql">CREATE TABLE accounts (id INTEGER PRIMARY KEY, name TEXT, balance REAL);
INSERT INTO accounts VALUES (1, 'Alice', 1000.00);
INSERT INTO accounts VALUES (2, 'Bob', 500.00);

BEGIN;
UPDATE accounts SET balance = balance - 200.00 WHERE name = 'Alice';
UPDATE accounts SET balance = balance + 200.00 WHERE name = 'Bob';
-- At this point, Alice has 800 and Bob has 700 within the transaction
ROLLBACK;

SELECT * FROM accounts;
-- Alice still has 1000.00 and Bob still has 500.00
</code></pre>
<h2 id="examples-18"><a class="header" href="#examples-18">Examples</a></h2>
<h3 id="atomic-money-transfer"><a class="header" href="#atomic-money-transfer">Atomic money transfer</a></h3>
<p>Wrapping related updates in a transaction ensures that a transfer between
accounts either fully completes or has no effect.</p>
<pre><code class="language-sql">CREATE TABLE accounts (id INTEGER PRIMARY KEY, name TEXT, balance REAL);
INSERT INTO accounts VALUES (1, 'Alice', 1000.00);
INSERT INTO accounts VALUES (2, 'Bob', 500.00);

BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 200.00 WHERE name = 'Alice';
UPDATE accounts SET balance = balance + 200.00 WHERE name = 'Bob';
COMMIT;

SELECT * FROM accounts;
-- 1|Alice|800.0
-- 2|Bob|700.0
</code></pre>
<h3 id="batch-inserts-within-a-transaction"><a class="header" href="#batch-inserts-within-a-transaction">Batch inserts within a transaction</a></h3>
<p>Grouping multiple inserts into a single transaction is significantly faster
than executing each insert in autocommit mode, because the database only needs
to sync to disk once at <code>COMMIT</code> rather than after every individual statement.</p>
<pre><code class="language-sql">CREATE TABLE inventory (id INTEGER PRIMARY KEY, product TEXT NOT NULL, qty INTEGER DEFAULT 0);

BEGIN;
INSERT INTO inventory (product, qty) VALUES ('Laptop', 50);
INSERT INTO inventory (product, qty) VALUES ('Mouse', 200);
INSERT INTO inventory (product, qty) VALUES ('Keyboard', 75);
COMMIT;

SELECT * FROM inventory;
-- 1|Laptop|50
-- 2|Mouse|200
-- 3|Keyboard|75
</code></pre>
<h3 id="rolling-back-on-error"><a class="header" href="#rolling-back-on-error">Rolling back on error</a></h3>
<p>If something goes wrong during a sequence of operations, <code>ROLLBACK</code> ensures
that partially applied changes do not corrupt the database.</p>
<pre><code class="language-sql">CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, qty INTEGER);

BEGIN;
INSERT INTO orders VALUES (1, 'Widget', 10);
INSERT INTO orders VALUES (2, 'Gadget', 5);
-- Decide to discard these changes
ROLLBACK;

SELECT count(*) FROM orders;
-- 0
</code></pre>
<h3 id="using-immediate-for-write-heavy-work"><a class="header" href="#using-immediate-for-write-heavy-work">Using IMMEDIATE for write-heavy work</a></h3>
<p>When you know a transaction will write to the database, starting with
<code>BEGIN IMMEDIATE</code> avoids the overhead and potential failure of upgrading a read
lock to a write lock mid-transaction.</p>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL);

BEGIN IMMEDIATE;
INSERT INTO products VALUES (1, 'Widget', 9.99);
INSERT INTO products VALUES (2, 'Gadget', 24.95);
END;

SELECT * FROM products;
-- 1|Widget|9.99
-- 2|Gadget|24.95
</code></pre>
<h3 id="end-as-an-alias-for-commit"><a class="header" href="#end-as-an-alias-for-commit">END as an alias for COMMIT</a></h3>
<p><code>END</code> and <code>COMMIT</code> are interchangeable. Use whichever reads more naturally in
your application.</p>
<pre><code class="language-sql">CREATE TABLE events (id INTEGER PRIMARY KEY, description TEXT);

BEGIN DEFERRED TRANSACTION;
INSERT INTO events (description) VALUES ('user_login');
INSERT INTO events (description) VALUES ('page_view');
END TRANSACTION;

SELECT * FROM events;
-- 1|user_login
-- 2|page_view
</code></pre>
<h2 id="compatibility-14"><a class="header" href="#compatibility-14">Compatibility</a></h2>
<p>Turso supports <code>BEGIN</code>, <code>COMMIT</code> / <code>END</code>, and <code>ROLLBACK</code> with the same syntax
and semantics as SQLite. The <code>TRANSACTION</code> keyword is optional in all three
commands, matching SQLite behavior.</p>
<p><code>SAVEPOINT</code> and <code>RELEASE SAVEPOINT</code> are not supported. Nested transactions
using savepoints are not available.</p>
<p>Turso operates exclusively in WAL (Write-Ahead Logging) mode. As a result,
<code>BEGIN EXCLUSIVE</code> and <code>BEGIN IMMEDIATE</code> behave identically – both acquire a
write lock immediately. The distinction between these two modes that exists in
other SQLite journaling modes does not apply.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="explain"><a class="header" href="#explain">EXPLAIN</a></h1>
<h2 id="syntax-19"><a class="header" href="#syntax-19">Syntax</a></h2>
<pre><code class="language-sql">EXPLAIN sql-statement

EXPLAIN QUERY PLAN sql-statement
</code></pre>
<h2 id="description-19"><a class="header" href="#description-19">Description</a></h2>
<p>The <code>EXPLAIN</code> statement is a diagnostic tool for understanding how Turso executes a SQL statement. It does not run the statement itself. Instead, it returns metadata about the execution strategy.</p>
<p>There are two forms. <code>EXPLAIN</code> returns the full sequence of virtual machine (VDBE) bytecode instructions that Turso would execute for the given statement. <code>EXPLAIN QUERY PLAN</code> returns a high-level summary of the query plan, showing which tables and indexes are accessed and in what order. Both forms are intended for interactive analysis, debugging, and performance tuning.</p>
<p>The <code>EXPLAIN</code> prefix can be applied to any SQL statement, including <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE TABLE</code>, and others. The prefixed statement is compiled but never executed, so it has no side effects.</p>
<h2 id="output-columns"><a class="header" href="#output-columns">Output Columns</a></h2>
<h3 id="explain-1"><a class="header" href="#explain-1">EXPLAIN</a></h3>
<p><code>EXPLAIN</code> returns one row per bytecode instruction. Each row has eight columns:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Column</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>addr</code></td><td>INTEGER</td><td>The instruction address (sequential, starting at 0).</td></tr>
<tr><td><code>opcode</code></td><td>TEXT</td><td>The name of the VDBE opcode (e.g., <code>Init</code>, <code>OpenRead</code>, <code>Column</code>, <code>ResultRow</code>).</td></tr>
<tr><td><code>p1</code></td><td>INTEGER</td><td>First operand. Meaning varies by opcode.</td></tr>
<tr><td><code>p2</code></td><td>INTEGER</td><td>Second operand. Often a jump target or register number.</td></tr>
<tr><td><code>p3</code></td><td>INTEGER</td><td>Third operand.</td></tr>
<tr><td><code>p4</code></td><td>TEXT</td><td>Fourth operand. May contain a string constant, function name, key format, or table/index name.</td></tr>
<tr><td><code>p5</code></td><td>INTEGER</td><td>Fifth operand. Typically contains flags.</td></tr>
<tr><td><code>comment</code></td><td>TEXT</td><td>A human-readable comment describing what the instruction does.</td></tr>
</tbody>
</table>
</div>
<p>The bytecode format is an internal implementation detail and may change between Turso releases. Do not write application logic that depends on specific opcodes or instruction sequences.</p>
<h3 id="explain-query-plan"><a class="header" href="#explain-query-plan">EXPLAIN QUERY PLAN</a></h3>
<p><code>EXPLAIN QUERY PLAN</code> returns one row per step in the query plan. Each row has four columns:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Column</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>id</code></td><td>INTEGER</td><td>A unique identifier for this node in the plan tree.</td></tr>
<tr><td><code>parent</code></td><td>INTEGER</td><td>The <code>id</code> of the parent node (0 for root nodes).</td></tr>
<tr><td><code>notused</code></td><td>INTEGER</td><td>Reserved. Always 0.</td></tr>
<tr><td><code>detail</code></td><td>TEXT</td><td>A human-readable description of the operation at this step.</td></tr>
</tbody>
</table>
</div>
<p>The <code>detail</code> column contains the most useful information. Common values include:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Detail prefix</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>SCAN table-name</code></td><td>A full table scan with no index.</td></tr>
<tr><td><code>SEARCH table-name USING INDEX index-name</code></td><td>An indexed lookup.</td></tr>
<tr><td><code>SEARCH table-name USING INTEGER PRIMARY KEY (rowid=?)</code></td><td>A direct rowid lookup via the primary key.</td></tr>
<tr><td><code>USE TEMP B-TREE FOR ORDER BY</code></td><td>A temporary structure is used to sort results.</td></tr>
<tr><td><code>SCAN CONSTANT ROW</code></td><td>A row is produced from constant values (no table access).</td></tr>
</tbody>
</table>
</div>
<p>When a query involves multiple tables (joins, subqueries), <code>EXPLAIN QUERY PLAN</code> returns multiple rows showing the access order and method for each table.</p>
<h2 id="interpreting-query-plans"><a class="header" href="#interpreting-query-plans">Interpreting Query Plans</a></h2>
<p>The output of <code>EXPLAIN QUERY PLAN</code> is the primary tool for diagnosing slow queries. The key things to look for:</p>
<ul>
<li><strong>SCAN vs. SEARCH</strong>: A <code>SCAN</code> reads every row in the table. A <code>SEARCH</code> uses an index to jump directly to matching rows. If a query is slow, look for unexpected <code>SCAN</code> operations on large tables and consider adding an index.</li>
<li><strong>Index usage</strong>: When an index is used, the detail line names it. Verify that the expected index is being chosen.</li>
<li><strong>Temporary B-trees</strong>: Lines mentioning <code>USE TEMP B-TREE</code> indicate that Turso must build a temporary data structure (for sorting, grouping, or deduplication). This is normal for <code>ORDER BY</code> on non-indexed columns but can be a performance concern for large result sets.</li>
<li><strong>Join order</strong>: In multi-table queries, the rows appear in the order that tables are accessed. The first table listed is the outer loop; subsequent tables are inner loops. The optimizer chooses the join order it estimates to be fastest.</li>
</ul>
<h2 id="examples-19"><a class="header" href="#examples-19">Examples</a></h2>
<h3 id="bytecode-for-a-simple-query"><a class="header" href="#bytecode-for-a-simple-query">Bytecode for a Simple Query</a></h3>
<pre><code class="language-sql">EXPLAIN SELECT 1;
-- addr  opcode             p1    p2    p3    p4             p5  comment
-- ----  -----------------  ----  ----  ----  -------------  --  -------
-- 0     Init               0     3     0                    0   Start at 3
-- 1     ResultRow          1     1     0                    0   output=r[1]
-- 2     Halt               0     0     0                    0
-- 3     Integer            1     1     0                    0   r[1]=1
-- 4     Goto               0     1     0                    0
</code></pre>
<p>The <code>Init</code> instruction jumps to address 3, where the integer <code>1</code> is loaded into register 1. Control then jumps to address 1, which outputs register 1 as a result row. Finally, <code>Halt</code> terminates execution.</p>
<h3 id="query-plan-for-a-full-table-scan"><a class="header" href="#query-plan-for-a-full-table-scan">Query Plan for a Full Table Scan</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer_id INTEGER,
  product TEXT,
  amount REAL
);

EXPLAIN QUERY PLAN SELECT * FROM orders;
-- QUERY PLAN
-- `--SCAN orders
</code></pre>
<p>With no <code>WHERE</code> clause and no index needed, Turso performs a full scan of the <code>orders</code> table.</p>
<h3 id="query-plan-with-index-usage"><a class="header" href="#query-plan-with-index-usage">Query Plan with Index Usage</a></h3>
<pre><code class="language-sql">CREATE INDEX idx_orders_customer ON orders(customer_id);

EXPLAIN QUERY PLAN SELECT id, product, amount
FROM orders WHERE customer_id = 42;
-- QUERY PLAN
-- `--SEARCH orders USING INDEX idx_orders_customer
</code></pre>
<p>The <code>SEARCH</code> line shows that Turso uses the <code>idx_orders_customer</code> index to find rows where <code>customer_id = 42</code>, avoiding a full table scan.</p>
<h3 id="query-plan-with-primary-key-lookup"><a class="header" href="#query-plan-with-primary-key-lookup">Query Plan with Primary Key Lookup</a></h3>
<pre><code class="language-sql">EXPLAIN QUERY PLAN SELECT * FROM orders WHERE id = 10;
-- QUERY PLAN
-- `--SEARCH orders USING INTEGER PRIMARY KEY (rowid=?)
</code></pre>
<p>When filtering by the <code>INTEGER PRIMARY KEY</code>, Turso performs a direct rowid lookup, which is the fastest possible access method.</p>
<h3 id="query-plan-for-a-join"><a class="header" href="#query-plan-for-a-join">Query Plan for a Join</a></h3>
<pre><code class="language-sql">CREATE TABLE customers (
  id INTEGER PRIMARY KEY,
  name TEXT,
  email TEXT
);

EXPLAIN QUERY PLAN SELECT c.name, o.product, o.amount
FROM customers c
JOIN orders o ON c.id = o.customer_id
WHERE c.name = 'Alice';
-- QUERY PLAN
-- |--SCAN customers AS c
-- `--SEARCH o USING INDEX idx_orders_customer
</code></pre>
<p>Turso scans the <code>customers</code> table (the outer loop), and for each matching customer, uses the index on <code>orders(customer_id)</code> to find their orders (the inner loop).</p>
<h3 id="query-plan-with-group-by-and-order-by"><a class="header" href="#query-plan-with-group-by-and-order-by">Query Plan with GROUP BY and ORDER BY</a></h3>
<pre><code class="language-sql">EXPLAIN QUERY PLAN SELECT product, SUM(amount)
FROM orders
GROUP BY product
ORDER BY SUM(amount) DESC;
-- QUERY PLAN
-- |--SCAN orders
-- `--USE TEMP B-TREE FOR ORDER BY
</code></pre>
<p>The plan shows a full table scan to read and group the data, followed by a temporary B-tree to sort the grouped results by the aggregate value.</p>
<h3 id="bytecode-for-an-insert"><a class="header" href="#bytecode-for-an-insert">Bytecode for an INSERT</a></h3>
<pre><code class="language-sql">EXPLAIN INSERT INTO orders VALUES (1, 42, 'Widget', 9.99);
-- addr  opcode             p1    p2    p3    p4             p5  comment
-- ----  -----------------  ----  ----  ----  -------------  --  -------
-- 0     Init               0     20    0                    0   Start at 20
-- 1     OpenWrite          0     2     0                    0   root=2; iDb=0
-- 2     Integer            1     2     0                    0   r[2]=1
-- 3     SoftNull           3     0     0                    0
-- 4     Integer            42    4     0                    0   r[4]=42
-- 5     String8            0     5     0     Widget         0   r[5]='Widget'
-- 6     Real               0     6     0     9.99           0   r[6]=9.99
-- 7     NotNull            2     9     0                    0   r[2]!=NULL -&gt; goto 9
-- 8     Goto               0     11    0                    0
-- 9     MustBeInt          2     0     0                    0
-- 10    Goto               0     12    0                    0
-- 11    NewRowid           0     2     0                    0   r[2]=rowid
-- 12    Affinity           3     4     0                    0   r[3..7] = D, D, B, E
-- 13    NotExists          0     15    2                    0
-- 14    Halt               1555  0     0     orders.id      0
-- 15    MakeRecord         3     4     7                    0   r[7]=mkrec(r[3..6])
-- 16    Insert             0     7     2     orders         0   intkey=r[2] data=r[7]
-- 17    Goto               0     18    0                    0
-- 18    Goto               0     19    0                    0
-- 19    Halt               0     0     0                    0
-- 20    Transaction        0     2     1                    0   iDb=0 tx_mode=Write
-- 21    Goto               0     1     0                    0
</code></pre>
<p>The bytecode shows the full instruction sequence: opening the table for writing, loading the values into registers, checking for primary key conflicts, assembling the record, and inserting it.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Operators perform arithmetic, comparison, logical, bitwise, and string operations on values in SQL expressions. Turso supports the full set of SQLite operators, including the standard SQL <code>IS DISTINCT FROM</code> and <code>IS NOT DISTINCT FROM</code> forms.</p>
<h2 id="operator-precedence"><a class="header" href="#operator-precedence">Operator Precedence</a></h2>
<p>When an expression contains multiple operators, precedence determines the order of evaluation. Operators with higher precedence bind more tightly. Operators at the same precedence level are left-associative (evaluated left to right). Parentheses override precedence.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Precedence</th><th>Operators</th><th>Category</th></tr>
</thead>
<tbody>
<tr><td>1 (highest)</td><td><code>~</code> <code>+</code> <code>-</code></td><td>Unary bitwise NOT, unary plus, unary minus</td></tr>
<tr><td>2</td><td><code>||</code></td><td>String concatenation</td></tr>
<tr><td>3</td><td><code>*</code> <code>/</code> <code>%</code></td><td>Multiplication, division, modulo</td></tr>
<tr><td>4</td><td><code>+</code> <code>-</code></td><td>Addition, subtraction</td></tr>
<tr><td>5</td><td><code>&amp;</code> <code>|</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td>Bitwise AND, OR, left shift, right shift</td></tr>
<tr><td>6</td><td><code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td><td>Relational comparison</td></tr>
<tr><td>7</td><td><code>=</code> <code>==</code> <code>&lt;&gt;</code> <code>IS</code> <code>IS NOT</code> <code>IS DISTINCT FROM</code> <code>IS NOT DISTINCT FROM</code></td><td>Equality and identity</td></tr>
<tr><td>8</td><td><code>NOT</code></td><td>Logical NOT (unary)</td></tr>
<tr><td>9</td><td><code>AND</code></td><td>Logical AND</td></tr>
<tr><td>10 (lowest)</td><td><code>OR</code></td><td>Logical OR</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">-- Multiplication binds tighter than addition
SELECT 2 + 3 * 4;    -- 14  (not 20)
SELECT (2 + 3) * 4;  -- 20  (parentheses override)

-- AND binds tighter than OR
SELECT 1 OR 0 AND 0;    -- 1  (equivalent to: 1 OR (0 AND 0))

-- NOT binds tighter than AND
SELECT NOT 1 AND 0;     -- 0  (equivalent to: (NOT 1) AND 0)

-- Left associativity
SELECT 10 - 2 - 3;      -- 5  (equivalent to: (10 - 2) - 3)
</code></pre>
<h2 id="unary-operators"><a class="header" href="#unary-operators">Unary Operators</a></h2>
<p>Unary operators take a single operand. They have the highest precedence of all operators.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>-expr</code></td><td>Negates the numeric value of <code>expr</code>.</td></tr>
<tr><td><code>+expr</code></td><td>No-op. Returns the value of <code>expr</code> unchanged.</td></tr>
<tr><td><code>~expr</code></td><td>Bitwise NOT. Inverts every bit of the integer value of <code>expr</code>.</td></tr>
<tr><td><code>NOT expr</code></td><td>Logical NOT. Returns 1 if <code>expr</code> is 0, returns 0 if <code>expr</code> is non-zero, returns NULL if <code>expr</code> is NULL.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT -5;       -- -5
SELECT +5;       -- 5
SELECT ~5;       -- -6  (inverts all bits of integer 5)
SELECT NOT 1;    -- 0
SELECT NOT 0;    -- 1
SELECT NOT NULL;  -- NULL
</code></pre>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<p>Arithmetic operators perform numeric calculations. When both operands are integers, the result is an integer. When either operand is a real (floating-point) value, the result is a real.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>expr1 + expr2</code></td><td>Addition.</td></tr>
<tr><td><code>expr1 - expr2</code></td><td>Subtraction.</td></tr>
<tr><td><code>expr1 * expr2</code></td><td>Multiplication.</td></tr>
<tr><td><code>expr1 / expr2</code></td><td>Division. Integer division truncates toward zero.</td></tr>
<tr><td><code>expr1 % expr2</code></td><td>Modulo. Returns the remainder after integer division. Both operands are cast to integers.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT 5 + 3;      -- 8
SELECT 10 - 4;     -- 6
SELECT 6 * 7;      -- 42
SELECT 15 / 4;     -- 3    (integer division truncates)
SELECT 7.0 / 2;    -- 3.5  (real division when either operand is real)
SELECT 2.5 + 1.5;  -- 4.0
SELECT 17 % 5;     -- 2
SELECT -7 % 3;     -- -1
</code></pre>
<h3 id="arithmetic-with-null"><a class="header" href="#arithmetic-with-null">Arithmetic with NULL</a></h3>
<p>Any arithmetic operation involving NULL produces NULL:</p>
<pre><code class="language-sql">SELECT 5 + NULL;  -- NULL
</code></pre>
<h3 id="realistic-example"><a class="header" href="#realistic-example">Realistic Example</a></h3>
<pre><code class="language-sql">CREATE TABLE products (name TEXT, price REAL, quantity INTEGER);
INSERT INTO products VALUES ('Widget', 9.99, 100),
                            ('Gadget', 24.50, 50),
                            ('Gizmo', 4.75, 200);

SELECT name, price * quantity AS total_value FROM products;
-- Widget|999.0
-- Gadget|1225.0
-- Gizmo|950.0
</code></pre>
<h2 id="string-concatenation"><a class="header" href="#string-concatenation">String Concatenation</a></h2>
<p>The <code>||</code> operator joins two values into a single text string. Non-text operands are converted to text before concatenation. If either operand is NULL, the result is NULL.</p>
<pre><code class="language-sql">SELECT 'Hello' || ' ' || 'World';  -- Hello World
SELECT 'Order #' || 42;            -- Order #42
SELECT 'text' || NULL;             -- NULL
</code></pre>
<h3 id="realistic-example-1"><a class="header" href="#realistic-example-1">Realistic Example</a></h3>
<pre><code class="language-sql">CREATE TABLE users (first_name TEXT, last_name TEXT);
INSERT INTO users VALUES ('Alice', 'Smith'), ('Bob', 'Jones');

SELECT first_name || ' ' || last_name AS full_name FROM users;
-- Alice Smith
-- Bob Jones
</code></pre>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<p>Comparison operators compare two values and return an integer: 1 for true, 0 for false. When either operand is NULL, standard comparison operators return NULL (with exceptions noted below).</p>
<h3 id="equality"><a class="header" href="#equality">Equality</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>expr1 = expr2</code></td><td>True if operands are equal.</td></tr>
<tr><td><code>expr1 == expr2</code></td><td>Synonym for <code>=</code>.</td></tr>
<tr><td><code>expr1 &lt;&gt; expr2</code></td><td>True if operands are not equal.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT 1 = 1;    -- 1
SELECT 1 == 1;   -- 1
SELECT 1 &lt;&gt; 2;   -- 1
</code></pre>
<h3 id="relational"><a class="header" href="#relational">Relational</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>expr1 &lt; expr2</code></td><td>True if <code>expr1</code> is less than <code>expr2</code>.</td></tr>
<tr><td><code>expr1 &gt; expr2</code></td><td>True if <code>expr1</code> is greater than <code>expr2</code>.</td></tr>
<tr><td><code>expr1 &lt;= expr2</code></td><td>True if <code>expr1</code> is less than or equal to <code>expr2</code>.</td></tr>
<tr><td><code>expr1 &gt;= expr2</code></td><td>True if <code>expr1</code> is greater than or equal to <code>expr2</code>.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT 3 &lt; 5;    -- 1
SELECT 5 &gt; 3;    -- 1
SELECT 3 &lt;= 3;   -- 1
SELECT 3 &gt;= 3;   -- 1
</code></pre>
<h3 id="null-and-equality"><a class="header" href="#null-and-equality">NULL and Equality</a></h3>
<p>Standard comparison operators return NULL when either operand is NULL, because NULL represents an unknown value:</p>
<pre><code class="language-sql">SELECT NULL = NULL;    -- NULL  (not 1!)
SELECT NULL &lt;&gt; NULL;   -- NULL  (not 1!)
</code></pre>
<p>This is why <code>WHERE column = NULL</code> never matches any rows. Use <code>IS NULL</code> instead.</p>
<h3 id="is-and-is-not"><a class="header" href="#is-and-is-not">IS and IS NOT</a></h3>
<p>The <code>IS</code> and <code>IS NOT</code> operators work like <code>=</code> and <code>&lt;&gt;</code> but handle NULL deterministically: they never return NULL.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Left</th><th>Right</th><th><code>IS</code></th><th><code>IS NOT</code></th></tr>
</thead>
<tbody>
<tr><td>NULL</td><td>NULL</td><td>1</td><td>0</td></tr>
<tr><td>NULL</td><td>non-NULL</td><td>0</td><td>1</td></tr>
<tr><td>non-NULL</td><td>NULL</td><td>0</td><td>1</td></tr>
<tr><td>value</td><td>value</td><td>same as <code>=</code></td><td>same as <code>&lt;&gt;</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT NULL IS NULL;       -- 1
SELECT 5 IS NOT NULL;      -- 1
SELECT 5 IS NULL;          -- 0
SELECT NULL IS NOT NULL;   -- 0
</code></pre>
<h3 id="is-distinct-from-and-is-not-distinct-from"><a class="header" href="#is-distinct-from-and-is-not-distinct-from">IS DISTINCT FROM and IS NOT DISTINCT FROM</a></h3>
<p>These are standard SQL aliases for <code>IS NOT</code> and <code>IS</code>, respectively. They are useful for writing portable SQL that avoids the compact SQLite-specific <code>IS</code>/<code>IS NOT</code> syntax.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression</th><th>Equivalent To</th></tr>
</thead>
<tbody>
<tr><td><code>a IS DISTINCT FROM b</code></td><td><code>a IS NOT b</code></td></tr>
<tr><td><code>a IS NOT DISTINCT FROM b</code></td><td><code>a IS b</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT NULL IS NOT DISTINCT FROM NULL;  -- 1  (equivalent to NULL IS NULL)
SELECT 5 IS DISTINCT FROM NULL;         -- 1  (equivalent to 5 IS NOT NULL)
SELECT 5 IS DISTINCT FROM 5;            -- 0  (equivalent to 5 IS NOT 5)
SELECT NULL IS NOT DISTINCT FROM 5;     -- 0  (equivalent to NULL IS 5)
</code></pre>
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<p>Logical operators evaluate boolean expressions. Turso uses three-valued logic: true (1), false (0), and unknown (NULL).</p>
<h3 id="and"><a class="header" href="#and">AND</a></h3>
<p>Returns 1 if both operands are true, 0 if either operand is false, and NULL otherwise.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Left</th><th>Right</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>NULL</td><td>1</td><td>NULL</td></tr>
<tr><td>NULL</td><td>0</td><td>0</td></tr>
</tbody>
</table>
</div>
<p>The key behavior: <code>NULL AND 0</code> is 0 (not NULL), because regardless of the unknown value, the result must be false when the other operand is false.</p>
<pre><code class="language-sql">SELECT 1 AND 1;      -- 1
SELECT 1 AND 0;      -- 0
SELECT NULL AND 0;   -- 0
SELECT NULL AND 1;   -- NULL
</code></pre>
<h3 id="or"><a class="header" href="#or">OR</a></h3>
<p>Returns 1 if either operand is true, 0 if both operands are false, and NULL otherwise.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Left</th><th>Right</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
<tr><td>NULL</td><td>1</td><td>1</td></tr>
<tr><td>NULL</td><td>0</td><td>NULL</td></tr>
</tbody>
</table>
</div>
<p>The key behavior: <code>NULL OR 1</code> is 1 (not NULL), because regardless of the unknown value, the result must be true when the other operand is true.</p>
<pre><code class="language-sql">SELECT 1 OR 0;      -- 1
SELECT 0 OR 0;      -- 0
SELECT NULL OR 1;   -- 1
SELECT NULL OR 0;   -- NULL
</code></pre>
<h3 id="not"><a class="header" href="#not">NOT</a></h3>
<p>Returns 0 if the operand is true, 1 if the operand is false, and NULL if the operand is NULL.</p>
<pre><code class="language-sql">SELECT NOT 1;      -- 0
SELECT NOT 0;      -- 1
SELECT NOT NULL;   -- NULL
</code></pre>
<h3 id="realistic-example-2"><a class="header" href="#realistic-example-2">Realistic Example</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (id INTEGER, amount REAL, status TEXT);
INSERT INTO orders VALUES (1, 150.00, 'shipped'),
                          (2, 75.50, 'pending'),
                          (3, 200.00, 'shipped'),
                          (4, 30.00, 'cancelled');

SELECT * FROM orders WHERE amount &gt; 100 AND status = 'shipped';
-- 1|150.0|shipped
-- 3|200.0|shipped
</code></pre>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<p>Bitwise operators work on the integer representation of their operands. Non-integer operands are cast to integers before the operation.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>expr1 &amp; expr2</code></td><td>Bitwise AND. Sets each bit to 1 only if both corresponding bits are 1.</td></tr>
<tr><td><code>expr1 | expr2</code></td><td>Bitwise OR. Sets each bit to 1 if either corresponding bit is 1.</td></tr>
<tr><td><code>~expr</code></td><td>Bitwise NOT (unary). Inverts every bit.</td></tr>
<tr><td><code>expr1 &lt;&lt; expr2</code></td><td>Left shift. Shifts bits of <code>expr1</code> left by <code>expr2</code> positions, filling with zeros.</td></tr>
<tr><td><code>expr1 &gt;&gt; expr2</code></td><td>Right shift. Shifts bits of <code>expr1</code> right by <code>expr2</code> positions.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT 5 &amp; 3;       -- 1    (0101 &amp; 0011 = 0001)
SELECT 5 | 3;       -- 7    (0101 | 0011 = 0111)
SELECT ~5;          -- -6   (inverts all 64 bits)
SELECT 1 &lt;&lt; 4;      -- 16   (shift 1 left by 4 positions)
SELECT 16 &gt;&gt; 2;     -- 4    (shift 16 right by 2 positions)
SELECT 0xFF &amp; 0x0F; -- 15   (mask lower nibble)
SELECT 0xF0 | 0x0F; -- 255  (combine nibbles)
</code></pre>
<h2 id="null-handling-summary"><a class="header" href="#null-handling-summary">NULL Handling Summary</a></h2>
<p>Most operators propagate NULL: if any operand is NULL, the result is NULL. The exceptions are:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>NULL Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>IS</code> / <code>IS NOT</code></td><td>Never returns NULL. Treats NULL as a comparable value.</td></tr>
<tr><td><code>IS DISTINCT FROM</code> / <code>IS NOT DISTINCT FROM</code></td><td>Never returns NULL. Same as <code>IS NOT</code> / <code>IS</code>.</td></tr>
<tr><td><code>AND</code></td><td>Returns 0 if the other operand is 0, even when one operand is NULL.</td></tr>
<tr><td><code>OR</code></td><td>Returns 1 if the other operand is 1, even when one operand is NULL.</td></tr>
<tr><td><code>||</code></td><td>Returns NULL if either operand is NULL.</td></tr>
</tbody>
</table>
</div>
<h2 id="compatibility-15"><a class="header" href="#compatibility-15">Compatibility</a></h2>
<p>The <code>!&lt;</code> (not less than) and <code>!&gt;</code> (not greater than) operators recognized by some databases are not supported. Use <code>&gt;=</code> and <code>&lt;=</code> instead.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="literals"><a class="header" href="#literals">Literals</a></h1>
<p>A literal (also called a constant) is a fixed value written directly in a SQL statement. Turso supports six kinds of literal values: integers, reals, strings, blobs, NULL, and booleans.</p>
<h2 id="integer-literals"><a class="header" href="#integer-literals">Integer Literals</a></h2>
<p>An integer literal is a sequence of decimal digits with no decimal point and no exponent. Integer values are stored as 64-bit signed integers, supporting the range -9223372036854775808 to 9223372036854775807.</p>
<pre><code class="language-sql">SELECT 42;       -- 42
SELECT -100;     -- -100
SELECT 0;        -- 0
</code></pre>
<p>If a numeric literal without a decimal point or exponent exceeds the 64-bit signed integer range, it is automatically treated as a real (floating-point) value:</p>
<pre><code class="language-sql">SELECT typeof(9223372036854775807);  -- integer (fits in 64-bit)
SELECT typeof(9223372036854775808);  -- real (exceeds 64-bit range)
</code></pre>
<h3 id="hexadecimal-integers"><a class="header" href="#hexadecimal-integers">Hexadecimal Integers</a></h3>
<p>Integer literals may also be written in hexadecimal using the <code>0x</code> or <code>0X</code> prefix followed by hexadecimal digits (<code>0</code>-<code>9</code>, <code>a</code>-<code>f</code>, <code>A</code>-<code>F</code>). Hexadecimal literals are interpreted as 64-bit two’s-complement integers.</p>
<pre><code class="language-sql">SELECT 0x1F;     -- 31
SELECT 0xFF;     -- 255
SELECT 0x0;      -- 0
SELECT 0X1F;     -- 31 (uppercase prefix also works)
</code></pre>
<p>Hexadecimal notation is recognized only in SQL literal syntax. Runtime string-to-integer conversions (such as <code>CAST('0xFF' AS INTEGER)</code>) do not interpret hex prefixes.</p>
<h2 id="real-literals"><a class="header" href="#real-literals">Real Literals</a></h2>
<p>A numeric literal is treated as a real (floating-point) value if it contains a decimal point, an exponent clause, or both. Real values are stored as 8-byte IEEE 754 floating-point numbers.</p>
<h3 id="decimal-point"><a class="header" href="#decimal-point">Decimal Point</a></h3>
<pre><code class="language-sql">SELECT 3.14;     -- 3.14
SELECT .5;       -- 0.5
SELECT 100.0;    -- 100.0
</code></pre>
<h3 id="scientific-notation"><a class="header" href="#scientific-notation">Scientific Notation</a></h3>
<p>An exponent clause consists of the letter <code>E</code> or <code>e</code>, an optional sign (<code>+</code> or <code>-</code>), and one or more digits:</p>
<pre><code class="language-sql">SELECT 2.5e3;    -- 2500.0
SELECT 1.5E-2;   -- 0.015
SELECT 1e10;     -- 10000000000.0
</code></pre>
<h3 id="underscore-separators"><a class="header" href="#underscore-separators">Underscore Separators</a></h3>
<p>For readability, a single underscore (<code>_</code>) may be placed between any two digits in a numeric literal. Underscores are ignored during parsing and do not affect the value. This works for both integer and real literals.</p>
<pre><code class="language-sql">SELECT 1_000_000;       -- 1000000
SELECT 1_000.000_001;   -- 1000.000001
</code></pre>
<h2 id="string-literals"><a class="header" href="#string-literals">String Literals</a></h2>
<p>A string literal is a sequence of characters enclosed in single quotes (<code>'</code>). The value has TEXT storage class.</p>
<pre><code class="language-sql">SELECT 'Hello, world!';   -- Hello, world!
SELECT '';                 -- (empty string)
</code></pre>
<h3 id="escaping-single-quotes"><a class="header" href="#escaping-single-quotes">Escaping Single Quotes</a></h3>
<p>To include a literal single-quote character within a string, write two single quotes in a row (<code>''</code>). This is the standard SQL escaping mechanism. C-style backslash escapes (<code>\'</code>) are not supported.</p>
<pre><code class="language-sql">SELECT 'It''s a test';    -- It's a test
SELECT 'She said ''hi'''; -- She said 'hi'
</code></pre>
<h2 id="blob-literals"><a class="header" href="#blob-literals">Blob Literals</a></h2>
<p>A blob literal is a string of hexadecimal digits preceded by <code>X</code> or <code>x</code> and enclosed in single quotes. Each pair of hex digits represents one byte. The number of hex digits must be even. The value has BLOB storage class.</p>
<pre><code class="language-sql">SELECT X'48656C6C6F';           -- blob containing bytes for "Hello"
SELECT typeof(X'48656C6C6F');   -- blob
SELECT length(X'48656C6C6F');   -- 5
SELECT x'48656C6C6F';           -- lowercase x prefix also works
SELECT X'FF';                   -- single byte: 0xFF
</code></pre>
<p>A blob literal with no hex digits (<code>X''</code>) produces a zero-length blob.</p>
<p>Invalid blob literals are rejected at parse time. The hex digits must be valid (<code>0</code>-<code>9</code>, <code>a</code>-<code>f</code>, <code>A</code>-<code>F</code>) and the total count must be even.</p>
<h2 id="null"><a class="header" href="#null">NULL</a></h2>
<p>The keyword <code>NULL</code> represents a missing or unknown value. NULL is its own storage class and is distinct from any other value, including zero, an empty string, or a zero-length blob.</p>
<pre><code class="language-sql">SELECT NULL;            -- (empty result)
SELECT typeof(NULL);    -- null
</code></pre>
<p>NULL propagates through most operations. An expression involving NULL generally produces NULL:</p>
<pre><code class="language-sql">SELECT NULL + 5;        -- NULL
</code></pre>
<p>Use <code>IS NULL</code> or <code>IS NOT NULL</code> to test for null values. The <code>=</code> operator does not match NULL because NULL is not equal to anything, including itself.</p>
<h2 id="boolean-literals"><a class="header" href="#boolean-literals">Boolean Literals</a></h2>
<p>Turso recognizes <code>TRUE</code> and <code>FALSE</code> as boolean literals. They are aliases for the integer values 1 and 0, respectively.</p>
<pre><code class="language-sql">SELECT TRUE;            -- 1
SELECT FALSE;           -- 0
SELECT typeof(TRUE);    -- integer
SELECT typeof(FALSE);   -- integer
</code></pre>
<p>Because <code>TRUE</code> and <code>FALSE</code> are integers, they participate in arithmetic like any other integer:</p>
<pre><code class="language-sql">SELECT TRUE + TRUE;     -- 2
</code></pre>
<h3 id="is-true--is-false"><a class="header" href="#is-true--is-false">IS TRUE / IS FALSE</a></h3>
<p>When <code>TRUE</code> or <code>FALSE</code> appear on the right-hand side of the <code>IS</code> operator, the expression performs a boolean evaluation of the left operand. Any non-zero, non-NULL value <code>IS TRUE</code>, and zero <code>IS FALSE</code>. NULL is neither true nor false.</p>
<pre><code class="language-sql">SELECT 5 IS TRUE;       -- 1 (non-zero is true)
SELECT 0 IS FALSE;      -- 1 (zero is false)
SELECT NULL IS TRUE;    -- 0 (NULL is not true)
SELECT NULL IS FALSE;   -- 0 (NULL is not false)
</code></pre>
<h2 id="determining-literal-type"><a class="header" href="#determining-literal-type">Determining Literal Type</a></h2>
<p>Use the <code>typeof()</code> function to inspect the storage class of any literal:</p>
<pre><code class="language-sql">SELECT typeof(42);              -- integer
SELECT typeof(3.14);            -- real
SELECT typeof('hello');         -- text
SELECT typeof(X'FF');           -- blob
SELECT typeof(NULL);            -- null
SELECT typeof(TRUE);            -- integer
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Literal Kind</th><th>Syntax</th><th>Storage Class</th></tr>
</thead>
<tbody>
<tr><td>Integer</td><td><code>42</code>, <code>-7</code>, <code>0xFF</code></td><td>INTEGER</td></tr>
<tr><td>Real</td><td><code>3.14</code>, <code>2.5e3</code>, <code>.5</code></td><td>REAL</td></tr>
<tr><td>String</td><td><code>'text'</code></td><td>TEXT</td></tr>
<tr><td>Blob</td><td><code>X'hex'</code></td><td>BLOB</td></tr>
<tr><td>NULL</td><td><code>NULL</code></td><td>NULL</td></tr>
<tr><td>Boolean</td><td><code>TRUE</code>, <code>FALSE</code></td><td>INTEGER</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="conditional-expressions"><a class="header" href="#conditional-expressions">Conditional Expressions</a></h1>
<p>Turso provides several ways to express conditional logic within SQL queries: the <code>CASE</code> expression for general-purpose branching, and the built-in functions <code>IIF</code>, <code>COALESCE</code>, <code>NULLIF</code>, and <code>IFNULL</code> for common patterns.</p>
<h2 id="case"><a class="header" href="#case">CASE</a></h2>
<h3 id="syntax-20"><a class="header" href="#syntax-20">Syntax</a></h3>
<p>There are two forms of the <code>CASE</code> expression.</p>
<p><strong>Searched CASE</strong> (without a base expression):</p>
<pre><code class="language-sql">CASE
  WHEN condition THEN result
  [WHEN condition THEN result ...]
  [ELSE default]
END
</code></pre>
<p><strong>Simple CASE</strong> (with a base expression):</p>
<pre><code class="language-sql">CASE expr
  WHEN value THEN result
  [WHEN value THEN result ...]
  [ELSE default]
END
</code></pre>
<h3 id="description-20"><a class="header" href="#description-20">Description</a></h3>
<p>The <code>CASE</code> expression evaluates a series of conditions and returns the result associated with the first condition that is true.</p>
<p>In the <strong>searched form</strong>, each <code>WHEN</code> clause contains an arbitrary boolean expression. Turso evaluates the <code>WHEN</code> expressions from left to right and returns the <code>THEN</code> result corresponding to the first expression that is true. A <code>WHEN</code> expression is considered true if its result is non-zero and non-NULL.</p>
<p>In the <strong>simple form</strong>, Turso evaluates the base expression once, then compares it against each <code>WHEN</code> value from left to right using the <code>=</code> operator. The result of the first matching <code>WHEN</code> value is returned. Because <code>NULL = NULL</code> evaluates to <code>NULL</code> (not true), a <code>NULL</code> base expression will never match any <code>WHEN</code> value, and the <code>ELSE</code> branch (or <code>NULL</code>) is returned.</p>
<p>Both forms use <strong>short-circuit evaluation</strong>: once a matching <code>WHEN</code> is found, the remaining <code>WHEN</code> clauses are not evaluated. If no <code>WHEN</code> clause matches and there is no <code>ELSE</code>, the result is <code>NULL</code>.</p>
<h3 id="examples-20"><a class="header" href="#examples-20">Examples</a></h3>
<pre><code class="language-sql">-- Searched CASE: classify a number
SELECT CASE
  WHEN 1 &gt; 0 THEN 'positive'
  ELSE 'non-positive'
END;
-- positive
</code></pre>
<pre><code class="language-sql">-- Simple CASE: map a value to a label
SELECT CASE 2
  WHEN 1 THEN 'one'
  WHEN 2 THEN 'two'
  WHEN 3 THEN 'three'
  ELSE 'other'
END;
-- two
</code></pre>
<pre><code class="language-sql">-- Multiple WHEN clauses; first match wins
SELECT CASE
  WHEN 1 = 2 THEN 'first'
  WHEN 2 = 3 THEN 'second'
  WHEN 3 = 3 THEN 'third'
  ELSE 'none'
END;
-- third
</code></pre>
<pre><code class="language-sql">-- NULL and 0 are not true in WHEN conditions
SELECT CASE WHEN NULL THEN 'yes' ELSE 'no' END;
-- no

SELECT CASE WHEN 0 THEN 'matched' END;
-- NULL (no ELSE clause, so NULL is returned)
</code></pre>
<pre><code class="language-sql">-- NULL base expression never matches
SELECT CASE NULL
  WHEN 1    THEN 'one'
  WHEN NULL THEN 'null'
  ELSE 'else'
END;
-- else
</code></pre>
<pre><code class="language-sql">-- Categorize product availability
CREATE TABLE products (name TEXT, price REAL, stock INTEGER);
INSERT INTO products VALUES ('Widget', 25.99, 100);
INSERT INTO products VALUES ('Gadget', 0, 50);
INSERT INTO products VALUES ('Doohickey', 15.50, 0);

SELECT name,
  CASE
    WHEN stock = 0  THEN 'out of stock'
    WHEN stock &lt; 20 THEN 'low stock'
    ELSE 'in stock'
  END AS availability
FROM products;
-- Widget    | in stock
-- Gadget    | in stock
-- Doohickey | out of stock
</code></pre>
<h2 id="iif"><a class="header" href="#iif">iif</a></h2>
<p><strong>iif(condition, true_value, false_value) -&gt; value</strong></p>
<p>Returns <code>true_value</code> if <code>condition</code> is true (non-zero and non-NULL), otherwise returns <code>false_value</code>. This is a shorthand for <code>CASE WHEN condition THEN true_value ELSE false_value END</code>.</p>
<pre><code class="language-sql">SELECT iif(1, 'true', 'false');
-- true

SELECT iif(10 &gt; 5, 'big', 'small');
-- big
</code></pre>
<pre><code class="language-sql">-- Label orders based on status
CREATE TABLE orders (id INTEGER, total REAL, status TEXT);
INSERT INTO orders VALUES (1, 150.00, 'shipped');
INSERT INTO orders VALUES (2, 0, 'pending');
INSERT INTO orders VALUES (3, 75.50, 'delivered');

SELECT id, iif(status = 'shipped', 'in transit', 'other') AS label
FROM orders;
-- 1 | in transit
-- 2 | other
-- 3 | other
</code></pre>
<h2 id="coalesce"><a class="header" href="#coalesce">coalesce</a></h2>
<p><strong>coalesce(x, y, …) -&gt; value</strong></p>
<p>Returns the first argument that is not <code>NULL</code>. If all arguments are <code>NULL</code>, returns <code>NULL</code>. Requires at least two arguments.</p>
<p><code>COALESCE</code> uses short-circuit evaluation: arguments to the right of the first non-NULL value are not evaluated.</p>
<pre><code class="language-sql">SELECT coalesce(NULL, NULL, 'third');
-- third

SELECT coalesce(NULL, NULL);
-- NULL
</code></pre>
<pre><code class="language-sql">-- Pick the best available contact method
CREATE TABLE contacts (name TEXT, phone TEXT, email TEXT);
INSERT INTO contacts VALUES ('Alice', NULL, 'alice@example.com');
INSERT INTO contacts VALUES ('Bob', '555-1234', NULL);
INSERT INTO contacts VALUES ('Charlie', NULL, NULL);

SELECT name, coalesce(phone, email, 'no contact info') AS contact
FROM contacts;
-- Alice   | alice@example.com
-- Bob     | 555-1234
-- Charlie | no contact info
</code></pre>
<h2 id="nullif"><a class="header" href="#nullif">nullif</a></h2>
<p><strong>nullif(x, y) -&gt; value</strong></p>
<p>Returns <code>x</code> if <code>x</code> and <code>y</code> are different. Returns <code>NULL</code> if <code>x</code> and <code>y</code> are equal. The comparison uses the same rules as the <code>=</code> operator.</p>
<p>A common use of <code>NULLIF</code> is to convert a sentinel value (such as zero or an empty string) into <code>NULL</code>, which can then be handled by <code>COALESCE</code>, <code>IFNULL</code>, or aggregate functions that skip <code>NULL</code> values.</p>
<pre><code class="language-sql">SELECT nullif(5, 5);
-- NULL

SELECT nullif(5, 8);
-- 5
</code></pre>
<pre><code class="language-sql">-- Prevent division by zero (dividing by NULL yields NULL instead of an error)
SELECT 100.0 / nullif(0, 0);
-- NULL

SELECT 100.0 / nullif(5, 0);
-- 20.0
</code></pre>
<pre><code class="language-sql">-- Convert zero prices to NULL
CREATE TABLE products (name TEXT, price REAL, stock INTEGER);
INSERT INTO products VALUES ('Widget', 25.99, 100);
INSERT INTO products VALUES ('Gadget', 0, 50);
INSERT INTO products VALUES ('Doohickey', 15.50, 0);

SELECT name, nullif(price, 0) AS nonzero_price
FROM products;
-- Widget    | 25.99
-- Gadget    | NULL
-- Doohickey | 15.5
</code></pre>
<h2 id="ifnull"><a class="header" href="#ifnull">ifnull</a></h2>
<p><strong>ifnull(x, y) -&gt; value</strong></p>
<p>Returns <code>x</code> if <code>x</code> is not <code>NULL</code>, otherwise returns <code>y</code>. This is equivalent to <code>coalesce(x, y)</code> with exactly two arguments.</p>
<pre><code class="language-sql">SELECT ifnull(NULL, 'fallback');
-- fallback

SELECT ifnull('present', 'fallback');
-- present
</code></pre>
<pre><code class="language-sql">-- Provide a default for missing phone numbers
CREATE TABLE contacts (name TEXT, phone TEXT, email TEXT);
INSERT INTO contacts VALUES ('Alice', NULL, 'alice@example.com');
INSERT INTO contacts VALUES ('Bob', '555-1234', NULL);
INSERT INTO contacts VALUES ('Charlie', NULL, NULL);

SELECT name, ifnull(phone, 'N/A') AS phone
FROM contacts;
-- Alice   | N/A
-- Bob     | 555-1234
-- Charlie | N/A
</code></pre>
<h2 id="choosing-the-right-construct"><a class="header" href="#choosing-the-right-construct">Choosing the Right Construct</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Need</th><th>Use</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Multi-way branching</td><td><code>CASE WHEN ... THEN ... END</code></td><td>Classify rows into categories</td></tr>
<tr><td>Match a value against a list</td><td><code>CASE expr WHEN ... THEN ... END</code></td><td>Map status codes to labels</td></tr>
<tr><td>Simple if/else in one line</td><td><code>iif(cond, a, b)</code></td><td>Toggle between two values</td></tr>
<tr><td>First non-NULL from a list</td><td><code>coalesce(a, b, c)</code></td><td>Pick best available contact</td></tr>
<tr><td>Convert a value to NULL</td><td><code>nullif(x, sentinel)</code></td><td>Turn 0 into NULL before division</td></tr>
<tr><td>Default for a single NULL</td><td><code>ifnull(x, default)</code></td><td>Replace NULL with a placeholder</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>Turso provides three pattern-matching operators for comparing strings against patterns: <code>LIKE</code>, <code>GLOB</code>, and <code>REGEXP</code>. Each uses different wildcard conventions and case-sensitivity rules. All three can be negated with the <code>NOT</code> keyword.</p>
<h2 id="syntax-21"><a class="header" href="#syntax-21">Syntax</a></h2>
<pre><code class="language-sql">expr [NOT] LIKE pattern [ESCAPE escape-char]
expr [NOT] GLOB pattern
expr [NOT] REGEXP pattern
</code></pre>
<p>Each operator returns <code>1</code> (true) if the string matches the pattern, <code>0</code> (false) if it does not, or <code>NULL</code> if either operand is <code>NULL</code>.</p>
<h2 id="like"><a class="header" href="#like">LIKE</a></h2>
<p>The <code>LIKE</code> operator performs pattern matching using two wildcard characters:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Wildcard</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>%</code></td><td>Matches any sequence of zero or more characters.</td></tr>
<tr><td><code>_</code></td><td>Matches exactly one character.</td></tr>
</tbody>
</table>
</div>
<p>Any other character in the pattern matches itself. <code>LIKE</code> is <strong>case-insensitive for ASCII characters</strong> by default – <code>'a' LIKE 'A'</code> evaluates to true. For Unicode characters outside the ASCII range, <code>LIKE</code> is case-sensitive: <code>'ä' LIKE 'Ä'</code> evaluates to false.</p>
<pre><code class="language-sql">-- % matches any sequence of characters
SELECT 'sweater' LIKE 'sweat%';   -- 1
SELECT 'sweatshirt' LIKE 'sweat%'; -- 1
SELECT 'hat' LIKE 'sweat%';       -- 0

-- _ matches exactly one character
SELECT 'sweater' LIKE 'sweat_r';  -- 1
SELECT 'sweatshirt' LIKE 'sweat_r'; -- 0

-- Case-insensitive for ASCII
SELECT 'sweater' LIKE 'SWEAT%';   -- 1
SELECT 'sweater' LIKE 'SwEaT_R';  -- 1
</code></pre>
<p>The <code>%</code> and <code>_</code> wildcards can be combined to build expressive patterns. Use <code>%</code> at the beginning and end of a pattern to search for a substring anywhere in a string:</p>
<pre><code class="language-sql">SELECT 'hello world' LIKE '%world%'; -- 1
SELECT 'hello world' LIKE '%xyz%';   -- 0
</code></pre>
<h3 id="escape-clause"><a class="header" href="#escape-clause">ESCAPE Clause</a></h3>
<p>To match a literal <code>%</code> or <code>_</code> character in a pattern, use the <code>ESCAPE</code> clause. The escape character causes the next <code>%</code>, <code>_</code>, or the escape character itself to be treated as a literal rather than a wildcard.</p>
<pre><code class="language-sql">-- Match a literal % character using \ as the escape character
SELECT '10%' LIKE '10\%' ESCAPE '\';  -- 1
SELECT '10x' LIKE '10\%' ESCAPE '\';  -- 0
</code></pre>
<p>The escape character must be a single character. If the <code>ESCAPE</code> value is <code>NULL</code>, the entire <code>LIKE</code> expression evaluates to <code>NULL</code>.</p>
<pre><code class="language-sql">-- Any single character can serve as the escape character
SELECT 'a%bc' LIKE 'a5%%' ESCAPE '5'; -- 1
</code></pre>
<h3 id="not-like"><a class="header" href="#not-like">NOT LIKE</a></h3>
<p>Prefixing with <code>NOT</code> inverts the result:</p>
<pre><code class="language-sql">SELECT 'sweater' NOT LIKE 'sweat%'; -- 0
SELECT 'hat' NOT LIKE 'sweat%';     -- 1
</code></pre>
<h3 id="function-form"><a class="header" href="#function-form">Function Form</a></h3>
<p>The <code>LIKE</code> operator can also be invoked as a function. The infix expression <code>X LIKE Y</code> is equivalent to <code>like(Y, X)</code>, and <code>X LIKE Y ESCAPE Z</code> is equivalent to <code>like(Y, X, Z)</code>. Note that the pattern is the <strong>first</strong> argument in function form.</p>
<pre><code class="language-sql">SELECT like('sweat%', 'sweater');           -- 1
SELECT like('abcX%', 'abc%', 'X');          -- 1
</code></pre>
<h2 id="glob"><a class="header" href="#glob">GLOB</a></h2>
<p>The <code>GLOB</code> operator is similar to <code>LIKE</code> but uses Unix file-globbing syntax for wildcards and is <strong>case-sensitive</strong>.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Wildcard</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>*</code></td><td>Matches any sequence of zero or more characters (like <code>%</code> in LIKE).</td></tr>
<tr><td><code>?</code></td><td>Matches exactly one character (like <code>_</code> in LIKE).</td></tr>
<tr><td><code>[chars]</code></td><td>Matches one character from the set or range inside the brackets.</td></tr>
<tr><td><code>[^chars]</code></td><td>Matches one character <strong>not</strong> in the set or range inside the brackets.</td></tr>
</tbody>
</table>
</div>
<p>Because <code>GLOB</code> is case-sensitive, <code>'hello' GLOB 'H*'</code> evaluates to false.</p>
<pre><code class="language-sql">-- * matches any sequence of characters
SELECT 'hello' GLOB 'h*';    -- 1
SELECT 'hello' GLOB 'H*';    -- 0 (case-sensitive)

-- ? matches exactly one character
SELECT 'hello' GLOB '?ello'; -- 1
SELECT 'hello' GLOB '??llo'; -- 1
</code></pre>
<h3 id="character-classes"><a class="header" href="#character-classes">Character Classes</a></h3>
<p>Square brackets define a set of characters to match against a single position. A range can be specified with a hyphen. Use <code>^</code> after the opening bracket to negate the set.</p>
<pre><code class="language-sql">-- [cde] matches one character that is c, d, or e
SELECT 'abcdefg' GLOB 'abc[cde]efg'; -- 1 (d matches [cde])
SELECT 'abcbefg' GLOB 'abc[cde]efg'; -- 0 (b not in [cde])

-- [c-e] matches one character in the range c through e
SELECT 'abcdefg' GLOB 'abc[c-e]efg'; -- 1
SELECT 'abcfefg' GLOB 'abc[c-e]efg'; -- 0

-- [^cde] matches one character NOT in the set
SELECT 'abcbefg' GLOB 'abc[^cde]efg'; -- 1
SELECT 'abccefg' GLOB 'abc[^cde]efg'; -- 0
</code></pre>
<p>A literal <code>-</code> can be included in a character class by placing it first or last: <code>[-c]</code> matches either <code>-</code> or <code>c</code>.</p>
<pre><code class="language-sql">SELECT '-' GLOB '[-c]'; -- 1
SELECT 'c' GLOB '[-c]'; -- 1
SELECT 'x' GLOB '[-c]'; -- 0
</code></pre>
<h3 id="not-glob"><a class="header" href="#not-glob">NOT GLOB</a></h3>
<p>Prefixing with <code>NOT</code> inverts the result:</p>
<pre><code class="language-sql">SELECT 'hello' NOT GLOB 'h*'; -- 0
SELECT 'hello' NOT GLOB 'H*'; -- 1
</code></pre>
<h3 id="function-form-1"><a class="header" href="#function-form-1">Function Form</a></h3>
<p>The infix expression <code>X GLOB Y</code> is equivalent to <code>glob(Y, X)</code>. The pattern is the <strong>first</strong> argument.</p>
<pre><code class="language-sql">SELECT glob('h*', 'hello');       -- 1
SELECT glob('[a-k]*', 'hello');   -- 1
</code></pre>
<h2 id="regexp"><a class="header" href="#regexp">REGEXP</a></h2>
<p>The <code>REGEXP</code> operator tests whether a string matches a regular expression pattern. Turso provides a built-in <code>regexp()</code> function, so <code>REGEXP</code> works without loading an extension.</p>
<p>The infix expression <code>X REGEXP Y</code> is equivalent to <code>regexp(Y, X)</code>. The pattern is the <strong>first</strong> argument in function form.</p>
<pre><code class="language-sql">SELECT 'hello' REGEXP 'h.*o';      -- 1
SELECT 'hello' REGEXP '^world$';   -- 0
</code></pre>
<p><code>REGEXP</code> supports standard regular expression syntax, including character classes, anchors, quantifiers, and escape sequences:</p>
<pre><code class="language-sql">-- Anchors: ^ (start of string) and $ (end of string)
SELECT 'hello' REGEXP '^hello$'; -- 1
SELECT 'hello' REGEXP '^ello';   -- 0

-- Character classes and quantifiers
SELECT 'test@example.com' REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'; -- 1

-- \d for digits, \b for word boundaries
SELECT '2024-01-15' REGEXP '^\d{4}-\d{2}-\d{2}$'; -- 1
SELECT 'hello world' REGEXP '\bworld\b';           -- 1
</code></pre>
<h3 id="not-regexp"><a class="header" href="#not-regexp">NOT REGEXP</a></h3>
<p>Prefixing with <code>NOT</code> inverts the result:</p>
<pre><code class="language-sql">SELECT 'hello' NOT REGEXP 'h.*o';     -- 0
SELECT 'hello' NOT REGEXP '^world$';  -- 1
</code></pre>
<h3 id="using-regexp-in-queries"><a class="header" href="#using-regexp-in-queries">Using REGEXP in Queries</a></h3>
<p><code>REGEXP</code> can be used in <code>WHERE</code> clauses, <code>CASE</code> expressions, and subqueries just like any other boolean expression:</p>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, sku TEXT);
INSERT INTO products VALUES (1, 'Widget A', 'WGT-001'),
                            (2, 'Gadget B', 'GDT-002'),
                            (3, 'Widget C', 'WGT-003'),
                            (4, 'Doohickey', 'DHK-004');

-- Filter rows with REGEXP in WHERE
SELECT name FROM products WHERE sku REGEXP '^WGT';
-- Widget A
-- Widget C

-- Classify rows with REGEXP in CASE
SELECT name,
       CASE WHEN name REGEXP '^Widget' THEN 'widget'
            ELSE 'other'
       END AS category
FROM products;
-- Widget A|widget
-- Gadget B|other
-- Widget C|widget
-- Doohickey|other
</code></pre>
<h2 id="null-handling-2"><a class="header" href="#null-handling-2">NULL Handling</a></h2>
<p>For all three operators, if either operand is <code>NULL</code>, the result is <code>NULL</code>:</p>
<pre><code class="language-sql">SELECT NULL LIKE 'hello';  -- NULL (empty result)
SELECT 'hello' LIKE NULL;  -- NULL (empty result)
SELECT NULL GLOB 'h*';     -- NULL (empty result)
SELECT NULL REGEXP 'abc';  -- NULL (empty result)
</code></pre>
<h2 id="comparison-of-operators"><a class="header" href="#comparison-of-operators">Comparison of Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>LIKE</th><th>GLOB</th><th>REGEXP</th></tr>
</thead>
<tbody>
<tr><td>Case sensitivity</td><td>Case-insensitive (ASCII)</td><td>Case-sensitive</td><td>Depends on pattern</td></tr>
<tr><td>Zero-or-more wildcard</td><td><code>%</code></td><td><code>*</code></td><td><code>.*</code></td></tr>
<tr><td>Single-char wildcard</td><td><code>_</code></td><td><code>?</code></td><td><code>.</code></td></tr>
<tr><td>Character classes</td><td>No</td><td><code>[abc]</code>, <code>[a-z]</code>, <code>[^abc]</code></td><td><code>[abc]</code>, <code>[a-z]</code>, <code>[^abc]</code>, <code>\d</code>, <code>\w</code>, etc.</td></tr>
<tr><td>Escape clause</td><td><code>ESCAPE</code> keyword</td><td>No</td><td><code>\</code> (backslash)</td></tr>
<tr><td>Negation</td><td><code>NOT LIKE</code></td><td><code>NOT GLOB</code></td><td><code>NOT REGEXP</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="type-conversions"><a class="header" href="#type-conversions">Type Conversions</a></h1>
<p>Turso uses a dynamic type system inherited from SQLite. Every value belongs to one of five storage classes – NULL, INTEGER, REAL, TEXT, or BLOB – but columns do not enforce a single type. Instead, each column has a <strong>type affinity</strong> that recommends how values should be stored. This page covers how type affinities are determined, how values are coerced on insertion, how the <code>CAST</code> expression performs explicit conversions, and how types interact during comparisons.</p>
<h2 id="storage-classes"><a class="header" href="#storage-classes">Storage Classes</a></h2>
<p>Every value in Turso has exactly one storage class at any given time. Use the <code>typeof()</code> function to inspect it:</p>
<pre><code class="language-sql">SELECT typeof(42);        -- integer
SELECT typeof(3.14);      -- real
SELECT typeof('hello');   -- text
SELECT typeof(x'ABCD');  -- blob
SELECT typeof(NULL);      -- null
</code></pre>
<p>Arithmetic and string operations produce values whose storage class follows from the operation:</p>
<pre><code class="language-sql">SELECT typeof(1 + 1);      -- integer
SELECT typeof(1 + 1.0);    -- real (integer promoted to real)
SELECT typeof('a' || 'b'); -- text
</code></pre>
<h2 id="type-affinity-1"><a class="header" href="#type-affinity-1">Type Affinity</a></h2>
<p>A column’s type affinity is determined by the declared type name in the <code>CREATE TABLE</code> statement. Affinity is a recommendation, not a constraint – any column can store a value of any storage class.</p>
<h3 id="the-five-affinities"><a class="header" href="#the-five-affinities">The Five Affinities</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Affinity</th><th>Behavior on INSERT</th></tr>
</thead>
<tbody>
<tr><td>TEXT</td><td>Numeric values are converted to their text representation before storage.</td></tr>
<tr><td>NUMERIC</td><td>Text that looks like an integer or real number is converted to INTEGER or REAL.</td></tr>
<tr><td>INTEGER</td><td>Behaves identically to NUMERIC on insertion. Differs from NUMERIC only in <code>CAST</code> expressions.</td></tr>
<tr><td>REAL</td><td>Like NUMERIC, but integer values are stored as floating-point.</td></tr>
<tr><td>BLOB</td><td>No conversion. Values are stored exactly as provided.</td></tr>
</tbody>
</table>
</div>
<h3 id="affinity-determination-rules"><a class="header" href="#affinity-determination-rules">Affinity Determination Rules</a></h3>
<p>The affinity of a column is determined by applying the following rules to the declared type name, in order. The first matching rule wins:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rule</th><th>Condition</th><th>Resulting Affinity</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>Type name contains <code>"INT"</code></td><td>INTEGER</td></tr>
<tr><td>2</td><td>Type name contains <code>"CHAR"</code>, <code>"CLOB"</code>, or <code>"TEXT"</code></td><td>TEXT</td></tr>
<tr><td>3</td><td>Type name contains <code>"BLOB"</code>, or no type is specified</td><td>BLOB</td></tr>
<tr><td>4</td><td>Type name contains <code>"REAL"</code>, <code>"FLOA"</code>, or <code>"DOUB"</code></td><td>REAL</td></tr>
<tr><td>5</td><td>Otherwise</td><td>NUMERIC</td></tr>
</tbody>
</table>
</div>
<p>The matching is case-insensitive and checks for substrings anywhere in the declared type name. Because rules are applied in order, some type names produce counterintuitive results:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Declared Type</th><th>Matching Rule</th><th>Affinity</th></tr>
</thead>
<tbody>
<tr><td><code>INT</code>, <code>INTEGER</code>, <code>BIGINT</code>, <code>SMALLINT</code></td><td>1 (contains “INT”)</td><td>INTEGER</td></tr>
<tr><td><code>TEXT</code>, <code>VARCHAR(255)</code>, <code>CLOB</code></td><td>2 (contains “TEXT”, “CHAR”, or “CLOB”)</td><td>TEXT</td></tr>
<tr><td><code>BLOB</code>, (no type)</td><td>3 (contains “BLOB” or empty)</td><td>BLOB</td></tr>
<tr><td><code>REAL</code>, <code>DOUBLE</code>, <code>FLOAT</code></td><td>4 (contains “REAL”, “DOUB”, or “FLOA”)</td><td>REAL</td></tr>
<tr><td><code>NUMERIC</code>, <code>DECIMAL(10,5)</code>, <code>BOOLEAN</code>, <code>DATE</code></td><td>5 (no match above)</td><td>NUMERIC</td></tr>
<tr><td><code>CHARINT</code></td><td>1 (contains “INT”, rule 1 before rule 2)</td><td>INTEGER</td></tr>
<tr><td><code>FLOATING POINT</code></td><td>1 (contains “INT” in “POINT”)</td><td>INTEGER</td></tr>
<tr><td><code>STRING</code></td><td>5 (no match for rules 1-4)</td><td>NUMERIC</td></tr>
</tbody>
</table>
</div>
<h3 id="affinity-in-action"><a class="header" href="#affinity-in-action">Affinity in Action</a></h3>
<p>When a value is inserted into a column, the column’s affinity determines whether a type conversion is attempted. Conversions only happen if they are lossless and reversible.</p>
<pre><code class="language-sql">CREATE TABLE demo (
  t TEXT,
  n NUMERIC,
  i INTEGER,
  r REAL,
  b BLOB
);

-- Insert the string '500' into every column
INSERT INTO demo VALUES ('500', '500', '500', '500', '500');
SELECT typeof(t), typeof(n), typeof(i), typeof(r), typeof(b) FROM demo;
-- text|integer|integer|real|text
</code></pre>
<p>Here is what happened to the string <code>'500'</code> in each column:</p>
<ul>
<li><strong>t (TEXT)</strong>: Stored as text. No conversion needed.</li>
<li><strong>n (NUMERIC)</strong>: Converted to integer 500 because <code>'500'</code> is a well-formed integer literal.</li>
<li><strong>i (INTEGER)</strong>: Converted to integer 500, same as NUMERIC.</li>
<li><strong>r (REAL)</strong>: Converted to real 500.0 because REAL affinity forces floating-point storage.</li>
<li><strong>b (BLOB)</strong>: Stored as text. BLOB affinity performs no conversion.</li>
</ul>
<pre><code class="language-sql">-- Insert the integer 500 into every column
DELETE FROM demo;
INSERT INTO demo VALUES (500, 500, 500, 500, 500);
SELECT typeof(t), typeof(n), typeof(i), typeof(r), typeof(b) FROM demo;
-- text|integer|integer|real|integer
</code></pre>
<ul>
<li><strong>t (TEXT)</strong>: Converted to text <code>'500'</code> because TEXT affinity converts numerics to text.</li>
<li><strong>n (NUMERIC)</strong>: Stored as integer. Already numeric.</li>
<li><strong>i (INTEGER)</strong>: Stored as integer. Already numeric.</li>
<li><strong>r (REAL)</strong>: Stored as real 500.0. REAL affinity promotes integers to floating-point.</li>
<li><strong>b (BLOB)</strong>: Stored as integer. BLOB affinity performs no conversion; the value keeps its original type.</li>
</ul>
<h3 id="null-and-blob-bypass-affinity"><a class="header" href="#null-and-blob-bypass-affinity">NULL and BLOB Bypass Affinity</a></h3>
<p>NULL values and BLOB values are never converted by affinity, regardless of the column’s declared type:</p>
<pre><code class="language-sql">DELETE FROM demo;
INSERT INTO demo VALUES (NULL, NULL, NULL, NULL, NULL);
SELECT typeof(t), typeof(n), typeof(i), typeof(r), typeof(b) FROM demo;
-- null|null|null|null|null
</code></pre>
<pre><code class="language-sql">DELETE FROM demo;
INSERT INTO demo VALUES (x'01', x'01', x'01', x'01', x'01');
SELECT typeof(t), typeof(n), typeof(i), typeof(r), typeof(b) FROM demo;
-- blob|blob|blob|blob|blob
</code></pre>
<h2 id="cast-expressions"><a class="header" href="#cast-expressions">CAST Expressions</a></h2>
<p>The <code>CAST</code> expression explicitly converts a value to a different storage class.</p>
<h3 id="syntax-22"><a class="header" href="#syntax-22">Syntax</a></h3>
<pre><code class="language-sql">CAST(expr AS type-name)
</code></pre>
<p>The <code>type-name</code> follows the same affinity determination rules as column type names. If <code>expr</code> is NULL, the result is always NULL.</p>
<h3 id="conversion-rules"><a class="header" href="#conversion-rules">Conversion Rules</a></h3>
<h4 id="cast-to-integer"><a class="header" href="#cast-to-integer">CAST to INTEGER</a></h4>
<p>Converts the value to a 64-bit signed integer.</p>
<ul>
<li><strong>From REAL</strong>: Truncates toward zero. Values outside the 64-bit integer range are clamped to the minimum or maximum value.</li>
<li><strong>From TEXT</strong>: Extracts the longest leading substring that is a valid integer. Leading whitespace is ignored. Returns 0 if no valid prefix exists.</li>
<li><strong>From BLOB</strong>: The blob is first interpreted as text, then the text-to-integer rules apply.</li>
</ul>
<pre><code class="language-sql">SELECT CAST(3.14 AS INTEGER);      -- 3
SELECT CAST(9.99 AS INTEGER);      -- 9
SELECT CAST(-7.8 AS INTEGER);      -- -7
SELECT CAST('42' AS INTEGER);      -- 42
SELECT CAST('123abc' AS INTEGER);  -- 123
SELECT CAST('abc' AS INTEGER);     -- 0
SELECT CAST('  42  ' AS INTEGER);  -- 42
SELECT CAST('' AS INTEGER);        -- 0
SELECT CAST('99.9' AS INTEGER);    -- 99
</code></pre>
<h4 id="cast-to-real"><a class="header" href="#cast-to-real">CAST to REAL</a></h4>
<p>Converts the value to an 8-byte IEEE 754 floating-point number.</p>
<ul>
<li><strong>From TEXT</strong>: Extracts the longest leading substring that is a valid real number. Returns 0.0 if no valid prefix exists.</li>
<li><strong>From INTEGER</strong>: Converts to the nearest representable floating-point value.</li>
<li><strong>From BLOB</strong>: The blob is first interpreted as text, then the text-to-real rules apply.</li>
</ul>
<pre><code class="language-sql">SELECT CAST(42 AS REAL);              -- 42.0
SELECT CAST('3.14' AS REAL);          -- 3.14
SELECT CAST('123.45abc' AS REAL);     -- 123.45
</code></pre>
<h4 id="cast-to-text"><a class="header" href="#cast-to-text">CAST to TEXT</a></h4>
<p>Converts the value to a text string.</p>
<ul>
<li><strong>From INTEGER or REAL</strong>: Renders the number as its string representation.</li>
<li><strong>From BLOB</strong>: Interprets the blob bytes as a UTF-8 text string.</li>
</ul>
<pre><code class="language-sql">SELECT CAST(42 AS TEXT);                    -- 42
SELECT CAST(x'68656C6C6F' AS TEXT);         -- hello
SELECT typeof(CAST(42 AS TEXT));            -- text
</code></pre>
<h4 id="cast-to-blob"><a class="header" href="#cast-to-blob">CAST to BLOB</a></h4>
<p>Converts the value to a blob.</p>
<ul>
<li><strong>From TEXT</strong>: The text is first encoded as UTF-8, then the resulting bytes are treated as a blob.</li>
<li><strong>From INTEGER or REAL</strong>: The value is first converted to text, then to blob.</li>
</ul>
<pre><code class="language-sql">SELECT typeof(CAST('hello' AS BLOB));  -- blob
</code></pre>
<h4 id="cast-to-numeric"><a class="header" href="#cast-to-numeric">CAST to NUMERIC</a></h4>
<p>CAST to NUMERIC returns either an INTEGER or a REAL, depending on the input:</p>
<ul>
<li>If the value looks like a well-formed integer and fits in 64 bits, the result is INTEGER.</li>
<li>If the value looks like a floating-point number, the result is REAL.</li>
<li>From REAL or INTEGER, the value is returned as-is.</li>
</ul>
<p>This is where INTEGER and NUMERIC affinity differ in CAST expressions:</p>
<pre><code class="language-sql">SELECT CAST(4.0 AS INTEGER), typeof(CAST(4.0 AS INTEGER));
-- 4|integer

SELECT CAST(4.0 AS NUMERIC), typeof(CAST(4.0 AS NUMERIC));
-- 4.0|real
</code></pre>
<p><code>CAST(4.0 AS INTEGER)</code> truncates the real value to an integer, while <code>CAST(4.0 AS NUMERIC)</code> preserves the real type because the input is already a REAL.</p>
<h2 id="comparison-and-type-affinity"><a class="header" href="#comparison-and-type-affinity">Comparison and Type Affinity</a></h2>
<p>When Turso compares two values, it may apply affinity conversions to the operands before performing the comparison. The rules depend on the affinities of the expressions being compared.</p>
<h3 id="affinity-application-during-comparisons"><a class="header" href="#affinity-application-during-comparisons">Affinity Application During Comparisons</a></h3>
<p>Before a comparison is performed, the following rules are applied in order:</p>
<ol>
<li>
<p><strong>If one operand has INTEGER, REAL, or NUMERIC affinity and the other has TEXT, BLOB, or no affinity</strong>: NUMERIC affinity is applied to the non-numeric operand. This means text that looks like a number is converted to a number before comparing.</p>
</li>
<li>
<p><strong>If one operand has TEXT affinity and the other has no affinity</strong>: TEXT affinity is applied to the operand with no affinity.</p>
</li>
<li>
<p><strong>Otherwise</strong>: No conversion is applied. Values are compared using their existing storage classes.</p>
</li>
</ol>
<h3 id="comparison-sort-order"><a class="header" href="#comparison-sort-order">Comparison Sort Order</a></h3>
<p>When comparing values of different storage classes, Turso follows this ordering:</p>
<ol>
<li><strong>NULL</strong> is less than any other value. (Note: <code>NULL &lt; x</code> evaluates to NULL, not TRUE. Use <code>IS NULL</code> to test for nulls. This ordering applies to <code>ORDER BY</code> and similar contexts.)</li>
<li><strong>INTEGER and REAL</strong> values are compared numerically with each other, and are less than any TEXT or BLOB value.</li>
<li><strong>TEXT</strong> values are less than BLOB values. Text comparisons use the applicable collating sequence (default: BINARY).</li>
<li><strong>BLOB</strong> values are compared byte-by-byte using <code>memcmp</code> ordering.</li>
</ol>
<h3 id="affinity-effects-on-comparisons"><a class="header" href="#affinity-effects-on-comparisons">Affinity Effects on Comparisons</a></h3>
<p>Column affinity can cause the same literal to compare differently depending on the column’s declared type:</p>
<pre><code class="language-sql">CREATE TABLE inventory (
  label TEXT,
  count NUMERIC
);
INSERT INTO inventory VALUES ('500', '500');

-- TEXT column: integer 40 is converted to text '40' for comparison
-- String comparison: '500' &gt; '40' (compares character by character)
SELECT label &lt; 40, label &lt; 60, label &lt; 600 FROM inventory;
-- 0|1|1

-- NUMERIC column: stored as integer 500, numeric comparison
SELECT count &lt; 40, count &lt; 60, count &lt; 600 FROM inventory;
-- 0|0|1
</code></pre>
<p>In the TEXT column example, the integer literal <code>40</code> is converted to the string <code>'40'</code> before comparing. In string comparison, <code>'500' &lt; '60'</code> is true because <code>'5' &lt; '6'</code> lexicographically. In the NUMERIC column, the value is already stored as integer 500, so the comparison is purely numeric.</p>
<h2 id="expression-affinity"><a class="header" href="#expression-affinity">Expression Affinity</a></h2>
<p>Expressions in SQL do not always carry an affinity. The rules for expression affinity are:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression</th><th>Affinity</th></tr>
</thead>
<tbody>
<tr><td>Column reference</td><td>Same affinity as the column</td></tr>
<tr><td><code>CAST(expr AS type)</code></td><td>Affinity determined by the type name</td></tr>
<tr><td>Unary <code>+</code> applied to a column (e.g., <code>+column</code>)</td><td>No affinity</td></tr>
<tr><td>Any operator or function result</td><td>No affinity</td></tr>
</tbody>
</table>
</div>
<p>The unary <code>+</code> operator is a common technique to strip affinity from a column reference, forcing the value to be compared without automatic type coercion.</p>
<h2 id="the-typeof-function"><a class="header" href="#the-typeof-function">The typeof() Function</a></h2>
<p>The <code>typeof()</code> function returns a string indicating the storage class of its argument. It is the primary tool for inspecting how Turso stores a value.</p>
<pre><code class="language-sql">SELECT typeof(42);                          -- integer
SELECT typeof(3.14);                        -- real
SELECT typeof('hello');                     -- text
SELECT typeof(x'FF');                       -- blob
SELECT typeof(NULL);                        -- null
SELECT typeof(CAST('42' AS INTEGER));       -- integer
</code></pre>
<p>The return value is always one of: <code>'null'</code>, <code>'integer'</code>, <code>'real'</code>, <code>'text'</code>, or <code>'blob'</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="in-and-between"><a class="header" href="#in-and-between">IN and BETWEEN</a></h1>
<p>Turso supports the <code>IN</code>, <code>NOT IN</code>, <code>BETWEEN</code>, and <code>NOT BETWEEN</code> operators for testing whether a value belongs to a set or falls within a range. These operators are commonly used in <code>WHERE</code> clauses to filter rows, but they can appear anywhere an expression is allowed.</p>
<h2 id="in-1"><a class="header" href="#in-1">IN</a></h2>
<h3 id="syntax-23"><a class="header" href="#syntax-23">Syntax</a></h3>
<pre><code class="language-sql">expr [NOT] IN (value [, ...])
expr [NOT] IN (select-stmt)
</code></pre>
<h3 id="description-21"><a class="header" href="#description-21">Description</a></h3>
<p>The <code>IN</code> operator tests whether the left-hand expression is equal to any value in the right-hand set. The set can be a parenthesized list of scalar values or the result of a subquery. <code>IN</code> returns 1 (true) if a match is found and 0 (false) if no match is found, subject to the NULL handling rules described below.</p>
<p><code>NOT IN</code> is the logical negation of <code>IN</code>. It returns 1 (true) when the left-hand expression does not match any value in the set, and 0 (false) when a match is found.</p>
<p>When the right-hand side is a subquery, it must return a single column. Each row returned by the subquery is treated as one element in the set.</p>
<p>Turso also allows an empty parenthesized list <code>()</code>. When the right-hand side is an empty set, <code>IN</code> always returns 0 (false) and <code>NOT IN</code> always returns 1 (true), regardless of the left-hand operand – even if it is NULL.</p>
<h3 id="null-handling-3"><a class="header" href="#null-handling-3">NULL Handling</a></h3>
<p>The interaction between <code>IN</code>/<code>NOT IN</code> and NULL values follows three-valued logic. The result depends on whether a match is found, whether the set contains NULL, and whether the left operand is NULL.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Left operand</th><th>Set contains NULL</th><th>Match found</th><th>Empty set</th><th><code>IN</code> result</th><th><code>NOT IN</code> result</th></tr>
</thead>
<tbody>
<tr><td>non-NULL</td><td>no</td><td>no</td><td>no</td><td>0</td><td>1</td></tr>
<tr><td>non-NULL</td><td>no</td><td>yes</td><td>–</td><td>1</td><td>0</td></tr>
<tr><td>non-NULL</td><td>yes</td><td>no</td><td>no</td><td>NULL</td><td>NULL</td></tr>
<tr><td>non-NULL</td><td>yes</td><td>yes</td><td>–</td><td>1</td><td>0</td></tr>
<tr><td>NULL</td><td>any</td><td>any</td><td>no</td><td>NULL</td><td>NULL</td></tr>
<tr><td>any</td><td>any</td><td>–</td><td>yes</td><td>0</td><td>1</td></tr>
</tbody>
</table>
</div>
<p>Key rules to remember:</p>
<ul>
<li><strong>Match found</strong>: When the left operand is found in the set, <code>IN</code> returns 1 and <code>NOT IN</code> returns 0, regardless of any NULLs in the set.</li>
<li><strong>No match, set contains NULL</strong>: When no match is found but the set contains NULL, the result is NULL for both <code>IN</code> and <code>NOT IN</code>. The NULL represents “unknown” – the value might match the unknown element.</li>
<li><strong>Left operand is NULL</strong>: When the left operand is NULL and the set is non-empty, the result is always NULL (unknown).</li>
<li><strong>Empty set</strong>: When the right-hand set is empty, <code>IN</code> returns 0 and <code>NOT IN</code> returns 1 – even if the left operand is NULL. An empty set cannot contain any value.</li>
</ul>
<h3 id="examples-21"><a class="header" href="#examples-21">Examples</a></h3>
<pre><code class="language-sql">-- Basic IN with a value list
SELECT 1 IN (1, 2, 3);
-- 1

SELECT 4 IN (1, 2, 3);
-- 0
</code></pre>
<pre><code class="language-sql">-- IN with string values
SELECT 'apple' IN ('apple', 'banana', 'cherry');
-- 1
</code></pre>
<pre><code class="language-sql">-- NOT IN excludes matching values
SELECT 'grape' NOT IN ('apple', 'banana', 'cherry');
-- 1
</code></pre>
<pre><code class="language-sql">-- IN with an empty list always returns 0
SELECT 1 IN ();
-- 0

-- NOT IN with an empty list always returns 1
SELECT NULL NOT IN ();
-- 1
</code></pre>
<pre><code class="language-sql">-- NULL handling: left operand is NULL
SELECT NULL IN (1, 2, 3);
-- NULL

-- Match found despite NULLs in the set
SELECT 1 IN (1, 2, NULL);
-- 1

-- No match and set contains NULL: result is NULL
SELECT 4 IN (1, 2, NULL);
-- NULL
</code></pre>
<pre><code class="language-sql">-- Filter rows using IN with a value list
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  category TEXT,
  price REAL,
  stock INTEGER
);
INSERT INTO products VALUES (1, 'Widget', 'Hardware', 9.99, 100);
INSERT INTO products VALUES (2, 'Gadget', 'Electronics', 24.99, 50);
INSERT INTO products VALUES (3, 'Gizmo', 'Electronics', 49.99, 25);
INSERT INTO products VALUES (4, 'Bolt', 'Hardware', 1.99, 500);
INSERT INTO products VALUES (5, 'Sensor', 'Electronics', 14.99, 75);

SELECT name, category FROM products
WHERE category NOT IN ('Electronics');
-- Widget|Hardware
-- Bolt|Hardware
</code></pre>
<pre><code class="language-sql">-- IN with a subquery
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  category TEXT,
  price REAL,
  stock INTEGER
);
INSERT INTO products VALUES (1, 'Widget', 'Hardware', 9.99, 100);
INSERT INTO products VALUES (2, 'Gadget', 'Electronics', 24.99, 50);
INSERT INTO products VALUES (3, 'Gizmo', 'Electronics', 49.99, 25);
INSERT INTO products VALUES (4, 'Bolt', 'Hardware', 1.99, 500);
INSERT INTO products VALUES (5, 'Sensor', 'Electronics', 14.99, 75);

CREATE TABLE featured_ids (id INTEGER);
INSERT INTO featured_ids VALUES (2);
INSERT INTO featured_ids VALUES (4);

SELECT name, price FROM products
WHERE id IN (SELECT id FROM featured_ids);
-- Gadget|24.99
-- Bolt|1.99
</code></pre>
<pre><code class="language-sql">-- NOT IN with a subquery to find customers with no pending orders
CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer TEXT,
  amount REAL,
  status TEXT
);
INSERT INTO orders VALUES (1, 'Alice', 150.00, 'shipped');
INSERT INTO orders VALUES (2, 'Bob', 75.50, 'pending');
INSERT INTO orders VALUES (3, 'Alice', 200.00, 'delivered');
INSERT INTO orders VALUES (4, 'Carol', 50.00, 'shipped');
INSERT INTO orders VALUES (5, 'Bob', 300.00, 'delivered');

SELECT customer, amount FROM orders
WHERE customer NOT IN (
  SELECT customer FROM orders WHERE status = 'pending'
);
-- Alice|150.0
-- Alice|200.0
-- Carol|50.0
</code></pre>
<h2 id="between-1"><a class="header" href="#between-1">BETWEEN</a></h2>
<h3 id="syntax-1-1"><a class="header" href="#syntax-1-1">Syntax</a></h3>
<pre><code class="language-sql">expr [NOT] BETWEEN expr AND expr
</code></pre>
<h3 id="description-1-1"><a class="header" href="#description-1-1">Description</a></h3>
<p>The <code>BETWEEN</code> operator tests whether a value falls within an inclusive range. The expression:</p>
<pre><code class="language-sql">x BETWEEN y AND z
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-sql">x &gt;= y AND x &lt;= z
</code></pre>
<p>except that with <code>BETWEEN</code>, the <code>x</code> expression is evaluated only once. This makes no difference in results but can matter when <code>x</code> is a complex or expensive expression.</p>
<p><code>NOT BETWEEN</code> inverts the test. The expression <code>x NOT BETWEEN y AND z</code> is equivalent to <code>x &lt; y OR x &gt; z</code>.</p>
<p><code>BETWEEN</code> works with any data type that supports comparison: integers, reals, text (compared according to the active collation), and blobs.</p>
<h3 id="examples-1-1"><a class="header" href="#examples-1-1">Examples</a></h3>
<pre><code class="language-sql">-- Numeric range check
SELECT 5 BETWEEN 1 AND 10;
-- 1

SELECT 15 BETWEEN 1 AND 10;
-- 0
</code></pre>
<pre><code class="language-sql">-- NOT BETWEEN
SELECT 5 NOT BETWEEN 1 AND 10;
-- 0

SELECT 15 NOT BETWEEN 1 AND 10;
-- 1
</code></pre>
<pre><code class="language-sql">-- BETWEEN with text values (compared lexicographically)
SELECT 'M' BETWEEN 'A' AND 'Z';
-- 1

SELECT 'banana' BETWEEN 'apple' AND 'cherry';
-- 1
</code></pre>
<pre><code class="language-sql">-- Filter products by price range
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  category TEXT,
  price REAL,
  stock INTEGER
);
INSERT INTO products VALUES (1, 'Widget', 'Hardware', 9.99, 100);
INSERT INTO products VALUES (2, 'Gadget', 'Electronics', 24.99, 50);
INSERT INTO products VALUES (3, 'Gizmo', 'Electronics', 49.99, 25);
INSERT INTO products VALUES (4, 'Bolt', 'Hardware', 1.99, 500);
INSERT INTO products VALUES (5, 'Sensor', 'Electronics', 14.99, 75);

SELECT name, price FROM products
WHERE price BETWEEN 10.00 AND 30.00;
-- Gadget|24.99
-- Sensor|14.99
</code></pre>
<pre><code class="language-sql">-- NOT BETWEEN to find outlier prices
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  category TEXT,
  price REAL,
  stock INTEGER
);
INSERT INTO products VALUES (1, 'Widget', 'Hardware', 9.99, 100);
INSERT INTO products VALUES (2, 'Gadget', 'Electronics', 24.99, 50);
INSERT INTO products VALUES (3, 'Gizmo', 'Electronics', 49.99, 25);
INSERT INTO products VALUES (4, 'Bolt', 'Hardware', 1.99, 500);
INSERT INTO products VALUES (5, 'Sensor', 'Electronics', 14.99, 75);

SELECT name, price FROM products
WHERE price NOT BETWEEN 10.00 AND 30.00;
-- Widget|9.99
-- Gizmo|49.99
-- Bolt|1.99
</code></pre>
<pre><code class="language-sql">-- BETWEEN with date strings (ISO 8601 format sorts correctly)
CREATE TABLE events (
  id INTEGER PRIMARY KEY,
  name TEXT,
  event_date TEXT
);
INSERT INTO events VALUES (1, 'Launch', '2024-01-15');
INSERT INTO events VALUES (2, 'Review', '2024-03-20');
INSERT INTO events VALUES (3, 'Release', '2024-06-01');
INSERT INTO events VALUES (4, 'Summit', '2024-09-10');

SELECT name, event_date FROM events
WHERE event_date BETWEEN '2024-01-01' AND '2024-06-30';
-- Launch|2024-01-15
-- Review|2024-03-20
-- Release|2024-06-01
</code></pre>
<h2 id="combining-in-and-between"><a class="header" href="#combining-in-and-between">Combining IN and BETWEEN</a></h2>
<p><code>IN</code> and <code>BETWEEN</code> can be used together in the same <code>WHERE</code> clause, combined with <code>AND</code> and <code>OR</code>:</p>
<pre><code class="language-sql">CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer TEXT,
  amount REAL,
  status TEXT
);
INSERT INTO orders VALUES (1, 'Alice', 150.00, 'shipped');
INSERT INTO orders VALUES (2, 'Bob', 75.50, 'pending');
INSERT INTO orders VALUES (3, 'Alice', 200.00, 'delivered');
INSERT INTO orders VALUES (4, 'Carol', 50.00, 'shipped');
INSERT INTO orders VALUES (5, 'Bob', 300.00, 'delivered');

-- Orders that are shipped or delivered with amount in a range
SELECT customer, amount FROM orders
WHERE status IN ('shipped', 'delivered')
  AND amount BETWEEN 100.00 AND 250.00;
-- Alice|150.0
-- Alice|200.0
</code></pre>
<h2 id="operator-precedence-1"><a class="header" href="#operator-precedence-1">Operator Precedence</a></h2>
<p>Both <code>IN</code> and <code>BETWEEN</code> have defined positions in the operator precedence hierarchy. From highest to lowest among the comparison operators:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Precedence</th><th>Operators</th></tr>
</thead>
<tbody>
<tr><td>Higher</td><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td></tr>
<tr><td></td><td><code>=</code>, <code>==</code>, <code>&lt;&gt;</code>, <code>IS</code>, <code>IS NOT</code></td></tr>
<tr><td></td><td><code>BETWEEN ... AND ...</code></td></tr>
<tr><td></td><td><code>IN</code>, <code>LIKE</code>, <code>GLOB</code>, <code>MATCH</code>, <code>REGEXP</code></td></tr>
<tr><td>Lower</td><td><code>ISNULL</code>, <code>NOTNULL</code>, <code>NOT NULL</code></td></tr>
</tbody>
</table>
</div>
<p>The <code>NOT</code> keyword that precedes <code>IN</code> or <code>BETWEEN</code> is part of the operator itself (not a separate prefix operator) and does not change the precedence.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="collation"><a class="header" href="#collation">Collation</a></h1>
<h2 id="syntax-24"><a class="header" href="#syntax-24">Syntax</a></h2>
<pre><code class="language-sql">expr COLLATE {BINARY | NOCASE | RTRIM}
</code></pre>
<p>In column definitions:</p>
<pre><code class="language-sql">column-name type-name COLLATE {BINARY | NOCASE | RTRIM}
</code></pre>
<p>In <code>ORDER BY</code> clauses:</p>
<pre><code class="language-sql">ORDER BY expr COLLATE {BINARY | NOCASE | RTRIM} [{ASC | DESC}]
</code></pre>
<p>In index definitions:</p>
<pre><code class="language-sql">CREATE INDEX index-name ON table-name (column-name COLLATE {BINARY | NOCASE | RTRIM})
</code></pre>
<h2 id="description-22"><a class="header" href="#description-22">Description</a></h2>
<p>A collation sequence determines how text values are compared and sorted. The <code>COLLATE</code> operator is a unary postfix operator that assigns a collation sequence to an expression, overriding whatever collation would otherwise apply.</p>
<p>Collation sequences affect only text comparisons. Numeric values are always compared numerically, and BLOB values are always compared byte-by-byte regardless of any collation setting.</p>
<h2 id="built-in-collation-sequences"><a class="header" href="#built-in-collation-sequences">Built-in Collation Sequences</a></h2>
<p>Turso provides three built-in collation sequences:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Collation</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>BINARY</code></td><td>Compares text byte-by-byte using raw byte values. This is the default collation for all columns. Uppercase letters sort before lowercase (<code>'A'</code> &lt; <code>'a'</code>).</td></tr>
<tr><td><code>NOCASE</code></td><td>Same as <code>BINARY</code>, except the 26 uppercase ASCII letters (<code>A</code>-<code>Z</code>) are folded to their lowercase equivalents before comparison. Only ASCII characters are folded; accented or non-Latin characters are not affected.</td></tr>
<tr><td><code>RTRIM</code></td><td>Same as <code>BINARY</code>, except trailing space characters are ignored. <code>'abc'</code> and <code>'abc   '</code> are considered equal.</td></tr>
</tbody>
</table>
</div>
<p>Every column has an associated collation sequence. If no <code>COLLATE</code> clause is specified in the column definition, the default is <code>BINARY</code>.</p>
<h2 id="collate-in-column-definitions"><a class="header" href="#collate-in-column-definitions">COLLATE in Column Definitions</a></h2>
<p>A <code>COLLATE</code> clause in a column definition sets the default collation for that column. This collation is used whenever the column appears in a comparison or <code>ORDER BY</code> without an explicit <code>COLLATE</code> operator.</p>
<pre><code class="language-sql">CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  email TEXT COLLATE NOCASE,
  username TEXT
);
INSERT INTO users VALUES (1, 'Alice@Example.com', 'alice');
INSERT INTO users VALUES (2, 'bob@example.com', 'bob');
INSERT INTO users VALUES (3, 'CAROL@EXAMPLE.COM', 'carol');

-- NOCASE column: matches regardless of case
SELECT id, email FROM users WHERE email = 'alice@example.com';
-- 1|Alice@Example.com
</code></pre>
<p>Because <code>email</code> is declared with <code>COLLATE NOCASE</code>, the comparison <code>email = 'alice@example.com'</code> matches the stored value <code>'Alice@Example.com'</code>.</p>
<h2 id="collate-operator-in-expressions"><a class="header" href="#collate-operator-in-expressions">COLLATE Operator in Expressions</a></h2>
<p>The <code>COLLATE</code> operator can be applied to any expression to control how a comparison is performed. It has very high precedence – higher than any binary operator – so it binds tightly to its operand.</p>
<pre><code class="language-sql">-- Default BINARY comparison is case-sensitive
SELECT 'Hello' = 'hello';
-- 0

-- COLLATE NOCASE makes the comparison case-insensitive
SELECT 'Hello' = 'hello' COLLATE NOCASE;
-- 1

-- COLLATE RTRIM ignores trailing spaces
SELECT 'hello   ' = 'hello' COLLATE RTRIM;
-- 1
</code></pre>
<p>When used in a <code>WHERE</code> clause, the <code>COLLATE</code> operator overrides the column’s default collation:</p>
<pre><code class="language-sql">CREATE TABLE items (
  id INTEGER PRIMARY KEY,
  label TEXT
);
INSERT INTO items VALUES (1, 'abc  ');
INSERT INTO items VALUES (2, 'abc');
INSERT INTO items VALUES (3, 'ABC');
INSERT INTO items VALUES (4, 'xyz');

-- Without COLLATE, default BINARY collation is exact
SELECT id FROM items WHERE label = 'abc';
-- 2

-- With COLLATE RTRIM, trailing spaces are ignored
SELECT id FROM items WHERE label = 'abc' COLLATE RTRIM;
-- 1
-- 2
</code></pre>
<h2 id="rules-for-choosing-a-collation-in-comparisons"><a class="header" href="#rules-for-choosing-a-collation-in-comparisons">Rules for Choosing a Collation in Comparisons</a></h2>
<p>When two values are compared using a binary operator (<code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;&gt;</code>, <code>IS</code>, <code>IS NOT</code>), the collation sequence is determined by these rules, applied in order:</p>
<ol>
<li>If either operand has an explicit <code>COLLATE</code> operator, that collation is used. If both operands have explicit <code>COLLATE</code> operators, the leftmost one wins.</li>
<li>If either operand is a column with a defined collation (from <code>CREATE TABLE</code>), that column’s collation is used. If both operands are columns, the left operand’s collation takes precedence.</li>
<li>Otherwise, the <code>BINARY</code> collation is used.</li>
</ol>
<pre><code class="language-sql">CREATE TABLE contacts (
  id INTEGER PRIMARY KEY,
  name TEXT COLLATE NOCASE,
  tag TEXT
);
INSERT INTO contacts VALUES (1, 'alice', 'alpha');
INSERT INTO contacts VALUES (2, 'Alice', 'Alpha');
INSERT INTO contacts VALUES (3, 'BOB', 'beta');

-- Column collation applies: name is NOCASE, so 'alice' matches 'Alice'
SELECT id FROM contacts WHERE name = 'alice';
-- 1
-- 2

-- Default BINARY: tag has no COLLATE, so comparison is case-sensitive
SELECT id FROM contacts WHERE tag = 'alpha';
-- 1

-- Explicit COLLATE overrides defaults
SELECT id FROM contacts WHERE tag = 'alpha' COLLATE NOCASE;
-- 1
-- 2
</code></pre>
<h2 id="collate-in-order-by"><a class="header" href="#collate-in-order-by">COLLATE in ORDER BY</a></h2>
<p>The <code>ORDER BY</code> clause uses collation to determine sort order for text values. The collation is chosen as follows:</p>
<ul>
<li>If the <code>ORDER BY</code> expression has an explicit <code>COLLATE</code> clause, that collation is used.</li>
<li>If the <code>ORDER BY</code> expression is a column, the column’s defined collation is used.</li>
<li>Otherwise, <code>BINARY</code> is used.</li>
</ul>
<pre><code class="language-sql">CREATE TABLE contacts (
  id INTEGER PRIMARY KEY,
  name TEXT COLLATE NOCASE,
  tag TEXT
);
INSERT INTO contacts VALUES (1, 'alice', 'alpha');
INSERT INTO contacts VALUES (2, 'Alice', 'Alpha');
INSERT INTO contacts VALUES (3, 'BOB', 'beta');
INSERT INTO contacts VALUES (4, 'bob', 'Beta');
INSERT INTO contacts VALUES (5, 'Carol', 'gamma');

-- ORDER BY tag with default BINARY: uppercase sorts before lowercase
SELECT id, tag FROM contacts ORDER BY tag COLLATE BINARY;
-- 2|Alpha
-- 4|Beta
-- 1|alpha
-- 3|beta
-- 5|gamma

-- ORDER BY tag with NOCASE: case-insensitive sort
SELECT id, tag FROM contacts ORDER BY tag COLLATE NOCASE;
-- 1|alpha
-- 2|Alpha
-- 3|beta
-- 4|Beta
-- 5|gamma
</code></pre>
<h2 id="collate-in-create-index"><a class="header" href="#collate-in-create-index">COLLATE in CREATE INDEX</a></h2>
<p>A <code>COLLATE</code> clause can be specified on indexed columns. This is useful when you want an index to support case-insensitive lookups on a column that does not itself have a <code>NOCASE</code> collation.</p>
<pre><code class="language-sql">CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  email TEXT,
  username TEXT
);
INSERT INTO users VALUES (1, 'Alice@Example.com', 'alice');
INSERT INTO users VALUES (2, 'bob@example.com', 'bob');
INSERT INTO users VALUES (3, 'CAROL@EXAMPLE.COM', 'carol');
CREATE INDEX idx_email ON users(email COLLATE NOCASE);

SELECT id, email FROM users WHERE email = 'alice@example.com' COLLATE NOCASE;
-- 1|Alice@Example.com
</code></pre>
<h2 id="collate-with-group-by-and-distinct"><a class="header" href="#collate-with-group-by-and-distinct">COLLATE with GROUP BY and DISTINCT</a></h2>
<p>Collation sequences also affect grouping. When <code>COLLATE NOCASE</code> is applied to a grouping expression, values that differ only in case are placed in the same group.</p>
<pre><code class="language-sql">CREATE TABLE words (id INTEGER PRIMARY KEY, word TEXT);
INSERT INTO words VALUES (1, 'apple');
INSERT INTO words VALUES (2, 'Apple');
INSERT INTO words VALUES (3, 'APPLE');
INSERT INTO words VALUES (4, 'banana');

-- GROUP BY with NOCASE: all case variants of 'apple' form one group
SELECT word COLLATE NOCASE, COUNT(*) AS cnt
FROM words
GROUP BY word COLLATE NOCASE;
-- apple|3
-- banana|1

-- DISTINCT with NOCASE: collapses case variants
SELECT DISTINCT word COLLATE NOCASE FROM words;
-- apple
-- banana
</code></pre>
<h2 id="collate-with-in"><a class="header" href="#collate-with-in">COLLATE with IN</a></h2>
<p>The <code>COLLATE</code> operator can be combined with the <code>IN</code> operator. Attach <code>COLLATE</code> to the left-hand expression to control how membership is tested.</p>
<pre><code class="language-sql">SELECT 'hello' COLLATE NOCASE IN ('Hello', 'World');
-- 1
</code></pre>
<h2 id="compatibility-16"><a class="header" href="#compatibility-16">Compatibility</a></h2>
<p>Turso supports the three built-in collation sequences (<code>BINARY</code>, <code>NOCASE</code>, <code>RTRIM</code>) and the <code>COLLATE</code> operator in expressions, column definitions, <code>ORDER BY</code>, and <code>CREATE INDEX</code>. Custom collation sequences registered via the C API (<code>sqlite3_create_collation</code>) are not supported. The <code>PRAGMA collation_list</code> command is not available.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="scalar-functions"><a class="header" href="#scalar-functions">Scalar Functions</a></h1>
<p>Scalar functions accept zero or more arguments and return a single value. They can be used anywhere an expression is allowed: in SELECT lists, WHERE clauses, ORDER BY, and so on.</p>
<hr>
<h2 id="abs"><a class="header" href="#abs">abs</a></h2>
<p><strong>abs(X) -&gt; numeric</strong></p>
<p>Returns the absolute value of X. Returns NULL if X is NULL. Returns 0.0 if X is a string that cannot be converted to a number.</p>
<pre><code class="language-sql">SELECT abs(-42);    -- 42
SELECT abs(3.14);   -- 3.14
SELECT abs(NULL);   -- NULL
</code></pre>
<h2 id="char"><a class="header" href="#char">char</a></h2>
<p><strong>char(X1, X2, …, XN) -&gt; text</strong></p>
<p>Returns a string composed of characters having the Unicode code points given by the integer arguments.</p>
<pre><code class="language-sql">SELECT char(72, 101, 108, 108, 111);  -- 'Hello'
SELECT char(9731);                     -- snowman character
</code></pre>
<h2 id="coalesce-1"><a class="header" href="#coalesce-1">coalesce</a></h2>
<p><strong>coalesce(X, Y, …) -&gt; value</strong></p>
<p>Returns the first non-NULL argument. Requires at least two arguments. Returns NULL only if every argument is NULL.</p>
<pre><code class="language-sql">SELECT coalesce(NULL, NULL, 'hello');  -- 'hello'
SELECT coalesce(1, 2, 3);             -- 1
</code></pre>
<h2 id="concat"><a class="header" href="#concat">concat</a></h2>
<p><strong>concat(X, …) -&gt; text</strong></p>
<p>Returns a string formed by concatenating the text representations of all non-NULL arguments. NULL arguments are silently skipped. Returns an empty string if all arguments are NULL.</p>
<pre><code class="language-sql">SELECT concat('Hello', ' ', 'World');  -- 'Hello World'
SELECT concat(NULL, 'hello');          -- 'hello'
</code></pre>
<h2 id="concat_ws"><a class="header" href="#concat_ws">concat_ws</a></h2>
<p><strong>concat_ws(separator, X, …) -&gt; text</strong></p>
<p>Returns a string formed by concatenating the non-NULL arguments after the first, using the first argument as a separator. Returns NULL if the separator is NULL.</p>
<pre><code class="language-sql">SELECT concat_ws('-', '2024', '01', '15');  -- '2024-01-15'
SELECT concat_ws(', ', 'Alice', 'Bob');     -- 'Alice, Bob'
SELECT concat_ws(NULL, 'a', 'b');           -- NULL
</code></pre>
<h2 id="format"><a class="header" href="#format">format</a></h2>
<p><strong>format(FORMAT, …) -&gt; text</strong></p>
<p>Returns a string formed by substituting arguments into the format string, following <code>printf</code> conventions. Supports <code>%s</code> (string), <code>%d</code> (integer), <code>%f</code> (floating-point), and other standard format specifiers. Returns NULL if FORMAT is NULL.</p>
<pre><code class="language-sql">SELECT format('%s has %d items', 'cart', 5);  -- 'cart has 5 items'
SELECT format('%.2f', 3.14159);               -- '3.14'
</code></pre>
<h2 id="glob-1"><a class="header" href="#glob-1">glob</a></h2>
<p><strong>glob(pattern, string) -&gt; integer</strong></p>
<p>Tests whether the string matches the glob pattern. Equivalent to the expression <code>string GLOB pattern</code>. Returns 1 for a match, 0 otherwise. Glob patterns use <code>*</code> to match any sequence of characters and <code>?</code> to match any single character. Matching is case-sensitive.</p>
<pre><code class="language-sql">SELECT glob('*ello', 'Hello');  -- 1
SELECT glob('H?llo', 'Hello');  -- 1
</code></pre>
<h2 id="hex"><a class="header" href="#hex">hex</a></h2>
<p><strong>hex(X) -&gt; text</strong></p>
<p>Returns an uppercase hexadecimal string rendering of the content of X. If X is a text string, each character is converted to its UTF-8 byte representation. If X is a blob, the raw bytes are converted.</p>
<pre><code class="language-sql">SELECT hex('Hello');       -- '48656C6C6F'
SELECT hex(X'CAFE');       -- 'CAFE'
SELECT hex(zeroblob(4));   -- '00000000'
</code></pre>
<h2 id="ifnull-1"><a class="header" href="#ifnull-1">ifnull</a></h2>
<p><strong>ifnull(X, Y) -&gt; value</strong></p>
<p>Returns X if X is not NULL, otherwise returns Y. Equivalent to <code>coalesce(X, Y)</code> but restricted to exactly two arguments.</p>
<pre><code class="language-sql">SELECT ifnull(NULL, 'backup');  -- 'backup'
SELECT ifnull('value', 42);    -- 'value'
</code></pre>
<h2 id="iif-1"><a class="header" href="#iif-1">iif</a></h2>
<p><strong>iif(condition, true_value, false_value) -&gt; value</strong></p>
<p>Returns true_value if condition is true, or false_value if condition is false or NULL. The <code>if</code> keyword is an alias for <code>iif</code>.</p>
<pre><code class="language-sql">SELECT iif(1, 'yes', 'no');   -- 'yes'
SELECT iif(0, 'yes', 'no');   -- 'no'
SELECT if(1 &gt; 0, 'positive', 'non-positive');  -- 'positive'
</code></pre>
<h2 id="instr"><a class="header" href="#instr">instr</a></h2>
<p><strong>instr(X, Y) -&gt; integer</strong></p>
<p>Returns the 1-based position of the first occurrence of Y within X, or 0 if Y is not found. Returns NULL if either argument is NULL. Both arguments must be the same type (both text or both blob).</p>
<pre><code class="language-sql">SELECT instr('Hello World', 'World');  -- 7
SELECT instr('Hello World', 'xyz');    -- 0
SELECT instr('hello', NULL);           -- NULL
</code></pre>
<h2 id="last_insert_rowid"><a class="header" href="#last_insert_rowid">last_insert_rowid</a></h2>
<p><strong>last_insert_rowid() -&gt; integer</strong></p>
<p>Returns the ROWID of the most recent successful INSERT into a rowid table from the same database connection. Returns 0 if no INSERT has occurred.</p>
<pre><code class="language-sql">SELECT last_insert_rowid();  -- 0 (before any inserts)
</code></pre>
<h2 id="length"><a class="header" href="#length">length</a></h2>
<p><strong>length(X) -&gt; integer</strong></p>
<p>Returns the number of characters in X if X is a text string, or the number of bytes if X is a blob. Returns NULL if X is NULL.</p>
<pre><code class="language-sql">SELECT length('Hello');           -- 5
SELECT length(X'0102030405');     -- 5
SELECT length(NULL);              -- NULL
</code></pre>
<h2 id="like-1"><a class="header" href="#like-1">like</a></h2>
<p><strong>like(pattern, string) -&gt; integer</strong></p>
<p>Tests whether the string matches the LIKE pattern. Equivalent to <code>string LIKE pattern</code>. The <code>%</code> wildcard matches any sequence of characters and <code>_</code> matches any single character. Matching is case-insensitive for ASCII characters.</p>
<pre><code class="language-sql">SELECT like('H%', 'Hello');     -- 1
SELECT like('H_llo', 'Hello');  -- 1
SELECT like('%world%', 'Hello World');  -- 1
</code></pre>
<h2 id="likelihood"><a class="header" href="#likelihood">likelihood</a></h2>
<p><strong>likelihood(X, P) -&gt; value</strong></p>
<p>Returns X unchanged. The second argument P is a probability hint (a floating-point number between 0.0 and 1.0) for the query planner, indicating the likelihood that X is true. This function has no effect on the result, only on query optimization.</p>
<pre><code class="language-sql">SELECT likelihood(1, 0.5);  -- 1
</code></pre>
<h2 id="likely"><a class="header" href="#likely">likely</a></h2>
<p><strong>likely(X) -&gt; value</strong></p>
<p>Returns X unchanged. Provides a hint to the query planner that X is usually true (equivalent to <code>likelihood(X, 0.9375)</code>). This function has no effect on the result, only on query optimization.</p>
<pre><code class="language-sql">SELECT likely(1);  -- 1
</code></pre>
<h2 id="lower"><a class="header" href="#lower">lower</a></h2>
<p><strong>lower(X) -&gt; text</strong></p>
<p>Returns a copy of X with all ASCII uppercase characters converted to lowercase. Non-ASCII characters are unchanged.</p>
<pre><code class="language-sql">SELECT lower('HELLO');       -- 'hello'
SELECT lower('Hello World'); -- 'hello world'
</code></pre>
<h2 id="ltrim-rtrim-trim"><a class="header" href="#ltrim-rtrim-trim">ltrim, rtrim, trim</a></h2>
<p><strong>ltrim(X) -&gt; text</strong>
<strong>ltrim(X, Y) -&gt; text</strong>
<strong>rtrim(X) -&gt; text</strong>
<strong>rtrim(X, Y) -&gt; text</strong>
<strong>trim(X) -&gt; text</strong>
<strong>trim(X, Y) -&gt; text</strong></p>
<p><code>ltrim</code> removes characters from the left side of X. <code>rtrim</code> removes from the right side. <code>trim</code> removes from both sides. With one argument, spaces are removed. With two arguments, all characters found in Y are removed from the respective side(s).</p>
<pre><code class="language-sql">SELECT ltrim('   Hello');          -- 'Hello'
SELECT ltrim('xxxHello', 'x');     -- 'Hello'
SELECT rtrim('Hello   ');          -- 'Hello'
SELECT rtrim('Helloxxxx', 'x');    -- 'Hello'
SELECT trim('  Hello  ');          -- 'Hello'
SELECT trim('xxHelloxx', 'x');     -- 'Hello'
</code></pre>
<h2 id="max-scalar"><a class="header" href="#max-scalar">max (scalar)</a></h2>
<p><strong>max(X, Y, …) -&gt; value</strong></p>
<p>Returns the argument with the maximum value when given two or more arguments. Uses the standard comparison rules to determine ordering. Returns NULL if any argument is NULL. (With a single argument, <code>max</code> acts as an aggregate function instead.)</p>
<pre><code class="language-sql">SELECT max(1, 5, 3);           -- 5
SELECT max('alpha', 'beta');   -- 'beta'
</code></pre>
<h2 id="min-scalar"><a class="header" href="#min-scalar">min (scalar)</a></h2>
<p><strong>min(X, Y, …) -&gt; value</strong></p>
<p>Returns the argument with the minimum value when given two or more arguments. Uses the standard comparison rules to determine ordering. Returns NULL if any argument is NULL. (With a single argument, <code>min</code> acts as an aggregate function instead.)</p>
<pre><code class="language-sql">SELECT min(1, 5, 3);           -- 1
SELECT min('alpha', 'beta');   -- 'alpha'
</code></pre>
<h2 id="nullif-1"><a class="header" href="#nullif-1">nullif</a></h2>
<p><strong>nullif(X, Y) -&gt; value</strong></p>
<p>Returns X if X and Y are different, or NULL if they are equal. Useful for converting sentinel values into NULLs.</p>
<pre><code class="language-sql">SELECT nullif(5, 5);    -- NULL
SELECT nullif(5, 3);    -- 5
SELECT nullif('', '');   -- NULL
</code></pre>
<h2 id="octet_length"><a class="header" href="#octet_length">octet_length</a></h2>
<p><strong>octet_length(X) -&gt; integer</strong></p>
<p>Returns the number of bytes in X. Unlike <code>length</code>, which counts characters for text values, <code>octet_length</code> always counts bytes. Returns NULL if X is NULL.</p>
<pre><code class="language-sql">SELECT octet_length('Hello');           -- 5
SELECT octet_length(X'0102030405');     -- 5
</code></pre>
<h2 id="printf"><a class="header" href="#printf">printf</a></h2>
<p><strong>printf(FORMAT, …) -&gt; text</strong></p>
<p>Alias for <code>format</code>. Returns a string formed by substituting arguments into the format string using <code>printf</code> conventions. Returns NULL if FORMAT is NULL.</p>
<pre><code class="language-sql">SELECT printf('%d items', 5);    -- '5 items'
SELECT printf('%.2f', 3.14159);  -- '3.14'
</code></pre>
<h2 id="quote"><a class="header" href="#quote">quote</a></h2>
<p><strong>quote(X) -&gt; text</strong></p>
<p>Returns a string that is the SQL literal representation of X. Text strings are surrounded by single quotes with internal quotes doubled. Blobs are returned as hex literals. NULL returns the string <code>NULL</code>. Integers and reals are returned as-is.</p>
<pre><code class="language-sql">SELECT quote('Hello');          -- 'Hello'  (with enclosing quotes)
SELECT quote(3.14);             -- 3.14
SELECT quote(NULL);             -- NULL
SELECT quote(X'48656C6C6F');    -- X'48656C6C6F'
</code></pre>
<h2 id="random"><a class="header" href="#random">random</a></h2>
<p><strong>random() -&gt; integer</strong></p>
<p>Returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807. A different value is returned each time the function is called.</p>
<pre><code class="language-sql">SELECT typeof(random());  -- 'integer'
</code></pre>
<h2 id="randomblob"><a class="header" href="#randomblob">randomblob</a></h2>
<p><strong>randomblob(N) -&gt; blob</strong></p>
<p>Returns an N-byte blob containing pseudo-random bytes. Useful for generating unique identifiers or random data.</p>
<pre><code class="language-sql">SELECT length(randomblob(16));  -- 16
SELECT hex(randomblob(4));      -- (random 8-character hex string)
</code></pre>
<h2 id="replace"><a class="header" href="#replace">replace</a></h2>
<p><strong>replace(X, Y, Z) -&gt; text</strong></p>
<p>Returns a copy of X with every occurrence of Y replaced by Z. If Y is an empty string, X is returned unchanged.</p>
<pre><code class="language-sql">SELECT replace('Hello World', 'World', 'Turso');  -- 'Hello Turso'
SELECT replace('aabbcc', 'bb', 'XX');              -- 'aaXXcc'
</code></pre>
<h2 id="round"><a class="header" href="#round">round</a></h2>
<p><strong>round(X) -&gt; real</strong>
<strong>round(X, Y) -&gt; real</strong></p>
<p>Rounds X to Y decimal places. If Y is omitted, it defaults to 0. The result is always a floating-point value.</p>
<pre><code class="language-sql">SELECT round(3.14159);     -- 3.0
SELECT round(3.14159, 2);  -- 3.14
SELECT round(123.5);       -- 124.0
</code></pre>
<h2 id="sign"><a class="header" href="#sign">sign</a></h2>
<p><strong>sign(X) -&gt; integer</strong></p>
<p>Returns -1 for negative values, 0 for zero, or +1 for positive values. Returns NULL if X is NULL or is a string or blob that cannot be converted to a number.</p>
<pre><code class="language-sql">SELECT sign(-42);   -- -1
SELECT sign(0);     -- 0
SELECT sign(42);    -- 1
SELECT sign(NULL);  -- NULL
</code></pre>
<h2 id="soundex"><a class="header" href="#soundex">soundex</a></h2>
<p><strong>soundex(X) -&gt; text</strong></p>
<p>Returns the Soundex encoding of X. The Soundex encoding is a four-character string that represents the phonetic sound of the input. Returns <code>?000</code> if X is NULL or contains no ASCII letters.</p>
<pre><code class="language-sql">SELECT soundex('Robert');   -- 'R163'
SELECT soundex('Rupert');   -- 'R163'
</code></pre>
<h2 id="sqlite_source_id"><a class="header" href="#sqlite_source_id">sqlite_source_id</a></h2>
<p><strong>sqlite_source_id() -&gt; text</strong></p>
<p>Returns a string that identifies the specific version and build of the library. The format includes a date, time, and a SHA hash.</p>
<pre><code class="language-sql">SELECT sqlite_source_id();
-- e.g. '2026-02-11 18:26:30 fd3ab2fd48b711aa9bec80562dd1175ce10f4d9a'
</code></pre>
<h2 id="sqlite_version"><a class="header" href="#sqlite_version">sqlite_version</a></h2>
<p><strong>sqlite_version() -&gt; text</strong></p>
<p>Returns the version string for the SQLite-compatible library.</p>
<pre><code class="language-sql">SELECT sqlite_version();  -- e.g. '3.50.4'
</code></pre>
<h2 id="substr--substring"><a class="header" href="#substr--substring">substr / substring</a></h2>
<p><strong>substr(X, Y) -&gt; text</strong>
<strong>substr(X, Y, Z) -&gt; text</strong>
<strong>substring(X, Y) -&gt; text</strong>
<strong>substring(X, Y, Z) -&gt; text</strong></p>
<p>Returns a substring of X starting at position Y (1-based). If Z is given, it specifies the length of the substring; otherwise the substring extends to the end of the string. <code>substring</code> is an alias for <code>substr</code>.</p>
<p>If Y is negative, the substring starts that many characters from the end. If Z is negative, the substring consists of the Z characters preceding (and including) position Y.</p>
<pre><code class="language-sql">SELECT substr('Hello World', 7);      -- 'World'
SELECT substr('Hello World', 1, 5);   -- 'Hello'
SELECT substring('Hello World', 7);   -- 'World'
</code></pre>
<h2 id="typeof"><a class="header" href="#typeof">typeof</a></h2>
<p><strong>typeof(X) -&gt; text</strong></p>
<p>Returns the type of X as a string. The possible return values are <code>'null'</code>, <code>'integer'</code>, <code>'real'</code>, <code>'text'</code>, and <code>'blob'</code>.</p>
<pre><code class="language-sql">SELECT typeof(42);        -- 'integer'
SELECT typeof(3.14);      -- 'real'
SELECT typeof('Hello');   -- 'text'
SELECT typeof(NULL);      -- 'null'
SELECT typeof(X'CAFE');   -- 'blob'
</code></pre>
<h2 id="unhex"><a class="header" href="#unhex">unhex</a></h2>
<p><strong>unhex(X) -&gt; blob</strong>
<strong>unhex(X, Y) -&gt; blob</strong></p>
<p>Converts the hexadecimal string X into a blob. Returns NULL if X contains characters that are not hexadecimal digits, unless those characters appear in Y (the set of characters to ignore). Returns NULL if X or Y is NULL.</p>
<pre><code class="language-sql">SELECT unhex('48656C6C6F');      -- Hello (as blob)
SELECT hex(unhex('48656C6C6F')); -- '48656C6C6F'
SELECT unhex('48GG', 'G');       -- H (as blob, 'G' chars are ignored)
</code></pre>
<h2 id="unicode"><a class="header" href="#unicode">unicode</a></h2>
<p><strong>unicode(X) -&gt; integer</strong></p>
<p>Returns the numeric Unicode code point of the first character of X. Returns NULL if X is an empty string.</p>
<pre><code class="language-sql">SELECT unicode('A');     -- 65
SELECT unicode('Hello'); -- 72
</code></pre>
<h2 id="unlikely"><a class="header" href="#unlikely">unlikely</a></h2>
<p><strong>unlikely(X) -&gt; value</strong></p>
<p>Returns X unchanged. Provides a hint to the query planner that X is usually false (equivalent to <code>likelihood(X, 0.0625)</code>). This function has no effect on the result, only on query optimization.</p>
<pre><code class="language-sql">SELECT unlikely(1);  -- 1
</code></pre>
<h2 id="upper"><a class="header" href="#upper">upper</a></h2>
<p><strong>upper(X) -&gt; text</strong></p>
<p>Returns a copy of X with all ASCII lowercase characters converted to uppercase. Non-ASCII characters are unchanged.</p>
<pre><code class="language-sql">SELECT upper('hello');        -- 'HELLO'
SELECT upper('Hello World');  -- 'HELLO WORLD'
</code></pre>
<h2 id="zeroblob"><a class="header" href="#zeroblob">zeroblob</a></h2>
<p><strong>zeroblob(N) -&gt; blob</strong></p>
<p>Returns a blob consisting of N zero-valued bytes (0x00). Useful as a placeholder for blob values to be filled in later with incremental I/O.</p>
<pre><code class="language-sql">SELECT length(zeroblob(10));  -- 10
SELECT hex(zeroblob(4));      -- '00000000'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="aggregate-functions"><a class="header" href="#aggregate-functions">Aggregate Functions</a></h1>
<p>Aggregate functions compute a single result from a set of input values. They are most commonly used with a <code>GROUP BY</code> clause to produce one result per group of rows, but when used without <code>GROUP BY</code>, they treat the entire result set as a single group and return one row.</p>
<p>All built-in aggregate functions ignore NULL inputs (except <code>count(*)</code>). If every input to an aggregate function is NULL, the result is NULL – with the exceptions of <code>count()</code> (which returns 0) and <code>total()</code> (which returns 0.0). This NULL-skipping behavior is consistent with the SQL standard.</p>
<p>Aggregate functions can be combined with <code>GROUP BY</code> and <code>HAVING</code> to filter groups after aggregation. See <a href="#group-by-and-having">GROUP BY and HAVING</a> for details on grouping.</p>
<p>The <code>DISTINCT</code> keyword can precede the argument of any single-argument aggregate to eliminate duplicate values before processing:</p>
<pre><code class="language-sql">SELECT count(DISTINCT category) FROM products;
</code></pre>
<p>The examples below use the following tables:</p>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  category TEXT,
  price REAL
);
INSERT INTO products VALUES
  (1, 'Laptop', 'Electronics', 999.99),
  (2, 'Phone', 'Electronics', 699.99),
  (3, 'Desk', 'Furniture', 299.99),
  (4, 'Chair', 'Furniture', 199.99),
  (5, 'Tablet', 'Electronics', 499.99);

CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  user_id INTEGER,
  product TEXT,
  amount REAL
);
INSERT INTO orders VALUES
  (1, 1, 'Laptop', 999.99),
  (2, 1, 'Phone', 699.99),
  (3, 2, 'Desk', 299.99),
  (4, 3, 'Chair', 199.99),
  (5, 1, 'Tablet', 499.99);
</code></pre>
<hr>
<h2 id="avg"><a class="header" href="#avg">avg</a></h2>
<p><strong>avg(X) -&gt; real</strong></p>
<p>Returns the average of all non-NULL values of X. The result is always a floating-point value when there is at least one non-NULL input. String and BLOB values that do not look like numbers are treated as 0. Returns NULL if all inputs are NULL or if the input set is empty. Internally, <code>avg(X)</code> is equivalent to <code>total(X) / count(X)</code>.</p>
<pre><code class="language-sql">SELECT avg(amount) FROM orders;
-- 539.99
</code></pre>
<pre><code class="language-sql">SELECT user_id, avg(amount) AS avg_order
  FROM orders
  GROUP BY user_id;
-- 1 | 733.323333333333
-- 2 | 299.99
-- 3 | 199.99
</code></pre>
<p>The <code>DISTINCT</code> keyword causes duplicate values to be removed before computing the average:</p>
<pre><code class="language-sql">SELECT avg(DISTINCT x) FROM (SELECT 1 AS x UNION ALL SELECT 2 UNION ALL SELECT 2 UNION ALL SELECT 3);
-- 2.0
</code></pre>
<hr>
<h2 id="count"><a class="header" href="#count">count</a></h2>
<p><strong>count(X) -&gt; integer</strong>
<strong>count(*) -&gt; integer</strong></p>
<p>The <code>count(X)</code> form returns the number of times X is not NULL. The <code>count(*)</code> form returns the total number of rows in the group, regardless of NULL values.</p>
<p><code>count()</code> always returns an integer and never returns NULL. For an empty input set, both forms return 0.</p>
<pre><code class="language-sql">SELECT count(*) FROM orders;
-- 5
</code></pre>
<pre><code class="language-sql">SELECT count(amount) FROM orders;
-- 5
</code></pre>
<pre><code class="language-sql">SELECT count(DISTINCT user_id) FROM orders;
-- 3
</code></pre>
<pre><code class="language-sql">SELECT user_id, count(*) AS order_count
  FROM orders
  GROUP BY user_id;
-- 1 | 3
-- 2 | 1
-- 3 | 1
</code></pre>
<hr>
<h2 id="group_concat"><a class="header" href="#group_concat">group_concat</a></h2>
<p><strong>group_concat(X) -&gt; text</strong>
<strong>group_concat(X, Y) -&gt; text</strong></p>
<p>Returns a string formed by concatenating all non-NULL values of X, separated by Y. If Y is omitted, a comma (<code>","</code>) is used as the default separator. Returns NULL if all inputs are NULL.</p>
<p>The order of concatenated elements is determined by the order in which rows are processed. When used with <code>GROUP BY</code>, the order within each group is not guaranteed unless the query uses a subquery or other mechanism to control row ordering.</p>
<pre><code class="language-sql">SELECT group_concat(product) FROM orders;
-- Laptop,Phone,Desk,Chair,Tablet
</code></pre>
<pre><code class="language-sql">SELECT group_concat(product, ' | ') FROM orders;
-- Laptop | Phone | Desk | Chair | Tablet
</code></pre>
<pre><code class="language-sql">SELECT user_id, group_concat(product, ', ') AS products
  FROM orders
  GROUP BY user_id;
-- 1 | Laptop, Phone, Tablet
-- 2 | Desk
-- 3 | Chair
</code></pre>
<hr>
<h2 id="string_agg"><a class="header" href="#string_agg">string_agg</a></h2>
<p><strong>string_agg(X, Y) -&gt; text</strong></p>
<p>An alias for <code>group_concat(X, Y)</code>. Returns a string formed by concatenating all non-NULL values of X, separated by Y. Unlike <code>group_concat</code>, the separator argument Y is required. This form provides compatibility with PostgreSQL and SQL Server, which use <code>string_agg</code> rather than <code>group_concat</code>.</p>
<pre><code class="language-sql">SELECT string_agg(product, ', ') FROM orders;
-- Laptop, Phone, Desk, Chair, Tablet
</code></pre>
<hr>
<h2 id="max"><a class="header" href="#max">max</a></h2>
<p><strong>max(X) -&gt; value</strong></p>
<p>Returns the maximum value of all non-NULL values of X. The maximum is determined by the sort order that would be used by <code>ORDER BY</code> on the same column. Returns NULL if all inputs are NULL or if the input set is empty.</p>
<p><code>max()</code> works on any type: integers, reals, text, and BLOBs are compared using the normal comparison rules.</p>
<pre><code class="language-sql">SELECT max(amount) FROM orders;
-- 999.99
</code></pre>
<pre><code class="language-sql">SELECT max(name) FROM products;
-- Tablet
</code></pre>
<pre><code class="language-sql">SELECT category, max(price) AS most_expensive
  FROM products
  GROUP BY category;
-- Electronics | 999.99
-- Furniture   | 299.99
</code></pre>
<hr>
<h2 id="min"><a class="header" href="#min">min</a></h2>
<p><strong>min(X) -&gt; value</strong></p>
<p>Returns the minimum non-NULL value of X. The minimum is the value that would appear first in an <code>ORDER BY</code> on the same column. Returns NULL if all inputs are NULL or if the input set is empty.</p>
<p><code>min()</code> works on any type: integers, reals, text, and BLOBs are compared using the normal comparison rules.</p>
<pre><code class="language-sql">SELECT min(amount) FROM orders;
-- 199.99
</code></pre>
<pre><code class="language-sql">SELECT min(name) FROM products;
-- Chair
</code></pre>
<pre><code class="language-sql">SELECT category, min(price) AS cheapest
  FROM products
  GROUP BY category;
-- Electronics | 499.99
-- Furniture   | 199.99
</code></pre>
<hr>
<h2 id="sum"><a class="header" href="#sum">sum</a></h2>
<p><strong>sum(X) -&gt; integer or real</strong></p>
<p>Returns the sum of all non-NULL values of X. If all inputs are integers, the result is an integer. If any input is a real number, the result is a real. Returns NULL if all inputs are NULL or if the input set is empty.</p>
<p>An integer overflow error is raised if all inputs are integers and the sum exceeds the integer range.</p>
<pre><code class="language-sql">SELECT sum(amount) FROM orders;
-- 2699.95
</code></pre>
<pre><code class="language-sql">-- sum returns integer type when all inputs are integers
SELECT typeof(sum(x)) FROM (SELECT 1 AS x UNION ALL SELECT 2 UNION ALL SELECT 3);
-- integer

-- sum returns real type when any input is real
SELECT typeof(sum(x)) FROM (SELECT 1.0 AS x UNION ALL SELECT 2.0 UNION ALL SELECT 3.0);
-- real
</code></pre>
<pre><code class="language-sql">SELECT user_id, sum(amount) AS total_spent
  FROM orders
  GROUP BY user_id
  HAVING total_spent &gt; 500;
-- 1 | 2199.97
</code></pre>
<p>The <code>DISTINCT</code> keyword causes duplicate values to be removed before summing:</p>
<pre><code class="language-sql">SELECT sum(DISTINCT x) FROM (SELECT 1 AS x UNION ALL SELECT 2 UNION ALL SELECT 2 UNION ALL SELECT 3);
-- 6
</code></pre>
<hr>
<h2 id="total"><a class="header" href="#total">total</a></h2>
<p><strong>total(X) -&gt; real</strong></p>
<p>Returns the sum of all non-NULL values of X, similar to <code>sum()</code>, but with two key differences:</p>
<ol>
<li><code>total()</code> always returns a floating-point value (0.0 for an empty set), whereas <code>sum()</code> returns NULL for an empty set.</li>
<li><code>total()</code> never raises an integer overflow error.</li>
</ol>
<p>Use <code>total()</code> when you need a guaranteed numeric result and want to avoid NULL checks.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Behavior</th><th>sum(X)</th><th>total(X)</th></tr>
</thead>
<tbody>
<tr><td>Empty set result</td><td>NULL</td><td>0.0</td></tr>
<tr><td>Return type (integer inputs)</td><td>integer</td><td>real</td></tr>
<tr><td>Return type (real inputs)</td><td>real</td><td>real</td></tr>
<tr><td>Integer overflow</td><td>raises error</td><td>no error</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT total(amount) FROM orders;
-- 2699.95
</code></pre>
<pre><code class="language-sql">-- total returns 0.0 on an empty table; sum returns NULL
CREATE TABLE empty (x INTEGER);
SELECT sum(x), total(x) FROM empty;
-- (NULL) | 0.0
</code></pre>
<pre><code class="language-sql">-- total always returns real type, even with integer inputs
SELECT typeof(total(x)) FROM (SELECT 1 AS x UNION ALL SELECT 2 UNION ALL SELECT 3);
-- real
</code></pre>
<hr>
<h1 id="turso-extension-aggregates"><a class="header" href="#turso-extension-aggregates">Turso Extension Aggregates</a></h1>
<p>The following aggregate functions are provided by the <code>percentile</code> extension. They are not built-in and must be loaded explicitly before use. Once loaded, they behave like any other aggregate function and can be used with <code>GROUP BY</code>, <code>HAVING</code>, and <code>DISTINCT</code>.</p>
<pre><code class="language-sql">.load liblimbo_percentile
</code></pre>
<h2 id="median"><a class="header" href="#median">median</a></h2>
<p><strong>median(X) -&gt; real</strong></p>
<p>Returns the median value of all non-NULL values of X. For an odd number of values, this is the middle value. For an even number of values, this is the average of the two middle values. Returns NULL if all inputs are NULL.</p>
<pre><code class="language-sql">.load liblimbo_percentile

CREATE TABLE scores (value REAL);
INSERT INTO scores VALUES (1.0), (2.0), (3.0), (4.0), (5.0);

SELECT median(value) FROM scores;
-- 3.0
</code></pre>
<h2 id="percentile"><a class="header" href="#percentile">percentile</a></h2>
<p><strong>percentile(Y, P) -&gt; real</strong></p>
<p>Returns the value at the P-th percentile among all non-NULL values of Y, using linear interpolation. P is expressed on a 0-to-100 scale (e.g., 50 for the median) and must be the same value for every row in the group. An error is raised if P is outside the range 0 to 100 or if different rows supply different values of P. Returns NULL if all inputs are NULL.</p>
<pre><code class="language-sql">SELECT percentile(value, 50) FROM scores;
-- 3.0
</code></pre>
<h2 id="percentile_cont"><a class="header" href="#percentile_cont">percentile_cont</a></h2>
<p><strong>percentile_cont(Y, P) -&gt; real</strong></p>
<p>Computes a percentile using continuous distribution, following the SQL standard <code>PERCENTILE_CONT</code> semantics. P is expressed on a 0.0-to-1.0 scale (e.g., 0.5 for the median) and must be the same value for every row in the group. Uses linear interpolation between adjacent values when the percentile falls between two data points. Returns NULL if all inputs are NULL.</p>
<pre><code class="language-sql">SELECT percentile_cont(value, 0.5) FROM scores;
-- 3.0
</code></pre>
<h2 id="percentile_disc"><a class="header" href="#percentile_disc">percentile_disc</a></h2>
<p><strong>percentile_disc(Y, P) -&gt; real</strong></p>
<p>Computes a percentile using discrete distribution, following the SQL standard <code>PERCENTILE_DISC</code> semantics. P is expressed on a 0.0-to-1.0 scale and must be the same value for every row in the group. Unlike <code>percentile_cont</code>, this function always returns an actual value from the input set rather than interpolating between values. Returns NULL if all inputs are NULL.</p>
<pre><code class="language-sql">SELECT percentile_disc(value, 0.5) FROM scores;
-- 3.0
</code></pre>
<h2 id="stddev"><a class="header" href="#stddev">stddev</a></h2>
<p><strong>stddev(X) -&gt; real</strong></p>
<p>Returns the population standard deviation of all non-NULL values of X. The standard deviation measures how spread out values are from their mean. Returns NULL if all inputs are NULL or if the input set is empty.</p>
<pre><code class="language-sql">SELECT stddev(value) FROM scores;
-- 1.58113883008419
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="date-and-time-functions"><a class="header" href="#date-and-time-functions">Date and Time Functions</a></h1>
<p>Turso provides seven date and time functions for computing dates, times, and timestamps. All functions operate on UTC internally and accept an optional list of modifiers that transform the result.</p>
<h2 id="date"><a class="header" href="#date">date</a></h2>
<p><strong>date(time-value, modifier, …) -&gt; TEXT</strong></p>
<p>Returns the date as text in the format <code>YYYY-MM-DD</code>.</p>
<pre><code class="language-sql">SELECT date('2024-06-15 14:30:00');  -- 2024-06-15
SELECT date('2024-06-15', '+10 days');  -- 2024-06-25
SELECT date('2024-06-15', '-30 days');  -- 2024-05-16
</code></pre>
<h2 id="time"><a class="header" href="#time">time</a></h2>
<p><strong>time(time-value, modifier, …) -&gt; TEXT</strong></p>
<p>Returns the time as text in the format <code>HH:MM:SS</code>.</p>
<pre><code class="language-sql">SELECT time('2024-06-15 14:30:45');  -- 14:30:45
SELECT time('14:30:00');  -- 14:30:00
</code></pre>
<h2 id="datetime"><a class="header" href="#datetime">datetime</a></h2>
<p><strong>datetime(time-value, modifier, …) -&gt; TEXT</strong></p>
<p>Returns the date and time as text in the format <code>YYYY-MM-DD HH:MM:SS</code>. When the <code>subsec</code> modifier is present, the output includes fractional seconds: <code>YYYY-MM-DD HH:MM:SS.SSS</code>.</p>
<pre><code class="language-sql">SELECT datetime('2024-06-15 14:30:00');  -- 2024-06-15 14:30:00
SELECT datetime('2024-06-15 14:30:00', '+3 hours');  -- 2024-06-15 17:30:00
SELECT datetime('2024-06-15 14:30:00', 'subsec');  -- 2024-06-15 14:30:00.000
</code></pre>
<p>Converting a Unix timestamp to a human-readable datetime:</p>
<pre><code class="language-sql">SELECT datetime(1718461800, 'unixepoch');  -- 2024-06-15 14:30:00
</code></pre>
<h2 id="julianday"><a class="header" href="#julianday">julianday</a></h2>
<p><strong>julianday(time-value, modifier, …) -&gt; REAL</strong></p>
<p>Returns the Julian day number – the fractional number of days since noon in Greenwich on November 24, 4714 B.C. (Proleptic Gregorian calendar).</p>
<pre><code class="language-sql">SELECT julianday('2024-06-15');  -- 2460476.5
</code></pre>
<p>Compute the number of days between two dates:</p>
<pre><code class="language-sql">SELECT julianday('2024-06-15') - julianday('2024-01-01');  -- 166.0
</code></pre>
<h2 id="unixepoch"><a class="header" href="#unixepoch">unixepoch</a></h2>
<p><strong>unixepoch(time-value, modifier, …) -&gt; INTEGER</strong></p>
<p>Returns the number of seconds since <code>1970-01-01 00:00:00 UTC</code>. Returns an integer by default; use the <code>subsec</code> modifier for a floating-point result with fractional seconds.</p>
<pre><code class="language-sql">SELECT unixepoch('2024-06-15 14:30:00');  -- 1718461800
</code></pre>
<p>Compute the number of seconds between two timestamps:</p>
<pre><code class="language-sql">SELECT unixepoch('2024-06-15 14:30:00') - unixepoch('2024-06-15 12:00:00');  -- 9000
</code></pre>
<h2 id="strftime"><a class="header" href="#strftime">strftime</a></h2>
<p><strong>strftime(format, time-value, modifier, …) -&gt; TEXT</strong></p>
<p>Returns the date formatted according to the format string specified as the first argument. The format string supports the substitutions listed in the <a href="#format-specifiers">Format Specifiers</a> table below.</p>
<pre><code class="language-sql">SELECT strftime('%Y/%m/%d', '2024-06-15');  -- 2024/06/15
SELECT strftime('%H:%M', '2024-06-15 14:30:00');  -- 14:30
SELECT strftime('%j', '2024-06-15');  -- 167
SELECT strftime('%s', '2024-06-15 14:30:00');  -- 1718461800
SELECT strftime('%J', '2024-06-15');  -- 2460476.5
</code></pre>
<p>The other date/time functions can be expressed as <code>strftime</code> equivalents:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>strftime Equivalent</th></tr>
</thead>
<tbody>
<tr><td><code>date(...)</code></td><td><code>strftime('%F', ...)</code></td></tr>
<tr><td><code>time(...)</code></td><td><code>strftime('%T', ...)</code></td></tr>
<tr><td><code>datetime(...)</code></td><td><code>strftime('%F %T', ...)</code></td></tr>
<tr><td><code>julianday(...)</code></td><td><code>CAST(strftime('%J', ...) AS REAL)</code></td></tr>
<tr><td><code>unixepoch(...)</code></td><td><code>CAST(strftime('%s', ...) AS INT)</code></td></tr>
</tbody>
</table>
</div>
<h2 id="timediff"><a class="header" href="#timediff">timediff</a></h2>
<p><strong>timediff(time-value-A, time-value-B) -&gt; TEXT</strong></p>
<p>Returns a text string describing the amount of time that must be added to the second argument to reach the first. The result has the format <code>(+|-)YYYY-MM-DD HH:MM:SS.SSS</code>.</p>
<p>The <code>timediff</code> function does not accept modifiers. It satisfies the invariant that <code>datetime(A)</code> equals <code>datetime(B, timediff(A, B))</code>.</p>
<pre><code class="language-sql">SELECT timediff('2024-06-15', '2024-01-01');  -- +0000-05-14 00:00:00.000
SELECT timediff('2024-06-15 14:30:00', '2024-06-15 12:00:00');  -- +0000-00-00 02:30:00.000
</code></pre>
<p>Because months and years vary in length, <code>timediff</code> may return the same text for intervals that span different numbers of days. For precise day-level differences, subtract Julian day numbers instead:</p>
<pre><code class="language-sql">SELECT julianday('2024-06-15') - julianday('2024-01-01');  -- 166.0
</code></pre>
<h2 id="time-value-formats"><a class="header" href="#time-value-formats">Time Value Formats</a></h2>
<p>All date/time functions accept time values in the following formats:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>YYYY-MM-DD</code></td><td><code>'2024-06-15'</code></td></tr>
<tr><td><code>YYYY-MM-DD HH:MM</code></td><td><code>'2024-06-15 14:30'</code></td></tr>
<tr><td><code>YYYY-MM-DD HH:MM:SS</code></td><td><code>'2024-06-15 14:30:00'</code></td></tr>
<tr><td><code>YYYY-MM-DD HH:MM:SS.SSS</code></td><td><code>'2024-06-15 14:30:00.123'</code></td></tr>
<tr><td><code>YYYY-MM-DDTHH:MM:SS</code></td><td><code>'2024-06-15T14:30:00'</code></td></tr>
<tr><td><code>HH:MM:SS</code></td><td><code>'14:30:00'</code> (assumes date 2000-01-01)</td></tr>
<tr><td><code>'now'</code></td><td>Current date and time in UTC</td></tr>
<tr><td><code>DDDDDDDDDD</code></td><td>Julian day number as a numeric value</td></tr>
</tbody>
</table>
</div>
<p>The ISO 8601 <code>T</code> separator between date and time is accepted interchangeably with a space:</p>
<pre><code class="language-sql">SELECT date('2024-06-15T14:30:00');  -- 2024-06-15
</code></pre>
<p>An optional timezone suffix <code>[+-]HH:MM</code> or <code>Z</code> may follow any format that includes a time component. The suffix <code>Z</code> denotes UTC (a no-op). A non-zero offset is subtracted to convert the value to UTC.</p>
<h2 id="modifiers"><a class="header" href="#modifiers">Modifiers</a></h2>
<p>All date/time functions except <code>timediff</code> accept zero or more modifiers after the time value. Modifiers are applied from left to right; order matters.</p>
<h3 id="arithmetic-modifiers"><a class="header" href="#arithmetic-modifiers">Arithmetic Modifiers</a></h3>
<p>Add or subtract a duration from the time value. The <code>NNN</code> value can be an integer or floating-point number, with an optional <code>+</code> or <code>-</code> prefix. The trailing <code>s</code> is optional (e.g., <code>'+1 day'</code> and <code>'+1 days'</code> are equivalent).</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Modifier</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><code>NNN days</code></td><td>Add NNN days</td></tr>
<tr><td><code>NNN hours</code></td><td>Add NNN hours</td></tr>
<tr><td><code>NNN minutes</code></td><td>Add NNN minutes</td></tr>
<tr><td><code>NNN seconds</code></td><td>Add NNN seconds</td></tr>
<tr><td><code>NNN months</code></td><td>Add NNN months</td></tr>
<tr><td><code>NNN years</code></td><td>Add NNN years</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT date('2024-06-15', '+1 month');  -- 2024-07-15
SELECT date('2024-06-15', '+1 year');  -- 2025-06-15
SELECT datetime('2024-06-15 14:30:00', '+90 minutes');  -- 2024-06-15 16:00:00
SELECT datetime('2024-06-15 14:30:00', '+30 seconds');  -- 2024-06-15 14:30:30
</code></pre>
<p>Multiple modifiers chain together from left to right:</p>
<pre><code class="language-sql">SELECT datetime('2024-06-15 14:30:00', '+1 year', '-2 months');  -- 2025-04-15 14:30:00
</code></pre>
<h3 id="timedatedatetime-offset-modifiers"><a class="header" href="#timedatedatetime-offset-modifiers">Time/Date/DateTime Offset Modifiers</a></h3>
<p>Shift a time value by a compound offset specified in time, date, or full datetime format. A leading <code>+</code> or <code>-</code> is required for date offsets.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Modifier Format</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>[+-]HH:MM</code></td><td><code>'-05:00'</code></td></tr>
<tr><td><code>[+-]HH:MM:SS</code></td><td><code>'+01:30:00'</code></td></tr>
<tr><td><code>[+-]YYYY-MM-DD</code></td><td><code>'+0001-06-00'</code></td></tr>
<tr><td><code>[+-]YYYY-MM-DD HH:MM:SS</code></td><td><code>'+0000-00-01 02:00:00'</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT datetime('2024-06-15 14:30:00', '-05:00');  -- 2024-06-15 09:30:00
</code></pre>
<h3 id="start-of-modifiers"><a class="header" href="#start-of-modifiers">Start-of Modifiers</a></h3>
<p>Truncate the time value backward to the beginning of a period.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Modifier</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><code>start of day</code></td><td>Sets time to <code>00:00:00</code></td></tr>
<tr><td><code>start of month</code></td><td>Sets to first day of the month at <code>00:00:00</code></td></tr>
<tr><td><code>start of year</code></td><td>Sets to January 1 at <code>00:00:00</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT datetime('2024-06-15 14:30:00', 'start of day');  -- 2024-06-15 00:00:00
SELECT date('2024-06-15', 'start of month');  -- 2024-06-01
SELECT date('2024-06-15', 'start of year');  -- 2024-01-01
</code></pre>
<p>Chaining start-of modifiers with arithmetic is useful for computing boundaries:</p>
<pre><code class="language-sql">-- Last day of the current month
SELECT date('2024-06-15', 'start of month', '+1 month', '-1 day');  -- 2024-06-30
</code></pre>
<h3 id="weekday-n"><a class="header" href="#weekday-n">weekday N</a></h3>
<p>Advance the date forward to the next occurrence of weekday <code>N</code>, where Sunday is 0, Monday is 1, through Saturday which is 6. If the date already falls on the requested weekday, it is left unchanged.</p>
<pre><code class="language-sql">-- 2024-06-15 is a Saturday (6); the next Sunday (0) is 2024-06-16
SELECT date('2024-06-15', 'weekday 0');  -- 2024-06-16

-- First Tuesday in October 2024
SELECT date('2024-06-15', 'start of year', '+9 months', 'weekday 2');  -- 2024-10-01
</code></pre>
<h3 id="ceiling-and-floor"><a class="header" href="#ceiling-and-floor">ceiling and floor</a></h3>
<p>When adding months or years produces an ambiguous date (for example, one month after January 31), the <code>ceiling</code> and <code>floor</code> modifiers control how the ambiguity is resolved.</p>
<ul>
<li><code>ceiling</code> (the default) rounds forward to the next valid date.</li>
<li><code>floor</code> rounds backward to the last day of the previous month.</li>
</ul>
<pre><code class="language-sql">SELECT date('2024-01-31', '+1 month', 'ceiling');  -- 2024-03-02
SELECT date('2024-01-31', '+1 month', 'floor');  -- 2024-02-29
</code></pre>
<h3 id="format-interpretation-modifiers"><a class="header" href="#format-interpretation-modifiers">Format Interpretation Modifiers</a></h3>
<p>These modifiers control how a bare numeric time value (<code>DDDDDDDDDD</code>) is interpreted. They must appear immediately after the time value.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Modifier</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><code>unixepoch</code></td><td>Interpret the number as seconds since 1970-01-01 00:00:00 UTC</td></tr>
<tr><td><code>julianday</code></td><td>Interpret the number as a Julian day number (the default)</td></tr>
<tr><td><code>auto</code></td><td>Automatically choose based on magnitude: small values are Julian day numbers, large values are Unix timestamps</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT datetime(1718461800, 'unixepoch');  -- 2024-06-15 14:30:00
SELECT datetime(2460476.5, 'julianday');  -- 2024-06-15 00:00:00
SELECT datetime(1718461800, 'auto');  -- 2024-06-15 14:30:00
</code></pre>
<h3 id="timezone-modifiers"><a class="header" href="#timezone-modifiers">Timezone Modifiers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Modifier</th><th>Effect</th></tr>
</thead>
<tbody>
<tr><td><code>localtime</code></td><td>Convert from UTC to local time</td></tr>
<tr><td><code>utc</code></td><td>Convert from local time to UTC</td></tr>
</tbody>
</table>
</div>
<h3 id="subsec"><a class="header" href="#subsec">subsec</a></h3>
<p>The <code>subsec</code> (or <code>subsecond</code>) modifier increases output resolution from seconds to milliseconds.</p>
<ul>
<li>With <code>datetime</code> or <code>time</code>: appends <code>.SSS</code> to the seconds field.</li>
<li>With <code>unixepoch</code>: returns a floating-point value instead of an integer.</li>
</ul>
<pre><code class="language-sql">SELECT datetime('2024-06-15 14:30:00', 'subsec');  -- 2024-06-15 14:30:00.000
</code></pre>
<h2 id="format-specifiers"><a class="header" href="#format-specifiers">Format Specifiers</a></h2>
<p>The <code>strftime</code> function accepts the following format specifiers:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Specifier</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>%d</code></td><td>Day of month: 01-31</td><td><code>15</code></td></tr>
<tr><td><code>%f</code></td><td>Fractional seconds: SS.SSS</td><td><code>00.123</code></td></tr>
<tr><td><code>%H</code></td><td>Hour: 00-24</td><td><code>14</code></td></tr>
<tr><td><code>%j</code></td><td>Day of year: 001-366</td><td><code>167</code></td></tr>
<tr><td><code>%J</code></td><td>Julian day number (fractional)</td><td><code>2460476.5</code></td></tr>
<tr><td><code>%m</code></td><td>Month: 01-12</td><td><code>06</code></td></tr>
<tr><td><code>%M</code></td><td>Minute: 00-59</td><td><code>30</code></td></tr>
<tr><td><code>%s</code></td><td>Seconds since 1970-01-01</td><td><code>1718461800</code></td></tr>
<tr><td><code>%S</code></td><td>Seconds: 00-59</td><td><code>45</code></td></tr>
<tr><td><code>%w</code></td><td>Day of week: 0-6 (Sunday=0)</td><td><code>6</code></td></tr>
<tr><td><code>%W</code></td><td>Week of year: 00-53</td><td><code>24</code></td></tr>
<tr><td><code>%Y</code></td><td>Year: 0000-9999</td><td><code>2024</code></td></tr>
<tr><td><code>%%</code></td><td>Literal <code>%</code> character</td><td><code>%</code></td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT strftime('%f', '2024-06-15 14:30:00.123');  -- 00.123
SELECT strftime('%w', '2024-06-15');  -- 6
SELECT strftime('%W', '2024-06-15');  -- 24
SELECT strftime('%S', '2024-06-15 14:30:45');  -- 45
SELECT strftime('%m', '2024-06-15');  -- 06
</code></pre>
<p>Unrecognized format specifiers return NULL.</p>
<h2 id="null-handling-4"><a class="header" href="#null-handling-4">NULL Handling</a></h2>
<p>All date/time functions return NULL when given an invalid input, an out-of-range date, or an unrecognized modifier. The valid date range is <code>0000-01-01 00:00:00</code> through <code>9999-12-31 23:59:59</code>.</p>
<h2 id="calendar-notes"><a class="header" href="#calendar-notes">Calendar Notes</a></h2>
<p>All computations use the Proleptic Gregorian calendar. Each day is treated as exactly 86,400 seconds; leap seconds are not incorporated.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="math-functions"><a class="header" href="#math-functions">Math Functions</a></h1>
<p>Turso provides a full set of mathematical functions for trigonometry, logarithms, exponentiation, and rounding. All math functions accept integers, floating-point numbers, or strings that look like numbers. They return an IEEE 754 double-precision floating-point result, except when the input is an integer and the result can be represented exactly as an integer.</p>
<p>All math functions return NULL when any argument is NULL, when an argument is a blob or non-numeric string, or when the result would be mathematically undefined (a domain error).</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<h3 id="pi"><a class="header" href="#pi">pi</a></h3>
<p><strong>pi() -&gt; real</strong></p>
<p>Returns an approximation of the mathematical constant pi.</p>
<pre><code class="language-sql">SELECT pi();  -- 3.14159265358979
</code></pre>
<h2 id="trigonometric-functions"><a class="header" href="#trigonometric-functions">Trigonometric Functions</a></h2>
<p>All trigonometric functions work in radians. Use <code>radians()</code> and <code>degrees()</code> to convert between degrees and radians.</p>
<h3 id="acos"><a class="header" href="#acos">acos</a></h3>
<p><strong>acos(X) -&gt; real</strong></p>
<p>Returns the arccosine of X, in radians. X must be between -1.0 and 1.0; returns NULL for values outside that range.</p>
<pre><code class="language-sql">SELECT acos(0.5);  -- 1.0471975511966
</code></pre>
<h3 id="asin"><a class="header" href="#asin">asin</a></h3>
<p><strong>asin(X) -&gt; real</strong></p>
<p>Returns the arcsine of X, in radians. X must be between -1.0 and 1.0; returns NULL for values outside that range.</p>
<pre><code class="language-sql">SELECT asin(0.5);  -- 0.523598775598299
</code></pre>
<h3 id="atan"><a class="header" href="#atan">atan</a></h3>
<p><strong>atan(X) -&gt; real</strong></p>
<p>Returns the arctangent of X, in radians.</p>
<pre><code class="language-sql">SELECT atan(1.0);  -- 0.785398163397448
</code></pre>
<h3 id="atan2"><a class="header" href="#atan2">atan2</a></h3>
<p><strong>atan2(Y, X) -&gt; real</strong></p>
<p>Returns the arctangent of Y/X, in radians, using the signs of both arguments to determine the quadrant of the result. Unlike <code>atan(Y/X)</code>, <code>atan2</code> correctly handles cases where X is zero.</p>
<pre><code class="language-sql">SELECT atan2(1.0, 1.0);  -- 0.785398163397448
</code></pre>
<h3 id="cos"><a class="header" href="#cos">cos</a></h3>
<p><strong>cos(X) -&gt; real</strong></p>
<p>Returns the cosine of X, where X is in radians.</p>
<pre><code class="language-sql">SELECT cos(0.0);  -- 1.0
</code></pre>
<h3 id="sin"><a class="header" href="#sin">sin</a></h3>
<p><strong>sin(X) -&gt; real</strong></p>
<p>Returns the sine of X, where X is in radians.</p>
<pre><code class="language-sql">SELECT sin(pi() / 6);  -- 0.5
</code></pre>
<h3 id="tan"><a class="header" href="#tan">tan</a></h3>
<p><strong>tan(X) -&gt; real</strong></p>
<p>Returns the tangent of X, where X is in radians.</p>
<pre><code class="language-sql">SELECT tan(pi() / 4);  -- 1.0
</code></pre>
<h2 id="hyperbolic-functions"><a class="header" href="#hyperbolic-functions">Hyperbolic Functions</a></h2>
<h3 id="acosh"><a class="header" href="#acosh">acosh</a></h3>
<p><strong>acosh(X) -&gt; real</strong></p>
<p>Returns the inverse hyperbolic cosine of X. X must be greater than or equal to 1.0; returns NULL for values less than 1.0.</p>
<pre><code class="language-sql">SELECT acosh(2.0);  -- 1.31695789692482
</code></pre>
<h3 id="asinh"><a class="header" href="#asinh">asinh</a></h3>
<p><strong>asinh(X) -&gt; real</strong></p>
<p>Returns the inverse hyperbolic sine of X.</p>
<pre><code class="language-sql">SELECT asinh(1.0);  -- 0.881373587019543
</code></pre>
<h3 id="atanh"><a class="header" href="#atanh">atanh</a></h3>
<p><strong>atanh(X) -&gt; real</strong></p>
<p>Returns the inverse hyperbolic tangent of X. X must be between -1.0 and 1.0 (exclusive); returns NULL for values outside that range.</p>
<pre><code class="language-sql">SELECT atanh(0.5);  -- 0.549306144334055
</code></pre>
<h3 id="cosh"><a class="header" href="#cosh">cosh</a></h3>
<p><strong>cosh(X) -&gt; real</strong></p>
<p>Returns the hyperbolic cosine of X.</p>
<pre><code class="language-sql">SELECT cosh(1.0);  -- 1.54308063481524
</code></pre>
<h3 id="sinh"><a class="header" href="#sinh">sinh</a></h3>
<p><strong>sinh(X) -&gt; real</strong></p>
<p>Returns the hyperbolic sine of X.</p>
<pre><code class="language-sql">SELECT sinh(1.0);  -- 1.1752011936438
</code></pre>
<h3 id="tanh"><a class="header" href="#tanh">tanh</a></h3>
<p><strong>tanh(X) -&gt; real</strong></p>
<p>Returns the hyperbolic tangent of X.</p>
<pre><code class="language-sql">SELECT tanh(1.0);  -- 0.761594155955765
</code></pre>
<h2 id="angle-conversion"><a class="header" href="#angle-conversion">Angle Conversion</a></h2>
<h3 id="degrees"><a class="header" href="#degrees">degrees</a></h3>
<p><strong>degrees(X) -&gt; real</strong></p>
<p>Converts X from radians to degrees.</p>
<pre><code class="language-sql">SELECT degrees(pi());  -- 180.0
</code></pre>
<h3 id="radians"><a class="header" href="#radians">radians</a></h3>
<p><strong>radians(X) -&gt; real</strong></p>
<p>Converts X from degrees to radians.</p>
<pre><code class="language-sql">SELECT radians(180.0);  -- 3.14159265358979
</code></pre>
<h2 id="exponential-and-logarithmic-functions"><a class="header" href="#exponential-and-logarithmic-functions">Exponential and Logarithmic Functions</a></h2>
<h3 id="exp"><a class="header" href="#exp">exp</a></h3>
<p><strong>exp(X) -&gt; real</strong></p>
<p>Returns the value of e (Euler’s number, approximately 2.71828) raised to the power X.</p>
<pre><code class="language-sql">SELECT exp(1.0);  -- 2.71828182845905
</code></pre>
<h3 id="ln"><a class="header" href="#ln">ln</a></h3>
<p><strong>ln(X) -&gt; real</strong></p>
<p>Returns the natural logarithm (base e) of X. Returns NULL if X is less than or equal to zero.</p>
<pre><code class="language-sql">SELECT ln(exp(1.0));  -- 1.0
</code></pre>
<h3 id="log"><a class="header" href="#log">log</a></h3>
<p><strong>log(X) -&gt; real</strong></p>
<p>With a single argument, returns the base-10 logarithm of X. Returns NULL if X is less than or equal to zero.</p>
<pre><code class="language-sql">SELECT log(100.0);  -- 2.0
</code></pre>
<p><strong>log(B, X) -&gt; real</strong></p>
<p>With two arguments, returns the base-B logarithm of X. Returns NULL if either argument is less than or equal to zero.</p>
<pre><code class="language-sql">SELECT log(2, 8);  -- 3.0
</code></pre>
<p>Note: the single-argument form of <code>log()</code> computes base-10, not the natural logarithm. Use <code>ln()</code> for the natural logarithm.</p>
<h3 id="log10"><a class="header" href="#log10">log10</a></h3>
<p><strong>log10(X) -&gt; real</strong></p>
<p>Returns the base-10 logarithm of X. Returns NULL if X is less than or equal to zero. Equivalent to <code>log(X)</code> with a single argument.</p>
<pre><code class="language-sql">SELECT log10(1000.0);  -- 3.0
</code></pre>
<h3 id="log2"><a class="header" href="#log2">log2</a></h3>
<p><strong>log2(X) -&gt; real</strong></p>
<p>Returns the base-2 logarithm of X. Returns NULL if X is less than or equal to zero.</p>
<pre><code class="language-sql">SELECT log2(64);  -- 6.0
</code></pre>
<h2 id="power-and-root-functions"><a class="header" href="#power-and-root-functions">Power and Root Functions</a></h2>
<h3 id="pow--power"><a class="header" href="#pow--power">pow / power</a></h3>
<p><strong>pow(X, Y) -&gt; real</strong>
<strong>power(X, Y) -&gt; real</strong></p>
<p>Returns X raised to the power Y. <code>pow</code> and <code>power</code> are aliases for the same function.</p>
<pre><code class="language-sql">SELECT pow(2, 10);   -- 1024.0
SELECT power(3, 4);  -- 81.0
</code></pre>
<h3 id="sqrt"><a class="header" href="#sqrt">sqrt</a></h3>
<p><strong>sqrt(X) -&gt; real</strong></p>
<p>Returns the square root of X. Returns NULL if X is negative.</p>
<pre><code class="language-sql">SELECT sqrt(144);  -- 12.0
</code></pre>
<h2 id="rounding-functions"><a class="header" href="#rounding-functions">Rounding Functions</a></h2>
<h3 id="ceil--ceiling"><a class="header" href="#ceil--ceiling">ceil / ceiling</a></h3>
<p><strong>ceil(X) -&gt; integer/real</strong>
<strong>ceiling(X) -&gt; integer/real</strong></p>
<p>Returns the smallest integer not less than X (rounds toward positive infinity). <code>ceil</code> and <code>ceiling</code> are aliases. When the input is an integer, the result is that same integer. When the input is a float, the result is a float with an integer value.</p>
<pre><code class="language-sql">SELECT ceil(3.2);     -- 4.0
SELECT ceiling(-2.8); -- -2.0
SELECT ceil(5);       -- 5
</code></pre>
<h3 id="floor"><a class="header" href="#floor">floor</a></h3>
<p><strong>floor(X) -&gt; integer/real</strong></p>
<p>Returns the largest integer not greater than X (rounds toward negative infinity). When the input is an integer, the result is that same integer. When the input is a float, the result is a float with an integer value.</p>
<pre><code class="language-sql">SELECT floor(3.8);   -- 3.0
SELECT floor(-2.3);  -- -3.0
SELECT floor(5);     -- 5
</code></pre>
<h3 id="trunc"><a class="header" href="#trunc">trunc</a></h3>
<p><strong>trunc(X) -&gt; integer/real</strong></p>
<p>Returns the integer part of X by removing any fractional digits (rounds toward zero). When the input is an integer, the result is that same integer. When the input is a float, the result is a float with an integer value.</p>
<pre><code class="language-sql">SELECT trunc(3.7);   -- 3.0
SELECT trunc(-3.7);  -- -3.0
SELECT trunc(5);     -- 5
</code></pre>
<p>The difference between these three rounding functions is visible with negative values:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>ceil</th><th>floor</th><th>trunc</th></tr>
</thead>
<tbody>
<tr><td>3.7</td><td>4.0</td><td>3.0</td><td>3.0</td></tr>
<tr><td>-3.7</td><td>-3.0</td><td>-4.0</td><td>-3.0</td></tr>
</tbody>
</table>
</div>
<p><code>ceil</code> rounds toward positive infinity, <code>floor</code> rounds toward negative infinity, and <code>trunc</code> rounds toward zero.</p>
<h2 id="remainder-function"><a class="header" href="#remainder-function">Remainder Function</a></h2>
<h3 id="mod"><a class="header" href="#mod">mod</a></h3>
<p><strong>mod(X, Y) -&gt; real</strong></p>
<p>Returns the remainder after dividing X by Y. Unlike the <code>%</code> operator, <code>mod()</code> works correctly with floating-point arguments. Returns NULL if Y is zero.</p>
<pre><code class="language-sql">SELECT mod(10, 3);      -- 1.0
SELECT mod(10.5, 3.0);  -- 1.5
</code></pre>
<h2 id="null-and-error-handling"><a class="header" href="#null-and-error-handling">NULL and Error Handling</a></h2>
<p>All math functions follow these rules:</p>
<ul>
<li><strong>NULL input</strong>: any NULL argument produces a NULL result.</li>
<li><strong>Non-numeric input</strong>: blob values and strings that cannot be converted to a number produce a NULL result.</li>
<li><strong>Domain errors</strong>: operations with no real-valued result return NULL rather than raising an error. Examples include <code>sqrt(-1)</code>, <code>acos(2.0)</code>, <code>ln(-1)</code>, and <code>log(-5)</code>.</li>
</ul>
<pre><code class="language-sql">SELECT sqrt(-1);    -- NULL
SELECT acos(2.0);   -- NULL
SELECT acos(NULL);  -- NULL
SELECT ln(-1);      -- NULL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="json-functions"><a class="header" href="#json-functions">JSON Functions</a></h1>
<p>Turso includes a comprehensive set of JSON functions for creating, querying, modifying, and aggregating JSON data. These functions accept both JSON text and JSONB (binary JSON) as input.</p>
<h2 id="json-path-syntax"><a class="header" href="#json-path-syntax">JSON Path Syntax</a></h2>
<p>Many JSON functions take a <code>path</code> argument that identifies a specific element within a JSON structure. A well-formed path begins with <code>$</code> (the root element) followed by zero or more accessors:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Accessor</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>$.key</code></td><td>Object member by name</td></tr>
<tr><td><code>$[N]</code></td><td>Array element at index N (0-based)</td></tr>
<tr><td><code>$[#-N]</code></td><td>Array element N from the end</td></tr>
<tr><td><code>$[#]</code></td><td>Position after last array element (for appending)</td></tr>
</tbody>
</table>
</div>
<p>Examples: <code>$</code> (root), <code>$.name</code> (object field), <code>$[0]</code> (first array element), <code>$.items[2].price</code> (nested access), <code>$[#-1]</code> (last array element).</p>
<h2 id="value-argument-conventions"><a class="header" href="#value-argument-conventions">Value Argument Conventions</a></h2>
<p>When a function parameter is labeled “value,” plain text arguments become quoted JSON strings in the result. To embed actual JSON (not a string), wrap the value with <code>json()</code> or another JSON function:</p>
<pre><code class="language-sql">SELECT json_object('data', '[1,2,3]');           -- {"data":"[1,2,3]"}
SELECT json_object('data', json('[1,2,3]'));      -- {"data":[1,2,3]}
</code></pre>
<hr>
<h2 id="creation-functions"><a class="header" href="#creation-functions">Creation Functions</a></h2>
<h3 id="json"><a class="header" href="#json">json</a></h3>
<p><strong>json(json) -&gt; text</strong></p>
<p>Validates and minifies a JSON string. Accepts JSON text, JSONB blobs, and JSON5 input. Returns canonical RFC-8259 JSON with whitespace removed. Raises an error if the input is malformed.</p>
<pre><code class="language-sql">SELECT json(' { "name" : "Alice", "scores": [ 90, 85 ] } ');
-- {"name":"Alice","scores":[90,85]}
</code></pre>
<p>JSON5 extensions such as unquoted keys, trailing commas, and comments are accepted on input but normalized to standard JSON on output:</p>
<pre><code class="language-sql">SELECT json('{name: "Alice", age: 25}');
-- {"name":"Alice","age":25}
</code></pre>
<h3 id="jsonb"><a class="header" href="#jsonb">jsonb</a></h3>
<p><strong>jsonb(json) -&gt; blob</strong></p>
<p>Returns the JSONB (binary) representation of the input. JSONB is an opaque binary format that can be faster to process than text JSON. All JSON functions accept JSONB as input.</p>
<pre><code class="language-sql">SELECT json(jsonb('{"name":"John","age":30}'));
-- {"name":"John","age":30}
</code></pre>
<h3 id="json_array"><a class="header" href="#json_array">json_array</a></h3>
<p><strong>json_array(value1, value2, …) -&gt; text</strong></p>
<p>Creates a JSON array from the given arguments. Text arguments become quoted JSON strings unless they come from another JSON function.</p>
<pre><code class="language-sql">SELECT json_array(1, 2, '3', 4);              -- [1,2,"3",4]
SELECT json_array(json_array(1, 2), 'text');   -- [[1,2],"text"]
SELECT json_array(1, null, json('[4,5]'));      -- [1,null,[4,5]]
</code></pre>
<p><code>jsonb_array(...)</code> returns the same result in JSONB format.</p>
<h3 id="json_object"><a class="header" href="#json_object">json_object</a></h3>
<p><strong>json_object(label1, value1, …) -&gt; text</strong></p>
<p>Creates a JSON object from label/value pairs. Labels must be strings. Text values become quoted JSON strings unless produced by another JSON function.</p>
<pre><code class="language-sql">SELECT json_object('name', 'Alice', 'age', 25);
-- {"name":"Alice","age":25}

SELECT json_object('user', json_object('id', 1, 'role', 'admin'));
-- {"user":{"id":1,"role":"admin"}}

SELECT json_object();
-- {}
</code></pre>
<p><code>jsonb_object(...)</code> returns the same result in JSONB format.</p>
<h3 id="json_quote"><a class="header" href="#json_quote">json_quote</a></h3>
<p><strong>json_quote(value) -&gt; text</strong></p>
<p>Converts an SQL value into its JSON representation. Strings are quoted and interior quotes are escaped. NULL becomes the JSON literal <code>null</code>. If the value is already JSON (from another JSON function), it is returned unchanged.</p>
<pre><code class="language-sql">SELECT json_quote('hello');     -- "hello"
SELECT json_quote(3.14159);     -- 3.14159
SELECT json_quote(12345);       -- 12345
SELECT json_quote(null);        -- null
</code></pre>
<hr>
<h2 id="extraction-functions"><a class="header" href="#extraction-functions">Extraction Functions</a></h2>
<h3 id="json_extract"><a class="header" href="#json_extract">json_extract</a></h3>
<p><strong>json_extract(json, path, …) -&gt; value</strong></p>
<p>Extracts one or more values from a JSON document at the given path(s).</p>
<p>With a single path, the return type depends on the JSON element: SQL NULL for JSON null, INTEGER for integers and booleans, REAL for floating-point numbers, TEXT for strings, and a text JSON representation for objects and arrays.</p>
<p>With multiple paths, returns a JSON array containing all extracted values.</p>
<pre><code class="language-sql">SELECT json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c[2].f');
-- 7

SELECT json_extract('{"a":[1,2,3]}', '$.a');
-- [1,2,3]

SELECT json_extract('{"a":[1,2,3]}', '$.a', '$.a[0]', '$.a[1]', '$.a[3]');
-- [[1,2,3],1,2,null]
</code></pre>
<p>Returns NULL if the input JSON is NULL. Raises an error if the JSON is malformed.</p>
<p><code>jsonb_extract(...)</code> returns JSONB for objects and arrays instead of text JSON.</p>
<h3 id="--extract-as-json"><a class="header" href="#--extract-as-json">-&gt; (extract as JSON)</a></h3>
<p><strong>json -&gt; path -&gt; text</strong></p>
<p>Extracts a value and always returns it as a JSON text representation. For strings, the result includes the surrounding quotes.</p>
<pre><code class="language-sql">SELECT '{"a":2,"c":[4,5]}' -&gt; '$.a';    -- 2
SELECT '{"a":"xyz"}' -&gt; '$.a';           -- "xyz"
SELECT '[1,2,3]' -&gt; 1;                   -- 2
</code></pre>
<p>The right operand can be a full path (<code>'$.field'</code>), a plain text label (interpreted as <code>'$.label'</code>), or an integer array index. Negative integers count from the end.</p>
<pre><code class="language-sql">SELECT '{"a":1}' -&gt; 'a';     -- 1
SELECT '[1,2,3]' -&gt; -1;      -- 3
</code></pre>
<p>The <code>-&gt;</code> operator can be chained:</p>
<pre><code class="language-sql">SELECT '{"a":2,"c":[4,5,{"f":7}]}' -&gt; 'c' -&gt; 2 -&gt;&gt; 'f';
-- 7
</code></pre>
<h3 id="--extract-as-sql-value"><a class="header" href="#--extract-as-sql-value">-&gt;&gt; (extract as SQL value)</a></h3>
<p><strong>json -&gt;&gt; path -&gt; value</strong></p>
<p>Extracts a value and returns it as an SQL type: TEXT for strings (without quotes), INTEGER for integers and booleans, REAL for floats, NULL for JSON null.</p>
<pre><code class="language-sql">SELECT '{"a":"xyz"}' -&gt;&gt; '$.a';     -- xyz   (text, no quotes)
SELECT '{"a":2}' -&gt;&gt; '$.a';         -- 2     (integer)
SELECT 'true' -&gt;&gt; '$';              -- 1     (integer)
SELECT 'false' -&gt;&gt; '$';             -- 0     (integer)
</code></pre>
<hr>
<h2 id="inspection-functions"><a class="header" href="#inspection-functions">Inspection Functions</a></h2>
<h3 id="json_array_length"><a class="header" href="#json_array_length">json_array_length</a></h3>
<p><strong>json_array_length(json [, path]) -&gt; integer</strong></p>
<p>Returns the number of elements in the JSON array. If the value at the specified path is not an array, returns 0. If the path does not exist, returns NULL.</p>
<pre><code class="language-sql">SELECT json_array_length('[1,2,3,4]');                       -- 4
SELECT json_array_length('[]');                               -- 0
SELECT json_array_length('{"one":[1,2,3]}', '$.one');        -- 3
SELECT json_array_length('{"one":[1,2,3]}');                  -- 0
SELECT json_array_length('{"one":[1,2,3]}', '$.two');        -- (NULL)
</code></pre>
<h3 id="json_type"><a class="header" href="#json_type">json_type</a></h3>
<p><strong>json_type(json [, path]) -&gt; text</strong></p>
<p>Returns a string indicating the type of the JSON element. Possible return values: <code>'object'</code>, <code>'array'</code>, <code>'integer'</code>, <code>'real'</code>, <code>'text'</code>, <code>'true'</code>, <code>'false'</code>, <code>'null'</code>. Returns NULL if the path does not exist.</p>
<pre><code class="language-sql">SELECT json_type('{"a":[2,3.5,true,false,null,"x"]}');           -- object
SELECT json_type('{"a":[2,3.5,true,false,null,"x"]}', '$.a');    -- array
SELECT json_type('{"a":[2,3.5,true,false,null,"x"]}', '$.a[0]'); -- integer
SELECT json_type('{"a":[2,3.5,true,false,null,"x"]}', '$.a[1]'); -- real
SELECT json_type('{"a":[2,3.5,true,false,null,"x"]}', '$.a[2]'); -- true
SELECT json_type('{"a":[2,3.5,true,false,null,"x"]}', '$.a[3]'); -- false
SELECT json_type('{"a":[2,3.5,true,false,null,"x"]}', '$.a[4]'); -- null
SELECT json_type('{"a":[2,3.5,true,false,null,"x"]}', '$.a[5]'); -- text
</code></pre>
<h3 id="json_valid"><a class="header" href="#json_valid">json_valid</a></h3>
<p><strong>json_valid(json [, flags]) -&gt; integer</strong></p>
<p>Returns 1 if the input is well-formed JSON, 0 if it is malformed, or NULL if the input is NULL.</p>
<p>Without flags (or with flags = 1), validates against RFC-8259 canonical JSON. The optional <code>flags</code> parameter is a bitmask that controls which formats are considered valid:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>RFC-8259 canonical JSON text</td></tr>
<tr><td>2</td><td>JSON5 text</td></tr>
<tr><td>4</td><td>JSONB (fast superficial check)</td></tr>
<tr><td>8</td><td>JSONB (strict thorough check)</td></tr>
</tbody>
</table>
</div>
<p>Flags can be combined with bitwise OR. Common combinations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Accepts</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>Standard JSON text only (default)</td></tr>
<tr><td>2</td><td>JSON5 text only</td></tr>
<tr><td>5</td><td>Standard JSON text or JSONB</td></tr>
<tr><td>6</td><td>JSON5 text or JSONB</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT json_valid('{"a":55,"b":72}');       -- 1
SELECT json_valid('not a valid json');       -- 0
SELECT json_valid(NULL);                     -- (NULL)
SELECT json_valid(123);                      -- 1
</code></pre>
<h3 id="json_error_position"><a class="header" href="#json_error_position">json_error_position</a></h3>
<p><strong>json_error_position(json) -&gt; integer</strong></p>
<p>Returns 0 if the input is well-formed JSON or JSON5. If malformed, returns the 1-based character position of the first syntax error. Returns NULL if the input is NULL.</p>
<pre><code class="language-sql">SELECT json_error_position('{"a":55,"b":72}');      -- 0
SELECT json_error_position('{"a":55,"b":72,,}');     -- 16
SELECT json_error_position(NULL);                     -- (NULL)
</code></pre>
<h3 id="json_pretty"><a class="header" href="#json_pretty">json_pretty</a></h3>
<p><strong>json_pretty(json [, indent]) -&gt; text</strong></p>
<p>Returns the input JSON formatted with whitespace for readability. The optional <code>indent</code> argument specifies the indentation string (default: four spaces). If <code>indent</code> is NULL, the default four spaces are used.</p>
<pre><code class="language-sql">SELECT json_pretty('{"name":"Alice","age":25}');
-- {
--     "name": "Alice",
--     "age": 25
-- }
</code></pre>
<hr>
<h2 id="modification-functions"><a class="header" href="#modification-functions">Modification Functions</a></h2>
<h3 id="json_set"><a class="header" href="#json_set">json_set</a></h3>
<p><strong>json_set(json, path, value, …) -&gt; text</strong></p>
<p>Creates or replaces values at the given paths. If the path exists, the value is replaced. If it does not exist, it is created (including intermediate objects and arrays as needed). Accepts multiple path/value pairs.</p>
<pre><code class="language-sql">SELECT json_set('{"a":2,"c":4}', '$.a', 99);
-- {"a":99,"c":4}

SELECT json_set('{"a":2,"c":4}', '$.e', 99);
-- {"a":2,"c":4,"e":99}

SELECT json_set('{}', '$.field', 'value');
-- {"field":"value"}

SELECT json_set('[123]', '$[0]', 456, '$[1]', 789);
-- [456,789]
</code></pre>
<p>To set a JSON value (not a string), wrap it with <code>json()</code>:</p>
<pre><code class="language-sql">SELECT json_set('{"a":2,"c":4}', '$.c', json('[97,96]'));
-- {"a":2,"c":[97,96]}
</code></pre>
<p><code>json_set</code> can create deeply nested structures:</p>
<pre><code class="language-sql">SELECT json_set('{}', '$.object.doesnt.exist', 'value');
-- {"object":{"doesnt":{"exist":"value"}}}
</code></pre>
<p><code>jsonb_set(...)</code> returns the same result in JSONB format.</p>
<h3 id="json_insert"><a class="header" href="#json_insert">json_insert</a></h3>
<p><strong>json_insert(json, path, value, …) -&gt; text</strong></p>
<p>Inserts values only where the path does not already exist. Existing values are not modified.</p>
<pre><code class="language-sql">SELECT json_insert('{"a":1}', '$.a', 2);         -- {"a":1}  (no change)
SELECT json_insert('{"a":1}', '$.b', 2);          -- {"a":1,"b":2}
SELECT json_insert('[1,2,3]', '$[3]', 4);          -- [1,2,3,4]
SELECT json_insert('{"a":1}', '$.b', 2, '$.c', 3);
-- {"a":1,"b":2,"c":3}
</code></pre>
<p><code>jsonb_insert(...)</code> returns the same result in JSONB format.</p>
<h3 id="json_replace"><a class="header" href="#json_replace">json_replace</a></h3>
<p><strong>json_replace(json, path, value, …) -&gt; text</strong></p>
<p>Replaces values only where the path already exists. Does not create new paths.</p>
<pre><code class="language-sql">SELECT json_replace('{"a":1,"b":2}', '$.a', 42);     -- {"a":42,"b":2}
SELECT json_replace('{"a":1,"b":2}', '$.c', 3);       -- {"a":1,"b":2}  (no change)
SELECT json_replace('[1,2,3,4]', '$[1]', 99);          -- [1,99,3,4]
</code></pre>
<p><code>jsonb_replace(...)</code> returns the same result in JSONB format.</p>
<h3 id="json_remove"><a class="header" href="#json_remove">json_remove</a></h3>
<p><strong>json_remove(json, path, …) -&gt; text</strong></p>
<p>Returns a copy of the JSON with elements at the specified paths removed. Paths that do not exist are silently ignored. Removing the root element (<code>$</code>) returns NULL.</p>
<pre><code class="language-sql">SELECT json_remove('{"a":1,"b":2,"c":3}', '$.b');          -- {"a":1,"c":3}
SELECT json_remove('[1,2,3,4]', '$[1]');                     -- [1,3,4]
SELECT json_remove('{"a":1,"b":2}', '$.a', '$.b');          -- {}
SELECT json_remove('{"a":1}', '$');                          -- (NULL)
</code></pre>
<p>When removing multiple array elements, removals are applied sequentially, and each removal shifts subsequent indices:</p>
<pre><code class="language-sql">SELECT json_remove('[0,1,2,3,4]', '$[2]', '$[0]');
-- [1,3,4]
</code></pre>
<p><code>jsonb_remove(...)</code> returns the same result in JSONB format.</p>
<h3 id="json_patch"><a class="header" href="#json_patch">json_patch</a></h3>
<p><strong>json_patch(json1, json2) -&gt; text</strong></p>
<p>Applies the RFC-7396 MergePatch algorithm. Object members in <code>json2</code> are merged into <code>json1</code>: new keys are added, existing keys are replaced, and keys with a <code>null</code> value are deleted. Arrays are treated as atomic values and replaced entirely.</p>
<pre><code class="language-sql">SELECT json_patch('{"a":1,"b":2}', '{"c":3,"d":4}');
-- {"a":1,"b":2,"c":3,"d":4}

SELECT json_patch('{"a":1,"b":2}', '{"b":3}');
-- {"a":1,"b":3}

SELECT json_patch('{"a":1,"b":2}', '{"a":null}');
-- {"b":2}

SELECT json_patch('{"user":{"name":"john"}}', '{"user":{"age":30}}');
-- {"user":{"name":"john","age":30}}

SELECT json_patch('{"arr":[1,2,3]}', '{"arr":[4,5,6]}');
-- {"arr":[4,5,6]}
</code></pre>
<p><code>jsonb_patch(...)</code> returns the same result in JSONB format.</p>
<hr>
<h2 id="aggregate-functions-1"><a class="header" href="#aggregate-functions-1">Aggregate Functions</a></h2>
<h3 id="json_group_array"><a class="header" href="#json_group_array">json_group_array</a></h3>
<p><strong>json_group_array(value) -&gt; text</strong></p>
<p>An aggregate function that collects all values from the group into a JSON array.</p>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL);
INSERT INTO products VALUES (1, 'hat', 9.99), (2, 'shirt', 24.99), (3, 'coat', 79.99);

SELECT json_group_array(name) FROM products;
-- ["hat","shirt","coat"]
</code></pre>
<p>Can be combined with other JSON functions to build complex aggregated structures:</p>
<pre><code class="language-sql">SELECT json_group_array(json_object('name', name, 'price', price)) FROM products;
-- [{"name":"hat","price":9.99},{"name":"shirt","price":24.99},{"name":"coat","price":79.99}]
</code></pre>
<p><code>jsonb_group_array(value)</code> returns the same result in JSONB format.</p>
<h3 id="json_group_object"><a class="header" href="#json_group_object">json_group_object</a></h3>
<p><strong>json_group_object(label, value) -&gt; text</strong></p>
<p>An aggregate function that collects label/value pairs from the group into a JSON object.</p>
<pre><code class="language-sql">SELECT json_group_object(name, price) FROM products;
-- {"hat":9.99,"shirt":24.99,"coat":79.99}
</code></pre>
<p><code>jsonb_group_object(label, value)</code> returns the same result in JSONB format.</p>
<hr>
<h2 id="table-valued-functions"><a class="header" href="#table-valued-functions">Table-Valued Functions</a></h2>
<h3 id="json_each"><a class="header" href="#json_each">json_each</a></h3>
<p><strong>json_each(json [, path])</strong></p>
<p>A table-valued function that returns one row for each immediate child of a JSON array or object. It does not recurse into nested structures. With an optional <code>path</code> argument, iteration starts at the element identified by that path.</p>
<p>The returned columns are:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Column</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>key</code></td><td>any</td><td>Array index (integer) or object key (text)</td></tr>
<tr><td><code>value</code></td><td>any</td><td>SQL value for primitives; JSON text for objects/arrays</td></tr>
<tr><td><code>type</code></td><td>text</td><td>One of: <code>object</code>, <code>array</code>, <code>integer</code>, <code>real</code>, <code>text</code>, <code>true</code>, <code>false</code>, <code>null</code></td></tr>
<tr><td><code>atom</code></td><td>any</td><td>SQL value for primitives; NULL for objects/arrays</td></tr>
<tr><td><code>id</code></td><td>integer</td><td>Unique identifier for this element</td></tr>
<tr><td><code>parent</code></td><td>integer</td><td>Always NULL (only populated by <code>json_tree</code>)</td></tr>
<tr><td><code>fullkey</code></td><td>text</td><td>Full JSON path to this element</td></tr>
<tr><td><code>path</code></td><td>text</td><td>JSON path to the containing element</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">SELECT key, value, type FROM json_each('[1, 2.5, "x", true, false, null]');
-- 0|1|integer
-- 1|2.5|real
-- 2|x|text
-- 3|1|true
-- 4|0|false
-- 5||null
</code></pre>
<pre><code class="language-sql">SELECT key, value, type FROM json_each('{"name":"Alice","age":30}');
-- name|Alice|text
-- age|30|integer
</code></pre>
<p>With a path argument:</p>
<pre><code class="language-sql">SELECT key, value FROM json_each('{"a":[10,20,30]}', '$.a');
-- 0|10
-- 1|20
-- 2|30
</code></pre>
<p>A common use case is joining <code>json_each</code> against a table column to search within JSON arrays:</p>
<pre><code class="language-sql">CREATE TABLE contacts (id INTEGER PRIMARY KEY, name TEXT, phones TEXT);
INSERT INTO contacts VALUES (1, 'Alice', '["555-0100","555-0101"]');
INSERT INTO contacts VALUES (2, 'Bob', '["555-0200"]');

SELECT DISTINCT contacts.name
FROM contacts, json_each(contacts.phones)
WHERE json_each.value LIKE '555-01%';
-- Alice
</code></pre>
<h3 id="json_tree"><a class="header" href="#json_tree">json_tree</a></h3>
<p><strong>json_tree(json [, path])</strong></p>
<p>A table-valued function that recursively walks the entire JSON structure, returning one row for every element at every level of nesting. It returns the same columns as <code>json_each</code>, but the <code>parent</code> column is populated with the <code>id</code> of each element’s parent.</p>
<pre><code class="language-sql">SELECT key, type, fullkey FROM json_tree('{"a":1,"b":{"c":2},"d":[3,4]}') ORDER BY id;
-- |object|$
-- a|integer|$.a
-- b|object|$.b
-- c|integer|$.b.c
-- d|array|$.d
-- 0|integer|$.d[0]
-- 1|integer|$.d[1]
</code></pre>
<h2 id="compatibility-17"><a class="header" href="#compatibility-17">Compatibility</a></h2>
<p>The <code>json_tree</code> function is partially supported. Basic recursive traversal works, but some edge cases involving negative array indices in the path argument have known limitations. See the SQLite documentation for full behavioral details.</p>
<p>All other JSON functions listed on this page are fully compatible with SQLite.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pragmas"><a class="header" href="#pragmas">PRAGMAs</a></h1>
<p>PRAGMAs are special SQL statements that configure the database engine or query internal state. Unlike regular SQL statements, PRAGMAs are specific to the database implementation and do not follow the SQL standard.</p>
<h2 id="syntax-25"><a class="header" href="#syntax-25">Syntax</a></h2>
<pre><code class="language-sql">PRAGMA pragma_name;
PRAGMA pragma_name = value;
PRAGMA pragma_name(value);
</code></pre>
<p>The first form queries the current value. The second and third forms set a new value. Not all PRAGMAs support both forms.</p>
<hr>
<h2 id="database-information"><a class="header" href="#database-information">Database Information</a></h2>
<h3 id="application_id"><a class="header" href="#application_id">application_id</a></h3>
<p><strong>PRAGMA application_id;</strong>
<strong>PRAGMA application_id = <em>integer</em>;</strong></p>
<p>Queries or sets the 32-bit signed integer “Application ID” stored at offset 68 in the database header. Applications that use Turso as a file format can set a unique application ID so that external tools can identify the file type. The default value is <code>0</code>.</p>
<pre><code class="language-sql">PRAGMA application_id;
-- 0

PRAGMA application_id = 12345;
PRAGMA application_id;
-- 12345
</code></pre>
<h3 id="database_list"><a class="header" href="#database_list">database_list</a></h3>
<p><strong>PRAGMA database_list;</strong></p>
<p>Returns one row per attached database, with columns <code>seq</code> (sequence number), <code>name</code> (database name), and <code>file</code> (file path). The main database always has sequence number <code>0</code> and the name <code>main</code>.</p>
<pre><code class="language-sql">PRAGMA database_list;
-- seq|name|file
-- 0|main|
</code></pre>
<h3 id="encoding"><a class="header" href="#encoding">encoding</a></h3>
<p><strong>PRAGMA encoding;</strong></p>
<p>Returns the text encoding used by the database. Turso uses UTF-8.</p>
<pre><code class="language-sql">PRAGMA encoding;
-- UTF-8
</code></pre>
<h3 id="freelist_count"><a class="header" href="#freelist_count">freelist_count</a></h3>
<p><strong>PRAGMA freelist_count;</strong></p>
<p>Returns the number of unused pages in the database file. A high freelist count may indicate the database would benefit from <code>VACUUM</code>.</p>
<pre><code class="language-sql">PRAGMA freelist_count;
-- 0
</code></pre>
<h3 id="page_count"><a class="header" href="#page_count">page_count</a></h3>
<p><strong>PRAGMA page_count;</strong></p>
<p>Returns the total number of pages in the database file. Multiply by the page size to get the approximate database size in bytes.</p>
<pre><code class="language-sql">PRAGMA page_count;
-- 0
</code></pre>
<h3 id="page_size"><a class="header" href="#page_size">page_size</a></h3>
<p><strong>PRAGMA page_size;</strong>
<strong>PRAGMA page_size = <em>bytes</em>;</strong></p>
<p>Queries or sets the database page size in bytes. The value must be a power of two between 512 and 65536. The default is <code>4096</code>.</p>
<p>Setting a new page size takes effect when the database is first created or after a <code>VACUUM</code> operation.</p>
<pre><code class="language-sql">PRAGMA page_size;
-- 4096
</code></pre>
<h3 id="schema_version"><a class="header" href="#schema_version">schema_version</a></h3>
<p><strong>PRAGMA schema_version;</strong></p>
<p>Returns the schema version number, an integer that Turso increments automatically whenever the database schema changes (via <code>CREATE TABLE</code>, <code>DROP TABLE</code>, etc.). The default for a new database is <code>0</code>.</p>
<p>Writing to <code>schema_version</code> is accepted syntactically but treated as a no-op for safety. Modifying the schema version externally can cause prepared statements to use stale schemas and corrupt data.</p>
<pre><code class="language-sql">PRAGMA schema_version;
-- 0
</code></pre>
<h3 id="user_version"><a class="header" href="#user_version">user_version</a></h3>
<p><strong>PRAGMA user_version;</strong>
<strong>PRAGMA user_version = <em>integer</em>;</strong></p>
<p>Queries or sets a user-defined 32-bit integer stored in the database header at offset 60. Turso does not use this value internally – it is available for applications to track their own schema migration version or any other purpose. The default is <code>0</code>.</p>
<pre><code class="language-sql">PRAGMA user_version;
-- 0

PRAGMA user_version = 100;
PRAGMA user_version;
-- 100
</code></pre>
<h3 id="pragma_list"><a class="header" href="#pragma_list">pragma_list</a></h3>
<p><strong>PRAGMA pragma_list;</strong></p>
<p>Returns a list of all PRAGMA names recognized by the current database connection.</p>
<pre><code class="language-sql">PRAGMA pragma_list;
-- application_id
-- busy_timeout
-- cache_size
-- ...
</code></pre>
<hr>
<h2 id="schema-information"><a class="header" href="#schema-information">Schema Information</a></h2>
<h3 id="table_info"><a class="header" href="#table_info">table_info</a></h3>
<p><strong>PRAGMA table_info(<em>table-name</em>);</strong></p>
<p>Returns one row per regular column in the named table. Each row contains:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Column</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cid</code></td><td>Column index (zero-based)</td></tr>
<tr><td><code>name</code></td><td>Column name</td></tr>
<tr><td><code>type</code></td><td>Declared type (empty string if none)</td></tr>
<tr><td><code>notnull</code></td><td><code>1</code> if the column has a NOT NULL constraint, <code>0</code> otherwise</td></tr>
<tr><td><code>dflt_value</code></td><td>Default value expression, or empty if none</td></tr>
<tr><td><code>pk</code></td><td><code>0</code> if the column is not part of the primary key; otherwise the 1-based index within the primary key</td></tr>
</tbody>
</table>
</div>
<p>Generated columns and hidden columns are omitted. Use <code>table_xinfo</code> for a complete listing.</p>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  price REAL DEFAULT 0.0,
  in_stock INTEGER DEFAULT 1
);

PRAGMA table_info(products);
-- cid|name|type|notnull|dflt_value|pk
-- 0|id|INTEGER|0||1
-- 1|name|TEXT|1||0
-- 2|price|REAL|0|0.0|0
-- 3|in_stock|INTEGER|0|1|0
</code></pre>
<h3 id="table_xinfo"><a class="header" href="#table_xinfo">table_xinfo</a></h3>
<p><strong>PRAGMA table_xinfo(<em>table-name</em>);</strong></p>
<p>Returns the same columns as <code>table_info</code> plus an additional <code>hidden</code> column. This PRAGMA includes all columns – regular, generated, and hidden.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>hidden</code> Value</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>0</code></td><td>Normal column</td></tr>
<tr><td><code>1</code></td><td>Hidden column in a virtual table</td></tr>
<tr><td><code>2</code></td><td>Virtual (dynamic) generated column</td></tr>
<tr><td><code>3</code></td><td>Stored generated column</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  price REAL DEFAULT 0.0,
  in_stock INTEGER DEFAULT 1
);

PRAGMA table_xinfo(products);
-- cid|name|type|notnull|dflt_value|pk|hidden
-- 0|id|INTEGER|0||1|0
-- 1|name|TEXT|1||0|0
-- 2|price|REAL|0|0.0|0|0
-- 3|in_stock|INTEGER|0|1|0|0
</code></pre>
<hr>
<h2 id="performance-and-caching"><a class="header" href="#performance-and-caching">Performance and Caching</a></h2>
<h3 id="busy_timeout"><a class="header" href="#busy_timeout">busy_timeout</a></h3>
<p><strong>PRAGMA busy_timeout;</strong>
<strong>PRAGMA busy_timeout = <em>milliseconds</em>;</strong></p>
<p>Queries or sets the busy timeout in milliseconds. When another connection holds a lock, Turso will retry for up to this many milliseconds before returning an error. The default is <code>0</code> (return immediately on lock contention).</p>
<pre><code class="language-sql">PRAGMA busy_timeout;
-- 0

PRAGMA busy_timeout = 5000;
PRAGMA busy_timeout;
-- 5000
</code></pre>
<h3 id="cache_size"><a class="header" href="#cache_size">cache_size</a></h3>
<p><strong>PRAGMA cache_size;</strong>
<strong>PRAGMA cache_size = <em>pages</em>;</strong></p>
<p>Queries or sets the suggested maximum number of database pages held in memory. A positive value specifies pages directly. A negative value specifies the cache size in kibibytes (KiB). The default is <code>-2000</code> (approximately 2 MB).</p>
<p>This setting applies only to the current session and reverts to the default when the connection closes.</p>
<pre><code class="language-sql">PRAGMA cache_size;
-- -2000

-- Set cache to 4000 pages
PRAGMA cache_size = 4000;
PRAGMA cache_size;
-- 4000

-- Set cache to approximately 4 MB
PRAGMA cache_size = -4000;
PRAGMA cache_size;
-- -4000
</code></pre>
<h3 id="cache_spill"><a class="header" href="#cache_spill">cache_spill</a></h3>
<p><strong>PRAGMA cache_spill;</strong>
<strong>PRAGMA cache_spill = <em>boolean</em>;</strong></p>
<p>Queries or sets whether the pager is allowed to spill dirty pages to the database file in the middle of a transaction. When enabled (the default, <code>1</code>), the pager may write dirty pages to disk before a transaction commits. When disabled (<code>0</code>), dirty pages are held in memory until commit.</p>
<p>Disabling cache spill avoids acquiring an exclusive lock on the database file until the transaction commits, which can be useful for long-running transactions.</p>
<pre><code class="language-sql">PRAGMA cache_spill;
-- 1

PRAGMA cache_spill = 0;
PRAGMA cache_spill;
-- 0
</code></pre>
<h3 id="max_page_count"><a class="header" href="#max_page_count">max_page_count</a></h3>
<p><strong>PRAGMA max_page_count;</strong>
<strong>PRAGMA max_page_count = <em>N</em>;</strong></p>
<p>Queries or sets the maximum number of pages allowed in the database file. Both the query and set forms return the current maximum. The maximum cannot be reduced below the current database size. The default is <code>4294967294</code>.</p>
<pre><code class="language-sql">PRAGMA max_page_count;
-- 4294967294

PRAGMA max_page_count = 1000;
PRAGMA max_page_count;
-- 1000
</code></pre>
<h3 id="query_only"><a class="header" href="#query_only">query_only</a></h3>
<p><strong>PRAGMA query_only;</strong>
<strong>PRAGMA query_only = <em>boolean</em>;</strong></p>
<p>When set to <code>1</code>, all write operations (<code>CREATE</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>DROP</code>) are rejected with an error. The default is <code>0</code> (writes allowed).</p>
<pre><code class="language-sql">PRAGMA query_only = 1;
CREATE TABLE test (id INTEGER);
-- Error: Cannot execute write statement in query_only mode

PRAGMA query_only = 0;
</code></pre>
<h3 id="temp_store"><a class="header" href="#temp_store">temp_store</a></h3>
<p><strong>PRAGMA temp_store;</strong>
<strong>PRAGMA temp_store = {0 | 1 | 2};</strong></p>
<p>Queries or sets the storage location for temporary tables and indices.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Name</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>0</code></td><td>DEFAULT</td><td>Use the compile-time default</td></tr>
<tr><td><code>1</code></td><td>FILE</td><td>Store temporary data in a file</td></tr>
<tr><td><code>2</code></td><td>MEMORY</td><td>Store temporary data in memory</td></tr>
</tbody>
</table>
</div>
<p>Changing this setting deletes all existing temporary tables, indices, triggers, and views. The default is <code>0</code>.</p>
<pre><code class="language-sql">PRAGMA temp_store;
-- 0

PRAGMA temp_store = 2;
PRAGMA temp_store;
-- 2
</code></pre>
<hr>
<h2 id="journaling-and-durability"><a class="header" href="#journaling-and-durability">Journaling and Durability</a></h2>
<h3 id="journal_mode"><a class="header" href="#journal_mode">journal_mode</a></h3>
<p><strong>PRAGMA journal_mode;</strong>
<strong>PRAGMA journal_mode = <em>mode</em>;</strong></p>
<p>Queries or sets the journal mode for the database. The journal mode controls how transactions are logged for crash recovery.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>wal</code></td><td>Write-ahead logging. Allows concurrent readers and a single writer. This is the default in Turso.</td></tr>
</tbody>
</table>
</div>
<p>Turso defaults to WAL mode. Setting the journal mode returns the active mode.</p>
<pre><code class="language-sql">PRAGMA journal_mode;
-- wal

PRAGMA journal_mode = 'wal';
-- wal
</code></pre>
<h3 id="synchronous"><a class="header" href="#synchronous">synchronous</a></h3>
<p><strong>PRAGMA synchronous;</strong>
<strong>PRAGMA synchronous = {0 | 2};</strong></p>
<p>Queries or sets the synchronous flag, which controls how aggressively Turso forces writes to disk. The value is returned as an integer.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Name</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>0</code></td><td>OFF</td><td>No synchronous writes. Fastest, but the database may corrupt if the operating system crashes or power is lost.</td></tr>
<tr><td><code>2</code></td><td>FULL</td><td>Synchronous writes at every critical moment. Safe against both application crashes and OS/power failures. This is the default.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">PRAGMA synchronous;
-- 2

PRAGMA synchronous = OFF;
PRAGMA synchronous;
-- 0

PRAGMA synchronous = FULL;
PRAGMA synchronous;
-- 2
</code></pre>
<h3 id="wal_checkpoint"><a class="header" href="#wal_checkpoint">wal_checkpoint</a></h3>
<p><strong>PRAGMA wal_checkpoint;</strong></p>
<p>Runs a checkpoint operation on the write-ahead log (WAL). A checkpoint transfers data from the WAL file back into the main database file. Returns three columns:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Column</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>busy</code></td><td><code>0</code> if the checkpoint completed, <code>1</code> if it was blocked by a concurrent reader or writer</td></tr>
<tr><td><code>log</code></td><td>Total number of frames in the WAL</td></tr>
<tr><td><code>checkpointed</code></td><td>Number of frames successfully checkpointed</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-sql">PRAGMA wal_checkpoint;
-- busy|log|checkpointed
-- 0|0|0
</code></pre>
<hr>
<h2 id="constraint-enforcement"><a class="header" href="#constraint-enforcement">Constraint Enforcement</a></h2>
<h3 id="foreign_keys"><a class="header" href="#foreign_keys">foreign_keys</a></h3>
<p><strong>PRAGMA foreign_keys;</strong>
<strong>PRAGMA foreign_keys = <em>boolean</em>;</strong></p>
<p>Queries or sets whether foreign key constraints are enforced. When enabled (<code>1</code>), INSERT, UPDATE, and DELETE operations that violate a foreign key constraint will fail with an error. The default is <code>0</code> (foreign keys not enforced).</p>
<p>This setting cannot be changed while a transaction is active.</p>
<pre><code class="language-sql">PRAGMA foreign_keys;
-- 0

PRAGMA foreign_keys = 1;

CREATE TABLE orders (id INTEGER PRIMARY KEY, total REAL);
CREATE TABLE items (
  id INTEGER PRIMARY KEY,
  order_id INTEGER REFERENCES orders(id)
);

-- This fails because order 999 does not exist
INSERT INTO items VALUES (1, 999);
-- Error: foreign key constraint failed
</code></pre>
<h3 id="ignore_check_constraints"><a class="header" href="#ignore_check_constraints">ignore_check_constraints</a></h3>
<p><strong>PRAGMA ignore_check_constraints;</strong>
<strong>PRAGMA ignore_check_constraints = <em>boolean</em>;</strong></p>
<p>Queries or sets whether CHECK constraints are enforced. When set to <code>1</code>, CHECK constraint violations are silently ignored during INSERT and UPDATE operations. The default is <code>0</code> (CHECK constraints enforced).</p>
<pre><code class="language-sql">CREATE TABLE orders (
  id INTEGER PRIMARY KEY,
  customer TEXT NOT NULL,
  total REAL CHECK(total &gt;= 0)
);

-- With CHECK constraints enforced (default)
INSERT INTO orders VALUES (1, 'Alice', -5.0);
-- Error: CHECK constraint failed: total &gt;= 0

-- Disable CHECK constraints
PRAGMA ignore_check_constraints = 1;
INSERT INTO orders VALUES (1, 'Alice', -5.0);
-- Succeeds despite negative total
</code></pre>
<hr>
<h2 id="integrity-checking"><a class="header" href="#integrity-checking">Integrity Checking</a></h2>
<h3 id="integrity_check"><a class="header" href="#integrity_check">integrity_check</a></h3>
<p><strong>PRAGMA integrity_check;</strong></p>
<p>Performs a thorough consistency check of the entire database. Examines every page, verifies B-tree structure, checks for missing or duplicate index entries, validates UNIQUE and NOT NULL constraints, and confirms freelist integrity. Returns <code>ok</code> if no problems are found, or one or more rows describing any issues detected.</p>
<pre><code class="language-sql">PRAGMA integrity_check;
-- ok
</code></pre>
<h3 id="quick_check"><a class="header" href="#quick_check">quick_check</a></h3>
<p><strong>PRAGMA quick_check;</strong></p>
<p>Performs a faster but less comprehensive consistency check than <code>integrity_check</code>. It verifies B-tree structure and record formatting but does not validate UNIQUE constraints or cross-check index content against table content. Returns <code>ok</code> if no problems are found.</p>
<pre><code class="language-sql">PRAGMA quick_check;
-- ok
</code></pre>
<hr>
<h2 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h2>
<h3 id="legacy_file_format"><a class="header" href="#legacy_file_format">legacy_file_format</a></h3>
<p><strong>PRAGMA legacy_file_format;</strong></p>
<p>This PRAGMA is a no-op. It exists for compatibility but does not return a value or perform any action.</p>
<hr>
<h2 id="compatibility-18"><a class="header" href="#compatibility-18">Compatibility</a></h2>
<p>Turso supports the PRAGMAs listed on this page. The following differences from SQLite are worth noting:</p>
<ul>
<li><strong>journal_mode</strong>: Turso defaults to <code>wal</code> mode. Other journal modes (<code>delete</code>, <code>truncate</code>, <code>persist</code>, <code>memory</code>, <code>off</code>) are not supported.</li>
<li><strong>synchronous</strong>: Only <code>OFF</code> (0) and <code>FULL</code> (2) are supported. <code>NORMAL</code> (1) and <code>EXTRA</code> (3) are not available.</li>
<li><strong>cache_spill</strong>: Only the boolean enable/disable form is supported. The numeric threshold form (<code>PRAGMA schema.cache_spill = N</code>) is not available.</li>
<li><strong>schema_version</strong>: Reads work normally. Writes are accepted but silently ignored to prevent accidental database corruption.</li>
<li><strong>wal_checkpoint</strong>: Only the no-argument form is supported. Checkpoint modes (<code>PASSIVE</code>, <code>FULL</code>, <code>RESTART</code>, <code>TRUNCATE</code>) are not available.</li>
<li><strong>legacy_file_format</strong>: Accepted for compatibility but is a no-op, matching modern SQLite behavior.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<blockquote>
<p><strong>Turso Extension.</strong> This feature is not available in SQLite. Custom types require STRICT tables for encode/decode behavior.</p>
</blockquote>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Turso supports user-defined custom types that extend the type system of STRICT tables. A custom type defines how values are transformed when written to and read from storage using ENCODE and DECODE expressions, allowing you to enforce domain constraints, normalize data, or change the storage representation without modifying application queries.</p>
<p>Custom types are built on top of one of the four base storage types (<code>TEXT</code>, <code>INTEGER</code>, <code>REAL</code>, <code>BLOB</code>). When a value is inserted into a column with a custom type, the ENCODE expression transforms it before writing. When the value is read back, the DECODE expression reverses the transformation. This is transparent to queries: SELECT statements return decoded values, and WHERE clauses operate on decoded values.</p>
<p>Type definitions are stored in the <code>sqlite_turso_types</code> system table and are loaded into an in-memory registry when the database is opened. Types persist across sessions.</p>
<h2 id="syntax-26"><a class="header" href="#syntax-26">Syntax</a></h2>
<h3 id="create-type"><a class="header" href="#create-type">CREATE TYPE</a></h3>
<pre><code class="language-sql">CREATE TYPE [IF NOT EXISTS] type_name [(param [, ...])]
    BASE {TEXT | INTEGER | REAL | BLOB}
    [ENCODE expr]
    [DECODE expr]
    [DEFAULT expr]
    [OPERATOR 'op' (right_type) -&gt; func_name]*;
</code></pre>
<h3 id="drop-type"><a class="header" href="#drop-type">DROP TYPE</a></h3>
<pre><code class="language-sql">DROP TYPE [IF EXISTS] type_name;
</code></pre>
<h2 id="description-23"><a class="header" href="#description-23">Description</a></h2>
<p><code>CREATE TYPE</code> registers a new custom type in the database. The type definition specifies:</p>
<ul>
<li><strong>BASE</strong>: The underlying storage type. All values for this type are stored on disk using this SQLite storage class. Must be one of <code>TEXT</code>, <code>INTEGER</code>, <code>REAL</code>, or <code>BLOB</code>.</li>
<li><strong>ENCODE</strong>: An expression applied to the input value before writing to storage. The keyword <code>value</code> is a placeholder that refers to the value being inserted. If omitted, values are stored as-is.</li>
<li><strong>DECODE</strong>: An expression applied to the stored value when reading from the table. The keyword <code>value</code> is a placeholder that refers to the raw stored value. If omitted, values are returned as-is.</li>
<li><strong>DEFAULT</strong>: A fallback default expression used when a column of this type has no column-level DEFAULT and no explicit value is provided in an INSERT.</li>
<li><strong>OPERATOR</strong>: Maps an operator symbol to a named function for use with values of this type.</li>
</ul>
<p><code>DROP TYPE</code> removes a custom type definition from the database. If the type does not exist and <code>IF EXISTS</code> is not specified, an error is raised.</p>
<h2 id="clauses-13"><a class="header" href="#clauses-13">Clauses</a></h2>
<h3 id="base"><a class="header" href="#base">BASE</a></h3>
<p>The <code>BASE</code> clause is required and specifies the underlying storage type.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Base Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>TEXT</code></td><td>Stored as a UTF-8 text string</td></tr>
<tr><td><code>INTEGER</code></td><td>Stored as a signed integer (up to 8 bytes)</td></tr>
<tr><td><code>REAL</code></td><td>Stored as an 8-byte IEEE 754 floating-point number</td></tr>
<tr><td><code>BLOB</code></td><td>Stored as raw binary data</td></tr>
</tbody>
</table>
</div>
<p>The base type determines how the encoded value is stored on disk and what type affinity rules apply during storage.</p>
<h3 id="encode"><a class="header" href="#encode">ENCODE</a></h3>
<p>The <code>ENCODE</code> clause defines an expression that transforms values on write. The special identifier <code>value</code> represents the input being inserted. The expression can be any valid SQL expression, including function calls, arithmetic, CASE expressions, and nested function calls.</p>
<p>If the ENCODE expression raises an error (for example, <code>json(value)</code> on invalid JSON), the INSERT statement fails. This makes ENCODE a natural place to add validation logic.</p>
<h3 id="decode"><a class="header" href="#decode">DECODE</a></h3>
<p>The <code>DECODE</code> clause defines an expression that transforms values on read. The special identifier <code>value</code> represents the raw stored value. The DECODE expression is applied whenever a column with the custom type is selected.</p>
<h3 id="default-1"><a class="header" href="#default-1">DEFAULT</a></h3>
<p>The <code>DEFAULT</code> clause specifies a fallback value for columns of this type when no value is provided during INSERT. If a column also has its own <code>DEFAULT</code> clause in the <code>CREATE TABLE</code> statement, the column-level default takes priority.</p>
<h3 id="operator"><a class="header" href="#operator">OPERATOR</a></h3>
<p>The <code>OPERATOR</code> clause maps an operator symbol to a named function. The syntax is:</p>
<pre><code class="language-sql">OPERATOR 'op' (right_type) -&gt; func_name
</code></pre>
<p>Where <code>op</code> is the operator symbol (such as <code>+</code>, <code>-</code>, <code>&lt;</code>, <code>=</code>), <code>right_type</code> is the type of the right-hand operand, and <code>func_name</code> is the function to call when this operator is used between values of the custom type.</p>
<h3 id="if-not-exists--if-exists"><a class="header" href="#if-not-exists--if-exists">IF NOT EXISTS / IF EXISTS</a></h3>
<p><code>CREATE TYPE IF NOT EXISTS</code> silently succeeds if a type with the same name already exists. <code>DROP TYPE IF EXISTS</code> silently succeeds if the type does not exist.</p>
<h2 id="parametric-types"><a class="header" href="#parametric-types">Parametric Types</a></h2>
<p>Custom types can accept parameters that are substituted into the ENCODE and DECODE expressions. Parameters are declared in parentheses after the type name and referenced by name in the expressions.</p>
<pre><code class="language-sql">CREATE TYPE type_name(param1, param2)
    BASE base_type
    ENCODE expr_using_param1_and_param2
    DECODE expr_using_param1_and_param2;
</code></pre>
<p>When the type is used in a <code>CREATE TABLE</code> statement, the actual parameter values are provided:</p>
<pre><code class="language-sql">CREATE TABLE t (col type_name(100, 2)) STRICT;
</code></pre>
<p>The parameter values are substituted into the ENCODE and DECODE expressions at compile time.</p>
<h2 id="using-custom-types-in-tables"><a class="header" href="#using-custom-types-in-tables">Using Custom Types in Tables</a></h2>
<p>Custom types are used as column type names in <code>CREATE TABLE ... STRICT</code> statements. The type name replaces a standard type like <code>TEXT</code> or <code>INTEGER</code>:</p>
<pre><code class="language-sql">CREATE TYPE cents BASE integer ENCODE value * 100 DECODE value / 100;
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    price cents
) STRICT;
</code></pre>
<p>Custom types require STRICT tables. On non-STRICT tables, the ENCODE transformation is not applied during insertion, which leads to incorrect values when DECODE runs on read.</p>
<h2 id="cast-with-custom-types"><a class="header" href="#cast-with-custom-types">CAST with Custom Types</a></h2>
<p>The <code>CAST</code> expression can target a custom type. When you write <code>CAST(expr AS type_name)</code>, the ENCODE and DECODE expressions are both applied (a round-trip), producing the normalized user-facing form of the value:</p>
<pre><code class="language-sql">CREATE TYPE normalized BASE text ENCODE lower(value) DECODE value;
SELECT CAST('Hello World' AS normalized);
-- Returns 'hello world'
</code></pre>
<p>For parametric types, the parameters must be provided:</p>
<pre><code class="language-sql">SELECT CAST(42 AS numeric(10,2));
-- Returns '42.00'
</code></pre>
<p>This is useful for normalizing values or validating that a value conforms to a custom type's constraints outside of an INSERT context.</p>
<h2 id="inspecting-custom-types"><a class="header" href="#inspecting-custom-types">Inspecting Custom Types</a></h2>
<p>Custom type definitions are stored in the <code>sqlite_turso_types</code> system table. You can query them directly:</p>
<pre><code class="language-sql">SELECT name, sql FROM sqlite_turso_types;
</code></pre>
<h2 id="null-handling-5"><a class="header" href="#null-handling-5">NULL Handling</a></h2>
<p>NULL values pass through ENCODE and DECODE unchanged. If you insert NULL into a column with a custom type, NULL is stored and NULL is returned on read, regardless of the ENCODE and DECODE expressions.</p>
<h2 id="examples-22"><a class="header" href="#examples-22">Examples</a></h2>
<h3 id="basic-custom-type"><a class="header" href="#basic-custom-type">Basic Custom Type</a></h3>
<pre><code class="language-sql">-- Define a type that stores monetary values as cents
CREATE TYPE cents BASE integer
    ENCODE value * 100
    DECODE value / 100;

-- Use it in a STRICT table
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    price cents
) STRICT;

INSERT INTO products VALUES (1, 'Coffee', 4);
INSERT INTO products VALUES (2, 'Tea', 2);
INSERT INTO products VALUES (3, 'Juice', 3);

-- Values are decoded on read
SELECT id, name, price FROM products;
-- 1|Coffee|4
-- 2|Tea|2
-- 3|Juice|3
</code></pre>
<h3 id="json-validation-type"><a class="header" href="#json-validation-type">JSON Validation Type</a></h3>
<pre><code class="language-sql">-- Define a type that validates JSON on insert
CREATE TYPE validated_json BASE text
    ENCODE json(value)
    DECODE value;

CREATE TABLE config (
    id INTEGER PRIMARY KEY,
    data validated_json
) STRICT;

-- Valid JSON is accepted and normalized
INSERT INTO config VALUES (1, '{"key": "val"}');
SELECT id, data FROM config;
-- 1|{"key":"val"}

-- Invalid JSON is rejected at insert time
INSERT INTO config VALUES (2, 'not valid json');
-- Error: malformed JSON
</code></pre>
<h3 id="text-normalization-type"><a class="header" href="#text-normalization-type">Text Normalization Type</a></h3>
<pre><code class="language-sql">-- Define a type that lowercases text on insert
CREATE TYPE normalized BASE text
    ENCODE lower(value)
    DECODE value;

CREATE TABLE tags (label normalized) STRICT;

INSERT INTO tags VALUES ('JavaScript');
INSERT INTO tags VALUES ('PYTHON');
INSERT INTO tags VALUES ('Rust');

SELECT label FROM tags ORDER BY label;
-- javascript
-- python
-- rust
</code></pre>
<h3 id="type-level-default"><a class="header" href="#type-level-default">Type-Level DEFAULT</a></h3>
<pre><code class="language-sql">-- Define a type with a default value
CREATE TYPE cents BASE integer
    ENCODE value * 100
    DECODE value / 100
    DEFAULT 0;

CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    price cents
) STRICT;

-- Omitting price uses the type-level default of 0
INSERT INTO products(id) VALUES (1);
INSERT INTO products VALUES (2, 5);

SELECT id, price FROM products;
-- 1|0
-- 2|5
</code></pre>
<h3 id="column-default-overrides-type-default"><a class="header" href="#column-default-overrides-type-default">Column DEFAULT Overrides Type DEFAULT</a></h3>
<pre><code class="language-sql">CREATE TYPE cents BASE integer
    ENCODE value * 100
    DECODE value / 100
    DEFAULT 0;

-- Column-level DEFAULT takes priority over type-level DEFAULT
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    price cents DEFAULT 10
) STRICT;

INSERT INTO products(id) VALUES (1);
SELECT id, price FROM products;
-- 1|10
</code></pre>
<h3 id="parametric-type"><a class="header" href="#parametric-type">Parametric Type</a></h3>
<pre><code class="language-sql">-- Define a clamping type with configurable bounds
CREATE TYPE clamp(lo, hi) BASE integer
    ENCODE CASE
        WHEN value &lt; lo THEN lo
        WHEN value &gt; hi THEN hi
        ELSE value
    END
    DECODE value;

CREATE TABLE readings (
    id INTEGER PRIMARY KEY,
    temperature clamp(0, 100)
) STRICT;

INSERT INTO readings VALUES (1, 50);
INSERT INTO readings VALUES (2, 150);
INSERT INTO readings VALUES (3, -20);

SELECT id, temperature FROM readings;
-- 1|50
-- 2|100
-- 3|0
</code></pre>
<h3 id="multiple-custom-types-in-one-table"><a class="header" href="#multiple-custom-types-in-one-table">Multiple Custom Types in One Table</a></h3>
<pre><code class="language-sql">CREATE TYPE cents BASE integer
    ENCODE value * 100
    DECODE value / 100;

CREATE TYPE normalized BASE text
    ENCODE lower(value)
    DECODE value;

CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name normalized,
    price cents
) STRICT;

INSERT INTO products VALUES (1, 'Coffee', 4);
INSERT INTO products VALUES (2, 'TEA', 2);

SELECT id, name, price FROM products;
-- 1|coffee|4
-- 2|tea|2
</code></pre>
<h3 id="null-passes-through"><a class="header" href="#null-passes-through">NULL Passes Through</a></h3>
<pre><code class="language-sql">CREATE TYPE cents BASE integer
    ENCODE value * 100
    DECODE value / 100;

CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    price cents
) STRICT;

INSERT INTO products VALUES (1, NULL);
SELECT id, COALESCE(price, 'IS_NULL') FROM products;
-- 1|IS_NULL
</code></pre>
<h3 id="create-type-if-not-exists"><a class="header" href="#create-type-if-not-exists">CREATE TYPE IF NOT EXISTS</a></h3>
<pre><code class="language-sql">CREATE TYPE cents BASE integer
    ENCODE value * 100
    DECODE value / 100;

-- Does not raise an error if the type already exists
CREATE TYPE IF NOT EXISTS cents BASE integer
    ENCODE value * 100
    DECODE value / 100;

SELECT count(*) FROM sqlite_turso_types WHERE name = 'cents';
-- 1
</code></pre>
<h3 id="drop-type-1"><a class="header" href="#drop-type-1">DROP TYPE</a></h3>
<pre><code class="language-sql">CREATE TYPE cents BASE integer
    ENCODE value * 100
    DECODE value / 100;

DROP TYPE cents;

SELECT count(*) FROM sqlite_turso_types WHERE name = 'cents';
-- 0

-- DROP TYPE IF EXISTS does not raise an error for missing types
DROP TYPE IF EXISTS nonexistent;
</code></pre>
<h3 id="inspecting-types-via-sqlite_turso_types"><a class="header" href="#inspecting-types-via-sqlite_turso_types">Inspecting Types via sqlite_turso_types</a></h3>
<pre><code class="language-sql">CREATE TYPE cents BASE integer
    ENCODE value * 100
    DECODE value / 100
    DEFAULT 0;

SELECT name, sql FROM sqlite_turso_types WHERE name = 'cents';
-- cents|CREATE TYPE cents BASE integer ENCODE value * 100 DECODE value / 100 DEFAULT 0
</code></pre>
<h2 id="compatibility-19"><a class="header" href="#compatibility-19">Compatibility</a></h2>
<ul>
<li>Custom types are a Turso extension and are not available in SQLite.</li>
<li>Custom types require STRICT tables for correct encode/decode behavior. On non-STRICT tables, custom type names are treated as standard type affinity hints and encode/decode expressions are not applied.</li>
<li>Type definitions are stored in the <code>sqlite_turso_types</code> system table. SQLite-based tools that open a Turso database may not understand this table.</li>
<li>The OPERATOR clause maps operators to named functions. These functions must be available in the Turso function registry (either built-in or loaded via extensions).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vector-search"><a class="header" href="#vector-search">Vector Search</a></h1>
<blockquote>
<p><strong>Turso extension.</strong> Vector search is a Turso-specific feature and is not available in standard SQLite.</p>
</blockquote>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Turso supports vector operations for building similarity search and semantic search applications. Vectors are fixed-length arrays of floating-point numbers that represent data points in a high-dimensional space. They are commonly produced by machine learning embedding models that convert text, images, or other data into numerical representations where similar items have nearby vectors.</p>
<p>Vectors are stored as compact binary BLOBs and can be compared using built-in distance functions to find the most similar items.</p>
<p>A typical workflow is:</p>
<ol>
<li>Create a table with a BLOB column (or the <code>F32_BLOB</code>/<code>F64_BLOB</code> type hint) to hold embeddings.</li>
<li>Generate embeddings externally using a model (such as OpenAI, Cohere, or a local model) and insert them using the <code>vector32()</code> or <code>vector64()</code> creation functions. These functions convert a JSON text array into a compact binary representation.</li>
<li>At query time, convert the search query into an embedding using the same model, then use a distance function (<code>vector_distance_cos</code>, <code>vector_distance_l2</code>, etc.) with <code>ORDER BY</code> and <code>LIMIT</code> to find the nearest neighbors.</li>
</ol>
<p>Vector indexes are not yet supported. All vector searches currently use brute-force scanning, which means search time scales linearly with the number of rows. For small to medium datasets (up to hundreds of thousands of rows), brute-force search is often fast enough. For larger datasets, consider partitioning or pre-filtering with WHERE clauses on non-vector columns.</p>
<h2 id="vector-types"><a class="header" href="#vector-types">Vector Types</a></h2>
<p>Turso supports three vector formats:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Function</th><th>Bytes per dimension</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Float32 dense</td><td><code>vector32()</code> or <code>vector()</code></td><td>4</td><td>32-bit floating-point. Default format, good balance of precision and size.</td></tr>
<tr><td>Float64 dense</td><td><code>vector64()</code></td><td>8</td><td>64-bit floating-point. Higher precision, double the storage.</td></tr>
<tr><td>Float32 sparse</td><td><code>vector32_sparse()</code></td><td>4 (non-zero only)</td><td>32-bit floating-point sparse representation. Only stores non-zero dimensions.</td></tr>
</tbody>
</table>
</div>
<p>The <code>vector()</code> function is an alias for <code>vector32()</code>.</p>
<h2 id="column-types"><a class="header" href="#column-types">Column Types</a></h2>
<p>Vectors are stored on disk as BLOBs. You can use a plain <code>BLOB</code> column or the optional type hints <code>F32_BLOB(n)</code> and <code>F64_BLOB(n)</code>, where <code>n</code> is the number of dimensions. The type hint is purely documentary and does not enforce a dimension constraint at the storage layer.</p>
<pre><code class="language-sql">CREATE TABLE documents (
    id INTEGER PRIMARY KEY,
    content TEXT,
    embedding F32_BLOB(4)
);
</code></pre>
<h2 id="vector-creation-functions"><a class="header" href="#vector-creation-functions">Vector Creation Functions</a></h2>
<h3 id="vectortext-vector32text"><a class="header" href="#vectortext-vector32text">vector(text), vector32(text)</a></h3>
<p><strong>vector(text) -&gt; blob</strong>
<strong>vector32(text) -&gt; blob</strong></p>
<p>Parse a JSON array of numbers into a 32-bit floating-point vector BLOB. The input must be a single-quoted string containing a JSON array of numeric values (integers or floats). <code>vector()</code> is an alias for <code>vector32()</code>. Each number in the array becomes one dimension of the vector. The values must be finite (no NaN or infinity).</p>
<pre><code class="language-sql">SELECT vector_extract(vector32('[1.0, 2.0, 3.0]'));  -- [1,2,3]
</code></pre>
<pre><code class="language-sql">SELECT vector_extract(vector('[4.5, 5.5, 6.5]'));  -- [4.5,5.5,6.5]
</code></pre>
<h3 id="vector64text"><a class="header" href="#vector64text">vector64(text)</a></h3>
<p><strong>vector64(text) -&gt; blob</strong></p>
<p>Parse a JSON array of numbers into a 64-bit floating-point vector BLOB. Use this when you need higher numerical precision than 32-bit floats provide. The trade-off is double the storage per dimension (8 bytes instead of 4 bytes).</p>
<pre><code class="language-sql">SELECT vector_extract(vector64('[1.0, 2.0, 3.0]'));  -- [1,2,3]
</code></pre>
<h3 id="vector32_sparsetext"><a class="header" href="#vector32_sparsetext">vector32_sparse(text)</a></h3>
<p><strong>vector32_sparse(text) -&gt; blob</strong></p>
<p>Parse a JSON array into a sparse 32-bit floating-point vector. Zero-valued dimensions are omitted from the binary representation, reducing storage for vectors with many zeros. This is particularly useful for bag-of-words models, TF-IDF representations, or any embedding scheme where most dimensions are zero. The full dimensionality of the vector is preserved – <code>vector_extract</code> will reconstruct the zeros – but only non-zero values are stored on disk.</p>
<pre><code class="language-sql">SELECT vector_extract(vector32_sparse('[1.0, 0.0, 3.0]'));  -- [1,0,3]
</code></pre>
<h2 id="distance-functions"><a class="header" href="#distance-functions">Distance Functions</a></h2>
<p>All distance functions take two vector BLOBs and return a floating-point number. Both vectors must have the same number of dimensions. Passing vectors with different dimension counts will result in an error.</p>
<p>When using distance functions for nearest-neighbor search, sort results in ascending order (<code>ORDER BY distance ASC</code> or simply <code>ORDER BY distance</code>) so that the most similar items appear first. All distance functions in Turso follow this convention: smaller values mean more similar vectors.</p>
<h3 id="vector_distance_cosv1-v2"><a class="header" href="#vector_distance_cosv1-v2">vector_distance_cos(v1, v2)</a></h3>
<p><strong>vector_distance_cos(v1, v2) -&gt; real</strong></p>
<p>Compute the cosine distance between two vectors, defined as <code>1 - cosine_similarity</code>. The result ranges from 0 (identical direction) to 2 (opposite direction). A value of 1 means the vectors are orthogonal.</p>
<p>Cosine distance is typically preferred for text and document embeddings because it measures the angle between vectors rather than their magnitude.</p>
<pre><code class="language-sql">-- Identical vectors: distance near 0
SELECT vector_distance_cos(
    vector32('[1.0, 0.0]'),
    vector32('[1.0, 0.0]')
);  -- ~0.0

-- Orthogonal vectors: distance = 1
SELECT vector_distance_cos(
    vector32('[1.0, 0.0, 0.0]'),
    vector32('[0.0, 0.0, 1.0]')
);  -- 1.0

-- Opposite vectors: distance near 2
SELECT vector_distance_cos(
    vector32('[1.0, 0.0]'),
    vector32('[-1.0, 0.0]')
);  -- ~2.0
</code></pre>
<h3 id="vector_distance_l2v1-v2"><a class="header" href="#vector_distance_l2v1-v2">vector_distance_l2(v1, v2)</a></h3>
<p><strong>vector_distance_l2(v1, v2) -&gt; real</strong></p>
<p>Compute the Euclidean (L2) distance between two vectors. This is the straight-line distance between two points in the vector space. The result is always non-negative, with 0 meaning the vectors are identical. L2 distance is sensitive to vector magnitude, so it works best when vectors are on a similar scale.</p>
<pre><code class="language-sql">SELECT vector_distance_l2(
    vector32('[0.0, 0.0]'),
    vector32('[3.0, 4.0]')
);  -- 5.0

SELECT vector_distance_l2(
    vector32('[1.0, 2.0, 3.0]'),
    vector32('[4.0, 5.0, 6.0]')
);  -- 5.19615242270663
</code></pre>
<h3 id="vector_distance_dotv1-v2"><a class="header" href="#vector_distance_dotv1-v2">vector_distance_dot(v1, v2)</a></h3>
<p><strong>vector_distance_dot(v1, v2) -&gt; real</strong></p>
<p>Compute the negative dot product between two vectors. A more negative result means the vectors are more similar (larger dot product). The result is negated so that sorting in ascending order returns the most similar vectors first.</p>
<pre><code class="language-sql">SELECT vector_distance_dot(
    vector32('[1.0, 2.0]'),
    vector32('[3.0, 4.0]')
);  -- -11.0

SELECT vector_distance_dot(
    vector32('[1.0, 0.0]'),
    vector32('[0.0, 1.0]')
);  -- 0.0
</code></pre>
<h3 id="vector_distance_jaccardv1-v2"><a class="header" href="#vector_distance_jaccardv1-v2">vector_distance_jaccard(v1, v2)</a></h3>
<p><strong>vector_distance_jaccard(v1, v2) -&gt; real</strong></p>
<p>Compute the Jaccard distance between two vectors treated as sets. The Jaccard distance is defined as <code>1 - (intersection / union)</code> where non-zero elements are treated as set members. This is useful when vector dimensions represent binary or categorical features, such as presence/absence of tags or keywords.</p>
<pre><code class="language-sql">SELECT vector_distance_jaccard(
    vector32('[1.0, 0.0, 1.0]'),
    vector32('[0.0, 1.0, 1.0]')
);  -- 0.666666656732559
</code></pre>
<h2 id="utility-functions"><a class="header" href="#utility-functions">Utility Functions</a></h2>
<h3 id="vector_extractblob"><a class="header" href="#vector_extractblob">vector_extract(blob)</a></h3>
<p><strong>vector_extract(blob) -&gt; text</strong></p>
<p>Convert a vector BLOB back into a human-readable JSON array. Useful for inspecting stored vectors.</p>
<pre><code class="language-sql">SELECT vector_extract(vector32('[1.0, 2.0, 3.0]'));  -- [1,2,3]
</code></pre>
<h3 id="vector_concatv1-v2"><a class="header" href="#vector_concatv1-v2">vector_concat(v1, v2)</a></h3>
<p><strong>vector_concat(v1, v2) -&gt; blob</strong></p>
<p>Concatenate two vectors into a single vector. Both vectors must be the same type.</p>
<pre><code class="language-sql">SELECT vector_extract(
    vector_concat(
        vector32('[1.0, 2.0]'),
        vector32('[3.0, 4.0]')
    )
);  -- [1,2,3,4]
</code></pre>
<h3 id="vector_slicev-start-end"><a class="header" href="#vector_slicev-start-end">vector_slice(v, start, end)</a></h3>
<p><strong>vector_slice(v, start, end) -&gt; blob</strong></p>
<p>Extract a contiguous sub-vector from dimension index <code>start</code> (inclusive) to <code>end</code> (exclusive). Indices are zero-based.</p>
<pre><code class="language-sql">SELECT vector_extract(
    vector_slice(vector32('[10.0, 20.0, 30.0, 40.0, 50.0]'), 0, 3)
);  -- [10,20,30]

SELECT vector_extract(
    vector_slice(vector32('[10.0, 20.0, 30.0, 40.0, 50.0]'), 2, 5)
);  -- [30,40,50]
</code></pre>
<h2 id="examples-23"><a class="header" href="#examples-23">Examples</a></h2>
<h3 id="creating-a-table-and-inserting-vectors"><a class="header" href="#creating-a-table-and-inserting-vectors">Creating a Table and Inserting Vectors</a></h3>
<pre><code class="language-sql">CREATE TABLE documents (
    id INTEGER PRIMARY KEY,
    content TEXT,
    embedding BLOB
);

INSERT INTO documents VALUES
    (1, 'Introduction to databases', vector32('[0.1, 0.2, 0.3, 0.4]'));
INSERT INTO documents VALUES
    (2, 'SQL query optimization', vector32('[0.2, 0.1, 0.4, 0.3]'));
INSERT INTO documents VALUES
    (3, 'Vector similarity search', vector32('[0.4, 0.3, 0.2, 0.1]'));
</code></pre>
<h3 id="finding-similar-documents-with-cosine-distance"><a class="header" href="#finding-similar-documents-with-cosine-distance">Finding Similar Documents with Cosine Distance</a></h3>
<pre><code class="language-sql">SELECT
    id,
    content,
    vector_distance_cos(embedding, vector32('[0.15, 0.25, 0.35, 0.45]')) AS distance
FROM documents
ORDER BY distance
LIMIT 3;
-- 1|Introduction to databases|0.00203462258422431
-- 2|SQL query optimization|0.0590611621657705
-- 3|Vector similarity search|0.287167575420696
</code></pre>
<h3 id="finding-similar-documents-with-l2-distance"><a class="header" href="#finding-similar-documents-with-l2-distance">Finding Similar Documents with L2 Distance</a></h3>
<pre><code class="language-sql">SELECT
    id,
    content,
    vector_distance_l2(embedding, vector32('[0.15, 0.25, 0.35, 0.45]')) AS distance
FROM documents
ORDER BY distance
LIMIT 3;
-- 1|Introduction to databases|0.0999999802559595
-- 2|SQL query optimization|0.223606791085977
-- 3|Vector similarity search|0.458257562341844
</code></pre>
<h3 id="threshold-based-search"><a class="header" href="#threshold-based-search">Threshold-Based Search</a></h3>
<p>Find all vectors within a certain distance rather than a fixed number of results:</p>
<pre><code class="language-sql">SELECT
    id,
    content,
    vector_distance_cos(embedding, vector32('[0.1, 0.2, 0.3, 0.4]')) AS distance
FROM documents
WHERE vector_distance_cos(embedding, vector32('[0.1, 0.2, 0.3, 0.4]')) &lt; 0.01
ORDER BY distance;
</code></pre>
<h3 id="inspecting-stored-vectors"><a class="header" href="#inspecting-stored-vectors">Inspecting Stored Vectors</a></h3>
<pre><code class="language-sql">SELECT id, vector_extract(embedding) FROM documents;
-- 1|[0.1,0.2,0.3,0.4]
-- 2|[0.2,0.1,0.4,0.3]
-- 3|[0.4,0.3,0.2,0.1]
</code></pre>
<h3 id="combining-vector-search-with-relational-filters"><a class="header" href="#combining-vector-search-with-relational-filters">Combining Vector Search with Relational Filters</a></h3>
<p>Vector search can be combined with standard SQL WHERE clauses. Non-vector predicates are applied before or alongside the distance calculation, reducing the number of vectors that need to be compared:</p>
<pre><code class="language-sql">-- Assuming a 'category' column exists alongside the embedding
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    category TEXT,
    embedding BLOB
);

INSERT INTO products VALUES (1, 'Running Shoes', 'footwear', vector32('[0.8, 0.1, 0.3]'));
INSERT INTO products VALUES (2, 'Hiking Boots', 'footwear', vector32('[0.7, 0.2, 0.5]'));
INSERT INTO products VALUES (3, 'Cotton T-Shirt', 'clothing', vector32('[0.1, 0.9, 0.2]'));
INSERT INTO products VALUES (4, 'Trail Sneakers', 'footwear', vector32('[0.75, 0.15, 0.4]'));

-- Search only within the 'footwear' category
SELECT
    name,
    vector_distance_cos(embedding, vector32('[0.8, 0.1, 0.35]')) AS distance
FROM products
WHERE category = 'footwear'
ORDER BY distance
LIMIT 2;
</code></pre>
<h3 id="semantic-search-application"><a class="header" href="#semantic-search-application">Semantic Search Application</a></h3>
<p>A complete example modeling an article recommendation system:</p>
<pre><code class="language-sql">-- Create schema
CREATE TABLE articles (
    id INTEGER PRIMARY KEY,
    title TEXT,
    embedding BLOB
);

-- Insert pre-computed embeddings from an external model
INSERT INTO articles VALUES
    (1, 'Database Fundamentals', vector32('[0.12, -0.34, 0.56, 0.78]'));
INSERT INTO articles VALUES
    (2, 'Machine Learning Basics', vector32('[0.23, 0.45, -0.67, 0.89]'));
INSERT INTO articles VALUES
    (3, 'Web Development Guide', vector32('[0.34, -0.12, 0.78, -0.56]'));
INSERT INTO articles VALUES
    (4, 'Data Structures', vector32('[0.11, -0.33, 0.55, 0.77]'));

-- Search: given a query embedding, find the 3 most similar articles
SELECT
    a.id,
    a.title,
    vector_distance_cos(a.embedding, vector32('[0.10, -0.30, 0.50, 0.70]')) AS distance
FROM articles a
ORDER BY distance
LIMIT 3;
-- 4|Data Structures|0.0
-- 1|Database Fundamentals|4.52537882702912e-05
-- 2|Machine Learning Basics|0.843018284332676
</code></pre>
<h2 id="choosing-a-distance-function"><a class="header" href="#choosing-a-distance-function">Choosing a Distance Function</a></h2>
<p>Different distance functions suit different use cases:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Best for</th><th>Range</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td><code>vector_distance_cos</code></td><td>Text/document embeddings</td><td>0 to 2</td><td>Ignores vector magnitude; focuses on direction. Most common for NLP embeddings.</td></tr>
<tr><td><code>vector_distance_l2</code></td><td>Spatial data, image features</td><td>0 to infinity</td><td>Sensitive to magnitude. Good when absolute position matters.</td></tr>
<tr><td><code>vector_distance_dot</code></td><td>Normalized embeddings, ranking</td><td>negative infinity to positive infinity</td><td>Returns negated dot product so ascending sort gives best matches.</td></tr>
<tr><td><code>vector_distance_jaccard</code></td><td>Binary/categorical features</td><td>0 to 1</td><td>Treats vectors as sets. Best for presence/absence features.</td></tr>
</tbody>
</table>
</div>
<p>When in doubt, start with <code>vector_distance_cos</code>. It is the most widely used metric for text embeddings produced by models like OpenAI, Cohere, and Sentence Transformers.</p>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>Since vector indexes are not yet implemented, keep the following in mind:</p>
<ul>
<li><strong>Linear scan</strong>: every search examines all rows in the table. For large datasets, queries will be slower.</li>
<li><strong>Use <code>vector32</code> over <code>vector64</code></strong> unless double precision is required. It uses half the storage (4 bytes vs. 8 bytes per dimension).</li>
<li><strong>Pre-filter with WHERE</strong>: apply non-vector predicates first to reduce the number of distance calculations. For example, filtering by a category column before computing distances avoids unnecessary work.</li>
<li><strong>Use <code>vector32_sparse</code></strong> when vectors have many zero-valued dimensions to reduce storage.</li>
<li><strong>Dimension count matters</strong>: storage per row is <code>dimensions * bytes_per_dimension</code>. A 1536-dimensional <code>vector32</code> column uses about 6 KB per row, while a 384-dimensional column uses about 1.5 KB per row. Choose the smallest embedding model that meets your accuracy requirements.</li>
</ul>
<h2 id="compatibility-20"><a class="header" href="#compatibility-20">Compatibility</a></h2>
<p>Vector search is a Turso extension and is not available in standard SQLite. The <code>vector()</code>, <code>vector32()</code>, <code>vector64()</code>, <code>vector32_sparse()</code>, <code>vector_extract()</code>, <code>vector_distance_cos()</code>, <code>vector_distance_l2()</code>, <code>vector_distance_dot()</code>, <code>vector_distance_jaccard()</code>, <code>vector_concat()</code>, and <code>vector_slice()</code> functions are all Turso-specific.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="change-data-capture"><a class="header" href="#change-data-capture">Change Data Capture</a></h1>
<blockquote>
<p><strong>Turso extension.</strong> Change Data Capture (CDC) is a Turso-specific feature and is not available in standard SQLite.</p>
</blockquote>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Change Data Capture (CDC) records every data modification (insert, update, delete) into a dedicated tracking table. This is useful for building reactive applications, replicating data between systems, maintaining audit logs, and implementing event-driven architectures.</p>
<p>CDC is enabled per connection using a PRAGMA. Once enabled, every INSERT, UPDATE, and DELETE on user tables automatically generates a corresponding row in the CDC table. The level of detail captured depends on the chosen mode.</p>
<p><strong>Note:</strong> This feature is currently marked as unstable, meaning the PRAGMA name may change in future versions. The functionality itself is reliable for use.</p>
<h2 id="syntax-27"><a class="header" href="#syntax-27">Syntax</a></h2>
<pre><code class="language-sql">PRAGMA unstable_capture_data_changes_conn('mode[,table_name]');
</code></pre>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<ul>
<li><strong>mode</strong> – the capture mode (see Capture Modes below).</li>
<li><strong>table_name</strong> – an optional custom name for the CDC table, separated from the mode by a comma. Defaults to <code>turso_cdc</code> when omitted.</li>
</ul>
<h2 id="capture-modes"><a class="header" href="#capture-modes">Capture Modes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>off</code></td><td>Disable CDC for this connection. No further changes are recorded.</td></tr>
<tr><td><code>id</code></td><td>Record only the primary key (or rowid) of every changed row. The <code>before</code>, <code>after</code>, and <code>updates</code> columns are NULL.</td></tr>
<tr><td><code>before</code></td><td>Record the full row state <strong>before</strong> each change. Populated for updates and deletes. Inserts still record only the id.</td></tr>
<tr><td><code>after</code></td><td>Record the full row state <strong>after</strong> each change. Populated for inserts and updates. Deletes still record only the id.</td></tr>
<tr><td><code>full</code></td><td>Record <strong>before</strong> state, <strong>after</strong> state, and an <strong>updates</strong> blob describing which columns changed. The most detailed mode.</td></tr>
</tbody>
</table>
</div>
<h2 id="cdc-table-structure"><a class="header" href="#cdc-table-structure">CDC Table Structure</a></h2>
<p>When CDC is first enabled and a DML statement is executed, Turso automatically creates the tracking table (default name <code>turso_cdc</code>) if it does not already exist. The table has the following schema:</p>
<pre><code>(change_id INTEGER PRIMARY KEY AUTOINCREMENT,
 change_time INTEGER,
 change_type INTEGER,
 table_name TEXT,
 id,
 before BLOB,
 after BLOB,
 updates BLOB)
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Column</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>change_id</code></td><td>INTEGER</td><td>Auto-incrementing unique identifier for each change entry.</td></tr>
<tr><td><code>change_time</code></td><td>INTEGER</td><td>Unix epoch timestamp when the change was recorded.</td></tr>
<tr><td><code>change_type</code></td><td>INTEGER</td><td><code>1</code> for INSERT, <code>0</code> for UPDATE, <code>-1</code> for DELETE.</td></tr>
<tr><td><code>table_name</code></td><td>TEXT</td><td>Name of the table that was modified. Schema changes appear as changes to <code>sqlite_schema</code>.</td></tr>
<tr><td><code>id</code></td><td>(any)</td><td>The primary key or rowid of the affected row.</td></tr>
<tr><td><code>before</code></td><td>BLOB</td><td>A binary record containing the row state before the change. Populated only in <code>before</code> and <code>full</code> modes, and only for updates and deletes. NULL otherwise.</td></tr>
<tr><td><code>after</code></td><td>BLOB</td><td>A binary record containing the row state after the change. Populated only in <code>after</code> and <code>full</code> modes, and only for inserts and updates. NULL otherwise.</td></tr>
<tr><td><code>updates</code></td><td>BLOB</td><td>A binary record describing per-column update details. Populated only in <code>full</code> mode for updates. NULL otherwise.</td></tr>
</tbody>
</table>
</div>
<h3 id="change-type-values"><a class="header" href="#change-type-values">Change Type Values</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>1</code></td><td>INSERT</td></tr>
<tr><td><code>0</code></td><td>UPDATE</td></tr>
<tr><td><code>-1</code></td><td>DELETE</td></tr>
</tbody>
</table>
</div>
<h2 id="enabling-cdc"><a class="header" href="#enabling-cdc">Enabling CDC</a></h2>
<p>Enable CDC with the desired mode:</p>
<pre><code class="language-sql">-- Capture only primary keys of changed rows
PRAGMA unstable_capture_data_changes_conn('id');
</code></pre>
<pre><code class="language-sql">-- Capture full before and after state
PRAGMA unstable_capture_data_changes_conn('full');
</code></pre>
<pre><code class="language-sql">-- Store changes in a custom table instead of the default turso_cdc
PRAGMA unstable_capture_data_changes_conn('full,audit_log');
</code></pre>
<h2 id="disabling-cdc"><a class="header" href="#disabling-cdc">Disabling CDC</a></h2>
<p>Turn off CDC for the current connection. Changes made after this point are not recorded.</p>
<pre><code class="language-sql">PRAGMA unstable_capture_data_changes_conn('off');
</code></pre>
<h2 id="querying-changes"><a class="header" href="#querying-changes">Querying Changes</a></h2>
<p>The CDC table is a regular table that can be queried with standard SQL.</p>
<pre><code class="language-sql">-- View all captured changes
SELECT * FROM turso_cdc;

-- View only inserts
SELECT * FROM turso_cdc WHERE change_type = 1;

-- View only updates
SELECT * FROM turso_cdc WHERE change_type = 0;

-- View only deletes
SELECT * FROM turso_cdc WHERE change_type = -1;

-- View changes for a specific table
SELECT * FROM turso_cdc WHERE table_name = 'users';

-- View recent changes (last hour)
SELECT * FROM turso_cdc
WHERE change_time &gt; unixepoch() - 3600;
</code></pre>
<p>You can also delete old entries to keep the table from growing indefinitely. Modifications to the CDC table itself are not captured, so deleting rows from <code>turso_cdc</code> does not generate additional CDC entries.</p>
<pre><code class="language-sql">-- Purge entries older than 24 hours
DELETE FROM turso_cdc
WHERE change_time &lt; unixepoch() - 86400;
</code></pre>
<h2 id="helper-functions"><a class="header" href="#helper-functions">Helper Functions</a></h2>
<p>Turso provides two scalar functions to decode the binary records stored in the <code>before</code>, <code>after</code>, and <code>updates</code> columns.</p>
<h3 id="table_columns_json_arraytable_name"><a class="header" href="#table_columns_json_arraytable_name">table_columns_json_array(table_name)</a></h3>
<p><strong>table_columns_json_array(table_name) -&gt; text</strong></p>
<p>Return a JSON array of column names for the given table. This can be used as the first argument to <code>bin_record_json_object</code> to decode a CDC binary record.</p>
<pre><code class="language-sql">CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL);
SELECT table_columns_json_array('products');
-- ["id","name","price"]
</code></pre>
<h3 id="bin_record_json_objectcolumns_json-blob"><a class="header" href="#bin_record_json_objectcolumns_json-blob">bin_record_json_object(columns_json, blob)</a></h3>
<p><strong>bin_record_json_object(columns_json, blob) -&gt; text</strong></p>
<p>Decode a binary record blob into a JSON object, using the column names from the first argument to label each field. The first argument should be a JSON array of column name strings (typically from <code>table_columns_json_array</code>).</p>
<pre><code class="language-sql">-- Decode the "after" column of a CDC row
SELECT bin_record_json_object(
    table_columns_json_array('products'),
    "after"
) FROM turso_cdc
WHERE table_name = 'products' AND change_type = 1;
</code></pre>
<h2 id="examples-24"><a class="header" href="#examples-24">Examples</a></h2>
<h3 id="basic-change-tracking"><a class="header" href="#basic-change-tracking">Basic Change Tracking</a></h3>
<pre><code class="language-sql">CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    name TEXT,
    email TEXT
);

-- Enable CDC in id mode
PRAGMA unstable_capture_data_changes_conn('id');

-- Make some changes
INSERT INTO users VALUES (1, 'Alice', 'alice@example.com');
INSERT INTO users VALUES (2, 'Bob', 'bob@example.com');
UPDATE users SET email = 'alice@newdomain.com' WHERE id = 1;
DELETE FROM users WHERE id = 2;

-- View the captured changes
SELECT change_id, change_type, table_name, id
FROM turso_cdc;
-- 1|1|users|1
-- 2|1|users|2
-- 3|0|users|1
-- 4|-1|users|2
</code></pre>
<h3 id="full-mode-with-beforeafter-state"><a class="header" href="#full-mode-with-beforeafter-state">Full Mode with Before/After State</a></h3>
<pre><code class="language-sql">CREATE TABLE inventory (
    id INTEGER PRIMARY KEY,
    qty INTEGER
);

PRAGMA unstable_capture_data_changes_conn('full');

INSERT INTO inventory VALUES (1, 100);
UPDATE inventory SET qty = 80 WHERE id = 1;

-- The INSERT has an "after" record but no "before"
-- The UPDATE has both "before" and "after" records, plus "updates"
SELECT change_id, change_type, "before" IS NOT NULL AS has_before,
       "after" IS NOT NULL AS has_after, updates IS NOT NULL AS has_updates
FROM turso_cdc;
-- 1|1|0|1|0
-- 2|0|1|1|1
</code></pre>
<h3 id="custom-cdc-table-name"><a class="header" href="#custom-cdc-table-name">Custom CDC Table Name</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (id INTEGER PRIMARY KEY, total REAL);

-- Store changes in a table named "order_audit"
PRAGMA unstable_capture_data_changes_conn('id,order_audit');

INSERT INTO orders VALUES (1, 99.95);

SELECT change_id, change_type, table_name, id FROM order_audit;
-- 1|1|orders|1
</code></pre>
<h3 id="per-connection-isolation"><a class="header" href="#per-connection-isolation">Per-Connection Isolation</a></h3>
<p>CDC is configured per connection. Each connection can use a different mode and a different CDC table. Changes made by a connection that does not have CDC enabled are not recorded.</p>
<pre><code class="language-sql">-- Connection 1 captures to "audit_log"
PRAGMA unstable_capture_data_changes_conn('full,audit_log');

-- Connection 2 captures to "sync_queue"
PRAGMA unstable_capture_data_changes_conn('id,sync_queue');

-- Changes from Connection 1 go to "audit_log"
-- Changes from Connection 2 go to "sync_queue"
</code></pre>
<p>Only changes executed by the connection that enabled CDC are recorded. If another connection modifies the same table without CDC enabled, those changes do not appear in any CDC table.</p>
<h3 id="schema-changes"><a class="header" href="#schema-changes">Schema Changes</a></h3>
<p>In <code>full</code> mode, DDL statements (CREATE TABLE, DROP TABLE, ALTER TABLE, CREATE INDEX, DROP INDEX) are also tracked as changes to <code>sqlite_schema</code>.</p>
<pre><code class="language-sql">PRAGMA unstable_capture_data_changes_conn('full');

CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT);
-- Recorded as an INSERT into sqlite_schema

DROP TABLE products;
-- Recorded as a DELETE from sqlite_schema
</code></pre>
<h3 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h3>
<p>CDC respects transaction boundaries. Changes within a transaction are recorded when the transaction commits. If a transaction is rolled back, no CDC entries are created for those changes.</p>
<pre><code class="language-sql">CREATE TABLE accounts (id INTEGER PRIMARY KEY, balance REAL);
PRAGMA unstable_capture_data_changes_conn('id');

BEGIN;
INSERT INTO accounts VALUES (1, 1000.00);
INSERT INTO accounts VALUES (2, 2000.00);
COMMIT;

-- Both inserts are recorded after COMMIT
SELECT change_id, change_type, id FROM turso_cdc;
-- 1|1|1
-- 2|1|2
</code></pre>
<h3 id="failed-statements"><a class="header" href="#failed-statements">Failed Statements</a></h3>
<p>When a statement fails (for example, due to a constraint violation), neither the data change nor the CDC entry is recorded. Only successful operations appear in the CDC table.</p>
<pre><code class="language-sql">CREATE TABLE tags (id INTEGER PRIMARY KEY, label TEXT UNIQUE);
PRAGMA unstable_capture_data_changes_conn('id');

INSERT INTO tags (label) VALUES ('urgent'), ('review');
-- This fails because 'urgent' already exists:
-- INSERT INTO tags (label) VALUES ('new'), ('other'), ('urgent');

INSERT INTO tags (label) VALUES ('done');

-- Only the successful inserts are recorded
SELECT change_id, change_type, table_name FROM turso_cdc;
-- 1|1|tags
-- 2|1|tags
-- 3|1|tags
</code></pre>
<h2 id="compatibility-21"><a class="header" href="#compatibility-21">Compatibility</a></h2>
<p>Change Data Capture is a Turso extension. It is not available in standard SQLite. The PRAGMA <code>unstable_capture_data_changes_conn</code>, the default <code>turso_cdc</code> table, and the helper functions <code>table_columns_json_array()</code> and <code>bin_record_json_object()</code> are all Turso-specific.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="materialized-views"><a class="header" href="#materialized-views">Materialized Views</a></h1>
<blockquote>
<p><strong>Turso Extension.</strong> This feature is not available in SQLite. Materialized views must be explicitly enabled with the <code>--experimental-views</code> flag.</p>
</blockquote>
<h2 id="syntax-28"><a class="header" href="#syntax-28">Syntax</a></h2>
<pre><code class="language-sql">CREATE MATERIALIZED VIEW [IF NOT EXISTS] view-name [(column-name [, ...])]
  AS select-statement
</code></pre>
<pre><code class="language-sql">DROP VIEW [IF EXISTS] view-name
</code></pre>
<h2 id="description-24"><a class="header" href="#description-24">Description</a></h2>
<p>Materialized views in Turso are automatically updating database objects that store the results of a query and keep them current in real-time. Unlike traditional materialized views found in other databases that require manual refresh commands, Turso uses Incremental View Maintenance (IVM) to update materialized views as the underlying data changes.</p>
<p>When you insert, update, or delete rows in a base table, any dependent materialized views are updated within the same transaction. Only the incremental changes are processed – not the entire query – making updates efficient even for complex aggregations over large datasets. Because the view is updated inside the same transaction as the base table modification, materialized views are always consistent and never show stale data.</p>
<h2 id="enabling-materialized-views"><a class="header" href="#enabling-materialized-views">Enabling Materialized Views</a></h2>
<p>Materialized views are an experimental feature. You must pass the <code>--experimental-views</code> flag when starting the Turso CLI:</p>
<pre><code class="language-bash">tursodb --experimental-views database.db
</code></pre>
<p>Without this flag, <code>CREATE MATERIALIZED VIEW</code> statements will fail with an error.</p>
<h2 id="how-incremental-view-maintenance-works"><a class="header" href="#how-incremental-view-maintenance-works">How Incremental View Maintenance Works</a></h2>
<p>Traditional materialized views store a snapshot of query results that becomes stale as underlying data changes. Re-executing the entire query to refresh the view is costly for large datasets.</p>
<p>Turso takes a different approach. Instead of re-computing the entire view, IVM tracks what has changed and updates only the affected portions:</p>
<ul>
<li><strong>INSERT</strong> – Adds the new row’s contribution to the view.</li>
<li><strong>DELETE</strong> – Removes the deleted row’s contribution from the view.</li>
<li><strong>UPDATE</strong> – Treated as a delete of the old value followed by an insert of the new value.</li>
</ul>
<p>This is particularly powerful for aggregations. If a view computes <code>SUM</code> over millions of rows, inserting one new row only requires adding that single value to the existing sum – not re-summing all rows.</p>
<h2 id="creating-materialized-views"><a class="header" href="#creating-materialized-views">Creating Materialized Views</a></h2>
<p>A materialized view is created with <code>CREATE MATERIALIZED VIEW</code>. The <code>AS</code> clause contains a <code>SELECT</code> statement that defines the view’s contents. When the view is created, the query is executed once to populate the initial data, and then incremental maintenance keeps it up to date.</p>
<pre><code class="language-sql">CREATE TABLE sales (product_id INTEGER, quantity INTEGER, day INTEGER);
INSERT INTO sales VALUES
  (1, 2, 1), (2, 5, 1), (1, 1, 2),
  (3, 1, 2), (2, 3, 3), (1, 1, 3);

CREATE MATERIALIZED VIEW daily_totals AS
  SELECT day, SUM(quantity) as total, COUNT(*) as transactions
  FROM sales
  GROUP BY day;

SELECT * FROM daily_totals ORDER BY day;
-- 1|7.0|2
-- 2|2.0|2
-- 3|4.0|2
</code></pre>
<p>Once created, a materialized view is queried like any regular table.</p>
<h3 id="supported-query-features"><a class="header" href="#supported-query-features">Supported Query Features</a></h3>
<p>Materialized views support a wide range of SQL constructs in their defining query:</p>
<ul>
<li><strong>WHERE</strong> filters</li>
<li><strong>GROUP BY</strong> with positional references, aliases, or expressions</li>
<li><strong>Aggregate functions</strong>: <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code> (including <code>DISTINCT</code> variants like <code>COUNT(DISTINCT ...)</code>, <code>SUM(DISTINCT ...)</code>)</li>
<li><strong>JOINs</strong> (two-way and three-way)</li>
<li><strong>UNION</strong> and <strong>UNION ALL</strong></li>
<li><strong>DISTINCT</strong></li>
<li><strong>Scalar expressions and functions</strong> in the select list (e.g., <code>b + a</code>, <code>min(a, b)</code>)</li>
<li><strong>BETWEEN</strong>, <strong>IN</strong>, and <strong>CAST</strong> in <code>WHERE</code> clauses</li>
</ul>
<h2 id="automatic-incremental-updates"><a class="header" href="#automatic-incremental-updates">Automatic Incremental Updates</a></h2>
<p>Materialized views stay current automatically. Every INSERT, UPDATE, and DELETE on a base table incrementally updates all dependent materialized views.</p>
<h3 id="insert-maintenance"><a class="header" href="#insert-maintenance">Insert Maintenance</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (
  order_id INTEGER PRIMARY KEY,
  customer_id INTEGER,
  amount INTEGER
);
INSERT INTO orders VALUES (1, 100, 50), (2, 200, 75);

CREATE MATERIALIZED VIEW customer_totals AS
  SELECT customer_id, SUM(amount) as total, COUNT(*) as order_count
  FROM orders
  GROUP BY customer_id;

SELECT * FROM customer_totals ORDER BY customer_id;
-- 100|50.0|1
-- 200|75.0|1

-- Insert a new order for customer 100
INSERT INTO orders VALUES (3, 100, 25);
SELECT * FROM customer_totals ORDER BY customer_id;
-- 100|75.0|2
-- 200|75.0|1
</code></pre>
<h3 id="update-maintenance"><a class="header" href="#update-maintenance">Update Maintenance</a></h3>
<pre><code class="language-sql">-- Continuing from above: update the amount of order 2
UPDATE orders SET amount = 100 WHERE order_id = 2;
SELECT * FROM customer_totals ORDER BY customer_id;
-- 100|75.0|2
-- 200|100.0|1
</code></pre>
<h3 id="delete-maintenance"><a class="header" href="#delete-maintenance">Delete Maintenance</a></h3>
<pre><code class="language-sql">-- Continuing from above: delete an order
DELETE FROM orders WHERE order_id = 1;
SELECT * FROM customer_totals ORDER BY customer_id;
-- 100|25.0|1
-- 200|100.0|1
</code></pre>
<h2 id="transactional-consistency"><a class="header" href="#transactional-consistency">Transactional Consistency</a></h2>
<p>Materialized views are updated inside the same transaction as the base table modification. This guarantees:</p>
<ul>
<li><strong>Atomicity</strong> – View changes are committed or rolled back together with base table changes.</li>
<li><strong>Consistency</strong> – Views never show partial or inconsistent state.</li>
<li><strong>Rollback safety</strong> – If a transaction rolls back, all view changes are rolled back too.</li>
</ul>
<pre><code class="language-sql">CREATE TABLE sales (product_id INTEGER, amount INTEGER);
INSERT INTO sales VALUES (1, 100), (1, 200), (2, 150), (2, 250);

CREATE MATERIALIZED VIEW product_totals AS
  SELECT product_id, SUM(amount) as total, COUNT(*) as cnt
  FROM sales
  GROUP BY product_id;

SELECT * FROM product_totals ORDER BY product_id;
-- 1|300.0|2
-- 2|400.0|2

BEGIN;
INSERT INTO sales VALUES (1, 50), (3, 300);
SELECT * FROM product_totals ORDER BY product_id;
-- 1|350.0|3
-- 2|400.0|2
-- 3|300.0|1

ROLLBACK;

-- After rollback, the view returns to its previous state
SELECT * FROM product_totals ORDER BY product_id;
-- 1|300.0|2
-- 2|400.0|2
</code></pre>
<h2 id="materialized-views-with-joins"><a class="header" href="#materialized-views-with-joins">Materialized Views with JOINs</a></h2>
<p>Materialized views can be defined over joins between two or more tables. Incremental maintenance applies to changes on any of the joined tables.</p>
<pre><code class="language-sql">CREATE TABLE customers (id INTEGER PRIMARY KEY, name TEXT, city TEXT);
CREATE TABLE orders (id INTEGER PRIMARY KEY, customer_id INTEGER, product_id INTEGER, quantity INTEGER);
CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER);

INSERT INTO customers VALUES (1, 'Alice', 'NYC'), (2, 'Bob', 'LA');
INSERT INTO products VALUES (1, 'Widget', 10), (2, 'Gadget', 20);
INSERT INTO orders VALUES (1, 1, 1, 5), (2, 1, 2, 3), (3, 2, 1, 2);

CREATE MATERIALIZED VIEW sales_summary AS
  SELECT c.name AS customer_name, p.name AS product_name, o.quantity
  FROM customers c
  JOIN orders o ON c.id = o.customer_id
  JOIN products p ON o.product_id = p.id;

SELECT * FROM sales_summary ORDER BY customer_name, product_name;
-- Alice|Gadget|3
-- Alice|Widget|5
-- Bob|Widget|2
</code></pre>
<p>Inserting into any of the three tables will incrementally update the view.</p>
<h2 id="materialized-views-with-distinct"><a class="header" href="#materialized-views-with-distinct">Materialized Views with DISTINCT</a></h2>
<p>The <code>DISTINCT</code> keyword is supported both at the query level and inside aggregate functions.</p>
<h3 id="query-level-distinct"><a class="header" href="#query-level-distinct">Query-Level DISTINCT</a></h3>
<pre><code class="language-sql">CREATE TABLE events (id INTEGER PRIMARY KEY, category TEXT, status TEXT);
INSERT INTO events VALUES (1, 'A', 'open'), (2, 'B', 'open'),
  (3, 'A', 'open'), (4, 'B', 'closed');

CREATE MATERIALIZED VIEW unique_categories AS
  SELECT DISTINCT category FROM events;

SELECT * FROM unique_categories ORDER BY category;
-- A
-- B
</code></pre>
<h3 id="distinct-aggregates"><a class="header" href="#distinct-aggregates">DISTINCT Aggregates</a></h3>
<pre><code class="language-sql">CREATE TABLE orders (id INTEGER PRIMARY KEY, customer TEXT, product TEXT, amount INTEGER);
INSERT INTO orders VALUES (1, 'Alice', 'Widget', 10), (2, 'Alice', 'Gadget', 20),
  (3, 'Alice', 'Widget', 15), (4, 'Bob', 'Widget', 30), (5, 'Bob', 'Widget', 25);

CREATE MATERIALIZED VIEW customer_stats AS
  SELECT customer, COUNT(DISTINCT product) AS unique_products,
    SUM(amount) AS total_amount
  FROM orders
  GROUP BY customer;

SELECT * FROM customer_stats ORDER BY customer;
-- Alice|2|45.0
-- Bob|1|55.0
</code></pre>
<h2 id="materialized-views-with-union"><a class="header" href="#materialized-views-with-union">Materialized Views with UNION</a></h2>
<p>Materialized views can use <code>UNION</code> and <code>UNION ALL</code> to combine results from multiple queries:</p>
<pre><code class="language-sql">CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT);
CREATE TABLE contractors (id INTEGER PRIMARY KEY, name TEXT, agency TEXT);
INSERT INTO employees VALUES (1, 'Alice', 'Engineering'), (2, 'Bob', 'Marketing');
INSERT INTO contractors VALUES (1, 'Charlie', 'TechCorp'), (2, 'Diana', 'DesignCo');

CREATE MATERIALIZED VIEW all_workers AS
  SELECT name, department AS affiliation FROM employees
  UNION ALL
  SELECT name, agency AS affiliation FROM contractors;

SELECT * FROM all_workers ORDER BY name;
-- Alice|Engineering
-- Bob|Marketing
-- Charlie|TechCorp
-- Diana|DesignCo
</code></pre>
<h2 id="dropping-materialized-views"><a class="header" href="#dropping-materialized-views">Dropping Materialized Views</a></h2>
<p>Materialized views are dropped using <code>DROP VIEW</code>, the same syntax used for regular views. This removes the view definition and all associated internal state tables.</p>
<pre><code class="language-sql">DROP VIEW sales_summary;
</code></pre>
<p>After dropping, the view can be recreated with the same or a different definition:</p>
<pre><code class="language-sql">CREATE MATERIALIZED VIEW sales_summary AS
  SELECT product_id, SUM(amount) AS revenue
  FROM sales
  GROUP BY product_id;
</code></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<p>Materialized views trade write-time overhead for read-time performance. Each INSERT, UPDATE, or DELETE on a base table must also update any dependent materialized views. Consider these trade-offs when designing your schema:</p>
<ul>
<li>Use materialized views for data that is read frequently and written infrequently.</li>
<li>Avoid creating many materialized views on tables with very high write rates.</li>
<li>Aggregation views benefit the most: a query that would scan millions of rows becomes a simple table lookup.</li>
<li>Join-based views avoid re-executing expensive joins on every read.</li>
</ul>
<h2 id="current-limitations"><a class="header" href="#current-limitations">Current Limitations</a></h2>
<p>As an experimental feature, materialized views have some limitations:</p>
<ul>
<li>Not all SQL functions are supported in view definitions.</li>
<li>Views cannot reference other views.</li>
<li>The <code>--experimental-views</code> flag must be provided at startup.</li>
</ul>
<h2 id="compatibility-22"><a class="header" href="#compatibility-22">Compatibility</a></h2>
<ul>
<li>This feature is a Turso extension and is not available in SQLite.</li>
<li>Materialized views are dropped with <code>DROP VIEW</code>, not a separate <code>DROP MATERIALIZED VIEW</code> statement.</li>
<li>The <code>--experimental-views</code> flag is required. The feature is experimental and behavior may change in future releases.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="encryption-at-rest"><a class="header" href="#encryption-at-rest">Encryption at Rest</a></h1>
<blockquote>
<p><strong>Turso Extension.</strong> This feature is not available in SQLite. Encryption must be explicitly enabled with the <code>--experimental-encryption</code> flag.</p>
</blockquote>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Turso supports transparent at-rest encryption to protect database files from unauthorized access. When enabled, all data written to disk is automatically encrypted and all data read from disk is automatically decrypted, with no changes required to SQL queries or application logic.</p>
<p>Encryption operates at the page level: each database page is independently encrypted and authenticated. A random nonce is generated for every page write, and an authentication tag is stored alongside the ciphertext. If a page is corrupted or tampered with, decryption will fail with an error rather than returning garbage data.</p>
<p>Encrypted databases use a modified file header. The first 16 bytes of a standard SQLite database contain the magic string <code>SQLite format 3\0</code>. In an encrypted Turso database, these bytes are replaced with a Turso-specific header that identifies the file as encrypted and records the cipher algorithm. The rest of the database header (bytes 16 through 99) remains unencrypted but is protected by authenticated encryption, so any tampering with the header is detected on read.</p>
<h2 id="enabling-encryption"><a class="header" href="#enabling-encryption">Enabling Encryption</a></h2>
<p>Encryption is an experimental feature. You must pass the <code>--experimental-encryption</code> flag when starting the Turso CLI:</p>
<pre><code class="language-bash">tursodb --experimental-encryption database.db
</code></pre>
<p>Without this flag, the <code>PRAGMA cipher</code> and <code>PRAGMA hexkey</code> statements are not available.</p>
<h2 id="supported-ciphers"><a class="header" href="#supported-ciphers">Supported Ciphers</a></h2>
<p>Turso supports eight authenticated encryption algorithms across two families. All ciphers provide both confidentiality and integrity verification.</p>
<h3 id="aes-gcm-family"><a class="header" href="#aes-gcm-family">AES-GCM Family</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Cipher Name</th><th>Key Size</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>aes128gcm</code></td><td>16 bytes (128-bit)</td><td>AES-128 in Galois/Counter Mode</td></tr>
<tr><td><code>aes256gcm</code></td><td>32 bytes (256-bit)</td><td>AES-256 in Galois/Counter Mode</td></tr>
</tbody>
</table>
</div>
<p>AES-GCM is a widely deployed AEAD cipher. It is a solid choice when hardware AES-NI acceleration is available.</p>
<h3 id="aegis-family"><a class="header" href="#aegis-family">AEGIS Family</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Cipher Name</th><th>Key Size</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>aegis256</code></td><td>32 bytes (256-bit)</td><td>AEGIS-256 (recommended)</td></tr>
<tr><td><code>aegis128l</code></td><td>16 bytes (128-bit)</td><td>AEGIS-128L</td></tr>
<tr><td><code>aegis128x2</code></td><td>16 bytes (128-bit)</td><td>AEGIS-128 with 2x parallelization</td></tr>
<tr><td><code>aegis128x4</code></td><td>16 bytes (128-bit)</td><td>AEGIS-128 with 4x parallelization</td></tr>
<tr><td><code>aegis256x2</code></td><td>32 bytes (256-bit)</td><td>AEGIS-256 with 2x parallelization</td></tr>
<tr><td><code>aegis256x4</code></td><td>32 bytes (256-bit)</td><td>AEGIS-256 with 4x parallelization</td></tr>
</tbody>
</table>
</div>
<p>AEGIS ciphers generally offer better performance than AES-GCM while maintaining strong security properties. <strong><code>aegis256</code> is the recommended default</strong> for most use cases. The <code>x2</code> and <code>x4</code> variants exploit instruction-level parallelism and may perform better on CPUs with wide execution pipelines.</p>
<p>Cipher names are case-insensitive and accept multiple separator styles. For example, <code>aegis256</code>, <code>aegis-256</code>, and <code>aegis_256</code> all refer to the same algorithm. Similarly, <code>aes128gcm</code>, <code>aes-128-gcm</code>, and <code>aes_128_gcm</code> are equivalent.</p>
<h2 id="generating-encryption-keys"><a class="header" href="#generating-encryption-keys">Generating Encryption Keys</a></h2>
<p>Keys are provided as hexadecimal strings. Use OpenSSL or any cryptographically secure random number generator:</p>
<pre><code class="language-bash"># Generate a 256-bit key (32 bytes) -- for aes256gcm, aegis256, aegis256x2, aegis256x4
openssl rand -hex 32

# Generate a 128-bit key (16 bytes) -- for aes128gcm, aegis128l, aegis128x2, aegis128x4
openssl rand -hex 16
</code></pre>
<p>A 256-bit key produces a 64-character hex string. A 128-bit key produces a 32-character hex string.</p>
<p><strong>Store your encryption key securely.</strong> If the key is lost, the encrypted database cannot be recovered. There is no key recovery mechanism.</p>
<h2 id="creating-an-encrypted-database"><a class="header" href="#creating-an-encrypted-database">Creating an Encrypted Database</a></h2>
<p>There are two ways to configure encryption: PRAGMAs in the SQL shell, or URI parameters on the command line.</p>
<h3 id="method-1-pragmas"><a class="header" href="#method-1-pragmas">Method 1: PRAGMAs</a></h3>
<p>Start Turso with the encryption flag, then set the cipher and key before creating any tables:</p>
<pre><code class="language-bash">tursodb --experimental-encryption database.db
</code></pre>
<pre><code class="language-sql">PRAGMA cipher = 'aegis256';
PRAGMA hexkey = '2d7a30108d3eb3e45c90a732041fe54778bdcf707c76749fab7da335d1b39c1d';

-- The database is now encrypted. Use it normally.
CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
INSERT INTO users VALUES (1, 'Alice');
SELECT * FROM users;
</code></pre>
<p>Both <code>PRAGMA cipher</code> and <code>PRAGMA hexkey</code> must be set before any other database operations. The encryption context is established when both values are present. Once set, the cipher and key cannot be changed within the same session.</p>
<h3 id="method-2-uri-parameters"><a class="header" href="#method-2-uri-parameters">Method 2: URI Parameters</a></h3>
<p>Specify the cipher and key directly in the database URI:</p>
<pre><code class="language-bash">tursodb --experimental-encryption \
  "file:database.db?cipher=aegis256&amp;hexkey=2d7a30108d3eb3e45c90a732041fe54778bdcf707c76749fab7da335d1b39c1d"
</code></pre>
<p>This is equivalent to setting the PRAGMAs and is the preferred method for scripting and automation.</p>
<h2 id="opening-an-encrypted-database"><a class="header" href="#opening-an-encrypted-database">Opening an Encrypted Database</a></h2>
<p>To open an existing encrypted database, you must provide the correct cipher and key. The recommended approach is URI parameters:</p>
<pre><code class="language-bash">tursodb --experimental-encryption \
  "file:database.db?cipher=aegis256&amp;hexkey=2d7a30108d3eb3e45c90a732041fe54778bdcf707c76749fab7da335d1b39c1d"
</code></pre>
<p>Alternatively, open the file and set PRAGMAs before any queries:</p>
<pre><code class="language-bash">tursodb --experimental-encryption database.db
</code></pre>
<pre><code class="language-sql">PRAGMA cipher = 'aegis256';
PRAGMA hexkey = '2d7a30108d3eb3e45c90a732041fe54778bdcf707c76749fab7da335d1b39c1d';

-- Database is now accessible
SELECT * FROM users;
</code></pre>
<p>Opening an encrypted database without providing the correct cipher and key will fail. Providing the wrong cipher or the wrong key will also fail. Turso does not silently return corrupted data.</p>
<h2 id="reading-encryption-settings"><a class="header" href="#reading-encryption-settings">Reading Encryption Settings</a></h2>
<p>You can query the current cipher with:</p>
<pre><code class="language-sql">PRAGMA cipher;
-- Returns the cipher name, e.g. 'aegis256'
</code></pre>
<p>This returns the cipher algorithm configured for the current session. If no cipher has been set, nothing is returned.</p>
<h2 id="pragmas-reference"><a class="header" href="#pragmas-reference">PRAGMAs Reference</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>PRAGMA</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>PRAGMA cipher = 'name'</code></td><td>Write</td><td>Set the encryption cipher for the session. Must be set before any I/O.</td></tr>
<tr><td><code>PRAGMA cipher</code></td><td>Read</td><td>Return the current cipher name.</td></tr>
<tr><td><code>PRAGMA hexkey = 'hex_string'</code></td><td>Write</td><td>Set the encryption key as a hex-encoded string. Must match the cipher’s key size.</td></tr>
</tbody>
</table>
</div>
<p>The key size must match the cipher:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key Size</th><th>Hex String Length</th><th>Ciphers</th></tr>
</thead>
<tbody>
<tr><td>16 bytes</td><td>32 characters</td><td><code>aes128gcm</code>, <code>aegis128l</code>, <code>aegis128x2</code>, <code>aegis128x4</code></td></tr>
<tr><td>32 bytes</td><td>64 characters</td><td><code>aes256gcm</code>, <code>aegis256</code>, <code>aegis256x2</code>, <code>aegis256x4</code></td></tr>
</tbody>
</table>
</div>
<h2 id="examples-25"><a class="header" href="#examples-25">Examples</a></h2>
<h3 id="create-and-query-an-encrypted-database"><a class="header" href="#create-and-query-an-encrypted-database">Create and Query an Encrypted Database</a></h3>
<pre><code class="language-bash"># Generate a key
KEY=$(openssl rand -hex 32)

# Create an encrypted database
tursodb --experimental-encryption \
  "file:secret.db?cipher=aegis256&amp;hexkey=$KEY" &lt;&lt;'SQL'
CREATE TABLE secrets (id INTEGER PRIMARY KEY, label TEXT, value TEXT);
INSERT INTO secrets VALUES (1, 'api_key', 'sk-abc123');
INSERT INTO secrets VALUES (2, 'db_password', 'hunter2');
SELECT * FROM secrets;
SQL
</code></pre>
<h3 id="verify-encryption-prevents-unauthorized-access"><a class="header" href="#verify-encryption-prevents-unauthorized-access">Verify Encryption Prevents Unauthorized Access</a></h3>
<pre><code class="language-bash"># Try opening without credentials -- this will fail
tursodb --experimental-encryption secret.db &lt;&lt;'SQL'
SELECT * FROM secrets;
SQL
# Error: database is encrypted or is not a database
</code></pre>
<h3 id="using-a-128-bit-cipher"><a class="header" href="#using-a-128-bit-cipher">Using a 128-bit Cipher</a></h3>
<pre><code class="language-bash">KEY128=$(openssl rand -hex 16)

tursodb --experimental-encryption \
  "file:fast.db?cipher=aes128gcm&amp;hexkey=$KEY128" &lt;&lt;'SQL'
CREATE TABLE logs (id INTEGER PRIMARY KEY, message TEXT);
INSERT INTO logs VALUES (1, 'System started');
SELECT * FROM logs;
SQL
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="database-is-encrypted-or-is-not-a-database"><a class="header" href="#database-is-encrypted-or-is-not-a-database">“Database is encrypted or is not a database”</a></h3>
<p>This error appears when:</p>
<ul>
<li>Opening an encrypted database without providing the cipher and key.</li>
<li>Providing the wrong cipher algorithm for an existing encrypted database.</li>
<li>Providing the wrong key.</li>
<li>The database file is corrupted.</li>
</ul>
<h3 id="invalid-hex-string"><a class="header" href="#invalid-hex-string">“Invalid hex string”</a></h3>
<p>This means the <code>hexkey</code> value is not valid hexadecimal. Ensure the string contains only characters <code>0-9</code> and <code>a-f</code> (case-insensitive) and that its length matches the cipher’s key size (32 hex characters for 16-byte keys, 64 hex characters for 32-byte keys).</p>
<h3 id="cannot-reset-encryption-attributes-if-already-set-in-the-session"><a class="header" href="#cannot-reset-encryption-attributes-if-already-set-in-the-session">“Cannot reset encryption attributes if already set in the session”</a></h3>
<p>The cipher and key can only be set once per session. If you need to change encryption parameters, close the connection and open a new one.</p>
<h2 id="compatibility-23"><a class="header" href="#compatibility-23">Compatibility</a></h2>
<ul>
<li>This feature is a Turso extension and is not available in SQLite.</li>
<li>Encrypted database files are not compatible with SQLite or other SQLite-based tools. They can only be opened by Turso with the correct cipher and key.</li>
<li>The <code>--experimental-encryption</code> flag is required. The feature is experimental and the on-disk format may change in future releases.</li>
<li>There is currently no built-in mechanism to change the encryption key of an existing database or to convert between encrypted and unencrypted formats. To re-key a database, create a new encrypted database and copy the data.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
